//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g 2018-08-27 19:40:23

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	 using System.Text;
	 using CoolGrammar.Grammar;
	

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace CoolGrammar
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class CoolGrammarParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASSIGN", "ATSIGN", "BREAK", "Block", "CAPITAL_LETTER", "CASE", "CLASS", "COLON", "COMMA", "COMMENT", "CaseExpr", "Class", "DIGIT", "DIV", "DO", "DOT", "DoWhile", "DotObjectInvoke", "DotTypeInvoke", "ELSE", "EQUAL", "ESAC", "ExprList", "FALSE", "FI", "FeatureList", "FuncDef", "FunctionArgsList", "GE", "GT", "HENCE", "IF", "IN", "INHERITS", "INTEGER", "ISVOID", "IdValue", "ImplicitInvoke", "LE", "LET", "LKEY", "LOOP", "LOWER_LETTER", "LPAREN", "LT", "LetExprs", "LocalOrFieldInit", "MINUS", "MULT", "MULTILINE_COMMENT", "NEG", "NEW", "NOT", "OBJ_ID", "OD", "OF", "OR", "PLUS", "POOL", "Params", "Program", "RKEY", "RPAREN", "SELF", "SEMI", "STRING", "THEN", "TRUE", "TYPE_ID", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int ASSIGN=5;
	public const int ATSIGN=6;
	public const int BREAK=7;
	public const int Block=8;
	public const int CAPITAL_LETTER=9;
	public const int CASE=10;
	public const int CLASS=11;
	public const int COLON=12;
	public const int COMMA=13;
	public const int COMMENT=14;
	public const int CaseExpr=15;
	public const int Class=16;
	public const int DIGIT=17;
	public const int DIV=18;
	public const int DO=19;
	public const int DOT=20;
	public const int DoWhile=21;
	public const int DotObjectInvoke=22;
	public const int DotTypeInvoke=23;
	public const int ELSE=24;
	public const int EQUAL=25;
	public const int ESAC=26;
	public const int ExprList=27;
	public const int FALSE=28;
	public const int FI=29;
	public const int FeatureList=30;
	public const int FuncDef=31;
	public const int FunctionArgsList=32;
	public const int GE=33;
	public const int GT=34;
	public const int HENCE=35;
	public const int IF=36;
	public const int IN=37;
	public const int INHERITS=38;
	public const int INTEGER=39;
	public const int ISVOID=40;
	public const int IdValue=41;
	public const int ImplicitInvoke=42;
	public const int LE=43;
	public const int LET=44;
	public const int LKEY=45;
	public const int LOOP=46;
	public const int LOWER_LETTER=47;
	public const int LPAREN=48;
	public const int LT=49;
	public const int LetExprs=50;
	public const int LocalOrFieldInit=51;
	public const int MINUS=52;
	public const int MULT=53;
	public const int MULTILINE_COMMENT=54;
	public const int NEG=55;
	public const int NEW=56;
	public const int NOT=57;
	public const int OBJ_ID=58;
	public const int OD=59;
	public const int OF=60;
	public const int OR=61;
	public const int PLUS=62;
	public const int POOL=63;
	public const int Params=64;
	public const int Program=65;
	public const int RKEY=66;
	public const int RPAREN=67;
	public const int SELF=68;
	public const int SEMI=69;
	public const int STRING=70;
	public const int THEN=71;
	public const int TRUE=72;
	public const int TYPE_ID=73;
	public const int WHILE=74;
	public const int WS=75;

	public CoolGrammarParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public CoolGrammarParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return CoolGrammarParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g"; } }


		
		public override void ReportError(RecognitionException e)
	    	{
	    		base.ReportError(e);
	        		var stringerror =  GetErrorMessage(e, TokenNames);
			Logger.LogError(e.Line, e.CharPositionInLine,stringerror);
	                  
	    	}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:164:8: public program : ( class SEMI )+ -> ^( Program ( class )+ ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMI2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> class1 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMI2_tree = default(object);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_class=new RewriteRuleSubtreeStream(adaptor,"rule class");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(164, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:164:16: ( ( class SEMI )+ -> ^( Program ( class )+ ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:165:3: ( class SEMI )+
			{
			DebugLocation(165, 3);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:165:3: ( class SEMI )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==CLASS))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:165:4: class SEMI
					{
					DebugLocation(165, 4);
					PushFollow(Follow._class_in_program851);
					class1=@class();
					PopFollow();

					stream_class.Add(class1.Tree);
					DebugLocation(165, 10);
					SEMI2=(IToken)Match(input,SEMI,Follow._SEMI_in_program853);  
					stream_SEMI.Add(SEMI2);


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: class
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 166:3: -> ^( Program ( class )+ )
			{
				DebugLocation(166, 7);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:166:7: ^( Program ( class )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(166, 10);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(Program, "Program"), root_1);

				DebugLocation(166, 18);
				if (!(stream_class.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_class.HasNext )
				{
					DebugLocation(166, 18);
					adaptor.AddChild(root_1, stream_class.NextTree());

				}
				stream_class.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(167, 2);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_class();
	partial void LeaveRule_class();

	// $ANTLR start "class"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:169:1: class : CLASS TYPE_ID ( INHERITS TYPE_ID )? LKEY feature_list RKEY -> ^( CLASS TYPE_ID feature_list ( TYPE_ID )? ) ;
	[GrammarRule("class")]
	private AstParserRuleReturnScope<object, IToken> @class()
	{
		EnterRule_class();
		EnterRule("class", 2);
		TraceIn("class", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CLASS3 = default(IToken);
		IToken TYPE_ID4 = default(IToken);
		IToken INHERITS5 = default(IToken);
		IToken TYPE_ID6 = default(IToken);
		IToken LKEY7 = default(IToken);
		IToken RKEY9 = default(IToken);
		AstParserRuleReturnScope<object, IToken> feature_list8 = default(AstParserRuleReturnScope<object, IToken>);

		object CLASS3_tree = default(object);
		object TYPE_ID4_tree = default(object);
		object INHERITS5_tree = default(object);
		object TYPE_ID6_tree = default(object);
		object LKEY7_tree = default(object);
		object RKEY9_tree = default(object);
		RewriteRuleITokenStream stream_TYPE_ID=new RewriteRuleITokenStream(adaptor,"token TYPE_ID");
		RewriteRuleITokenStream stream_RKEY=new RewriteRuleITokenStream(adaptor,"token RKEY");
		RewriteRuleITokenStream stream_LKEY=new RewriteRuleITokenStream(adaptor,"token LKEY");
		RewriteRuleITokenStream stream_INHERITS=new RewriteRuleITokenStream(adaptor,"token INHERITS");
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleSubtreeStream stream_feature_list=new RewriteRuleSubtreeStream(adaptor,"rule feature_list");
		try { DebugEnterRule(GrammarFileName, "class");
		DebugLocation(169, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:169:8: ( CLASS TYPE_ID ( INHERITS TYPE_ID )? LKEY feature_list RKEY -> ^( CLASS TYPE_ID feature_list ( TYPE_ID )? ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:170:3: CLASS TYPE_ID ( INHERITS TYPE_ID )? LKEY feature_list RKEY
			{
			DebugLocation(170, 3);
			CLASS3=(IToken)Match(input,CLASS,Follow._CLASS_in_class886);  
			stream_CLASS.Add(CLASS3);

			DebugLocation(170, 9);
			TYPE_ID4=(IToken)Match(input,TYPE_ID,Follow._TYPE_ID_in_class888);  
			stream_TYPE_ID.Add(TYPE_ID4);

			DebugLocation(170, 17);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:170:17: ( INHERITS TYPE_ID )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==INHERITS))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:170:18: INHERITS TYPE_ID
				{
				DebugLocation(170, 18);
				INHERITS5=(IToken)Match(input,INHERITS,Follow._INHERITS_in_class891);  
				stream_INHERITS.Add(INHERITS5);

				DebugLocation(170, 27);
				TYPE_ID6=(IToken)Match(input,TYPE_ID,Follow._TYPE_ID_in_class893);  
				stream_TYPE_ID.Add(TYPE_ID6);


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(170, 37);
			LKEY7=(IToken)Match(input,LKEY,Follow._LKEY_in_class897);  
			stream_LKEY.Add(LKEY7);

			DebugLocation(170, 42);
			PushFollow(Follow._feature_list_in_class899);
			feature_list8=feature_list();
			PopFollow();

			stream_feature_list.Add(feature_list8.Tree);
			DebugLocation(170, 56);
			RKEY9=(IToken)Match(input,RKEY,Follow._RKEY_in_class902);  
			stream_RKEY.Add(RKEY9);



			{
			// AST REWRITE
			// elements: feature_list, CLASS, TYPE_ID, TYPE_ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 171:3: -> ^( CLASS TYPE_ID feature_list ( TYPE_ID )? )
			{
				DebugLocation(171, 6);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:171:6: ^( CLASS TYPE_ID feature_list ( TYPE_ID )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(171, 9);
				root_1 = (object)adaptor.BecomeRoot(stream_CLASS.NextNode(), root_1);

				DebugLocation(171, 15);
				adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());
				DebugLocation(171, 23);
				adaptor.AddChild(root_1, stream_feature_list.NextTree());
				DebugLocation(171, 36);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:171:36: ( TYPE_ID )?
				if (stream_TYPE_ID.HasNext)
				{
					DebugLocation(171, 36);
					adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());

				}
				stream_TYPE_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("class", 2);
			LeaveRule("class", 2);
			LeaveRule_class();
		}
		DebugLocation(172, 2);
		} finally { DebugExitRule(GrammarFileName, "class"); }
		return retval;

	}
	// $ANTLR end "class"

	partial void EnterRule_feature_list();
	partial void LeaveRule_feature_list();

	// $ANTLR start "feature_list"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:173:1: feature_list : ( feature SEMI )* -> ^( FeatureList ( feature )* ) ;
	[GrammarRule("feature_list")]
	private AstParserRuleReturnScope<object, IToken> feature_list()
	{
		EnterRule_feature_list();
		EnterRule("feature_list", 3);
		TraceIn("feature_list", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMI11 = default(IToken);
		AstParserRuleReturnScope<object, IToken> feature10 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMI11_tree = default(object);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_feature=new RewriteRuleSubtreeStream(adaptor,"rule feature");
		try { DebugEnterRule(GrammarFileName, "feature_list");
		DebugLocation(173, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:173:15: ( ( feature SEMI )* -> ^( FeatureList ( feature )* ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:174:3: ( feature SEMI )*
			{
			DebugLocation(174, 3);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:174:3: ( feature SEMI )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==OBJ_ID))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:174:4: feature SEMI
					{
					DebugLocation(174, 4);
					PushFollow(Follow._feature_in_feature_list933);
					feature10=feature();
					PopFollow();

					stream_feature.Add(feature10.Tree);
					DebugLocation(174, 12);
					SEMI11=(IToken)Match(input,SEMI,Follow._SEMI_in_feature_list935);  
					stream_SEMI.Add(SEMI11);


					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }



			{
			// AST REWRITE
			// elements: feature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 175:3: -> ^( FeatureList ( feature )* )
			{
				DebugLocation(175, 6);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:175:6: ^( FeatureList ( feature )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(175, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FeatureList, "FeatureList"), root_1);

				DebugLocation(175, 22);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:175:22: ( feature )*
				while ( stream_feature.HasNext )
				{
					DebugLocation(175, 22);
					adaptor.AddChild(root_1, stream_feature.NextTree());

				}
				stream_feature.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("feature_list", 3);
			LeaveRule("feature_list", 3);
			LeaveRule_feature_list();
		}
		DebugLocation(176, 2);
		} finally { DebugExitRule(GrammarFileName, "feature_list"); }
		return retval;

	}
	// $ANTLR end "feature_list"

	partial void EnterRule_feature();
	partial void LeaveRule_feature();

	// $ANTLR start "feature"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:178:1: feature : ( localOrFieldInit -> localOrFieldInit | method -> method );
	[GrammarRule("feature")]
	private AstParserRuleReturnScope<object, IToken> feature()
	{
		EnterRule_feature();
		EnterRule("feature", 4);
		TraceIn("feature", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> localOrFieldInit12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> method13 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_method=new RewriteRuleSubtreeStream(adaptor,"rule method");
		RewriteRuleSubtreeStream stream_localOrFieldInit=new RewriteRuleSubtreeStream(adaptor,"rule localOrFieldInit");
		try { DebugEnterRule(GrammarFileName, "feature");
		DebugLocation(178, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:178:10: ( localOrFieldInit -> localOrFieldInit | method -> method )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==OBJ_ID))
			{
				int LA4_1 = input.LA(2);

				if ((LA4_1==COLON))
				{
					alt4 = 1;
				}
				else if ((LA4_1==LPAREN))
				{
					alt4 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 4, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:179:5: localOrFieldInit
				{
				DebugLocation(179, 5);
				PushFollow(Follow._localOrFieldInit_in_feature969);
				localOrFieldInit12=localOrFieldInit();
				PopFollow();

				stream_localOrFieldInit.Add(localOrFieldInit12.Tree);


				{
				// AST REWRITE
				// elements: localOrFieldInit
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 179:22: -> localOrFieldInit
				{
					DebugLocation(179, 25);
					adaptor.AddChild(root_0, stream_localOrFieldInit.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:180:7: method
				{
				DebugLocation(180, 7);
				PushFollow(Follow._method_in_feature982);
				method13=method();
				PopFollow();

				stream_method.Add(method13.Tree);


				{
				// AST REWRITE
				// elements: method
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 180:14: -> method
				{
					DebugLocation(180, 17);
					adaptor.AddChild(root_0, stream_method.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("feature", 4);
			LeaveRule("feature", 4);
			LeaveRule_feature();
		}
		DebugLocation(181, 2);
		} finally { DebugExitRule(GrammarFileName, "feature"); }
		return retval;

	}
	// $ANTLR end "feature"

	partial void EnterRule_method();
	partial void LeaveRule_method();

	// $ANTLR start "method"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:183:1: method : OBJ_ID LPAREN ( formal_parameters )? RPAREN COLON TYPE_ID LKEY expression RKEY -> ^( FuncDef OBJ_ID TYPE_ID ( formal_parameters )? expression ) ;
	[GrammarRule("method")]
	private AstParserRuleReturnScope<object, IToken> method()
	{
		EnterRule_method();
		EnterRule("method", 5);
		TraceIn("method", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OBJ_ID14 = default(IToken);
		IToken LPAREN15 = default(IToken);
		IToken RPAREN17 = default(IToken);
		IToken COLON18 = default(IToken);
		IToken TYPE_ID19 = default(IToken);
		IToken LKEY20 = default(IToken);
		IToken RKEY22 = default(IToken);
		AstParserRuleReturnScope<object, IToken> formal_parameters16 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression21 = default(AstParserRuleReturnScope<object, IToken>);

		object OBJ_ID14_tree = default(object);
		object LPAREN15_tree = default(object);
		object RPAREN17_tree = default(object);
		object COLON18_tree = default(object);
		object TYPE_ID19_tree = default(object);
		object LKEY20_tree = default(object);
		object RKEY22_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_TYPE_ID=new RewriteRuleITokenStream(adaptor,"token TYPE_ID");
		RewriteRuleITokenStream stream_RKEY=new RewriteRuleITokenStream(adaptor,"token RKEY");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LKEY=new RewriteRuleITokenStream(adaptor,"token LKEY");
		RewriteRuleITokenStream stream_OBJ_ID=new RewriteRuleITokenStream(adaptor,"token OBJ_ID");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_formal_parameters=new RewriteRuleSubtreeStream(adaptor,"rule formal_parameters");
		try { DebugEnterRule(GrammarFileName, "method");
		DebugLocation(183, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:183:9: ( OBJ_ID LPAREN ( formal_parameters )? RPAREN COLON TYPE_ID LKEY expression RKEY -> ^( FuncDef OBJ_ID TYPE_ID ( formal_parameters )? expression ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:184:4: OBJ_ID LPAREN ( formal_parameters )? RPAREN COLON TYPE_ID LKEY expression RKEY
			{
			DebugLocation(184, 4);
			OBJ_ID14=(IToken)Match(input,OBJ_ID,Follow._OBJ_ID_in_method1003);  
			stream_OBJ_ID.Add(OBJ_ID14);

			DebugLocation(184, 11);
			LPAREN15=(IToken)Match(input,LPAREN,Follow._LPAREN_in_method1005);  
			stream_LPAREN.Add(LPAREN15);

			DebugLocation(184, 18);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:184:18: ( formal_parameters )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==OBJ_ID))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:184:19: formal_parameters
				{
				DebugLocation(184, 19);
				PushFollow(Follow._formal_parameters_in_method1008);
				formal_parameters16=formal_parameters();
				PopFollow();

				stream_formal_parameters.Add(formal_parameters16.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(184, 39);
			RPAREN17=(IToken)Match(input,RPAREN,Follow._RPAREN_in_method1012);  
			stream_RPAREN.Add(RPAREN17);

			DebugLocation(184, 47);
			COLON18=(IToken)Match(input,COLON,Follow._COLON_in_method1015);  
			stream_COLON.Add(COLON18);

			DebugLocation(184, 54);
			TYPE_ID19=(IToken)Match(input,TYPE_ID,Follow._TYPE_ID_in_method1018);  
			stream_TYPE_ID.Add(TYPE_ID19);

			DebugLocation(184, 62);
			LKEY20=(IToken)Match(input,LKEY,Follow._LKEY_in_method1020);  
			stream_LKEY.Add(LKEY20);

			DebugLocation(184, 67);
			PushFollow(Follow._expression_in_method1022);
			expression21=expression();
			PopFollow();

			stream_expression.Add(expression21.Tree);
			DebugLocation(184, 78);
			RKEY22=(IToken)Match(input,RKEY,Follow._RKEY_in_method1024);  
			stream_RKEY.Add(RKEY22);



			{
			// AST REWRITE
			// elements: expression, formal_parameters, TYPE_ID, OBJ_ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 185:4: -> ^( FuncDef OBJ_ID TYPE_ID ( formal_parameters )? expression )
			{
				DebugLocation(185, 7);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:7: ^( FuncDef OBJ_ID TYPE_ID ( formal_parameters )? expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(185, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FuncDef, "FuncDef"), root_1);

				DebugLocation(185, 17);
				adaptor.AddChild(root_1, stream_OBJ_ID.NextNode());
				DebugLocation(185, 24);
				adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());
				DebugLocation(185, 32);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:32: ( formal_parameters )?
				if (stream_formal_parameters.HasNext)
				{
					DebugLocation(185, 32);
					adaptor.AddChild(root_1, stream_formal_parameters.NextTree());

				}
				stream_formal_parameters.Reset();
				DebugLocation(185, 51);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("method", 5);
			LeaveRule("method", 5);
			LeaveRule_method();
		}
		DebugLocation(186, 2);
		} finally { DebugExitRule(GrammarFileName, "method"); }
		return retval;

	}
	// $ANTLR end "method"

	partial void EnterRule_formal_parameters();
	partial void LeaveRule_formal_parameters();

	// $ANTLR start "formal_parameters"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:188:1: formal_parameters : formal ( COMMA formal )* -> ^( FunctionArgsList ( formal )+ ) ;
	[GrammarRule("formal_parameters")]
	private AstParserRuleReturnScope<object, IToken> formal_parameters()
	{
		EnterRule_formal_parameters();
		EnterRule("formal_parameters", 6);
		TraceIn("formal_parameters", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA24 = default(IToken);
		AstParserRuleReturnScope<object, IToken> formal23 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> formal25 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA24_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_formal=new RewriteRuleSubtreeStream(adaptor,"rule formal");
		try { DebugEnterRule(GrammarFileName, "formal_parameters");
		DebugLocation(188, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:188:20: ( formal ( COMMA formal )* -> ^( FunctionArgsList ( formal )+ ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:189:3: formal ( COMMA formal )*
			{
			DebugLocation(189, 3);
			PushFollow(Follow._formal_in_formal_parameters1058);
			formal23=formal();
			PopFollow();

			stream_formal.Add(formal23.Tree);
			DebugLocation(189, 11);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:189:11: ( COMMA formal )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==COMMA))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:189:13: COMMA formal
					{
					DebugLocation(189, 13);
					COMMA24=(IToken)Match(input,COMMA,Follow._COMMA_in_formal_parameters1063);  
					stream_COMMA.Add(COMMA24);

					DebugLocation(189, 19);
					PushFollow(Follow._formal_in_formal_parameters1065);
					formal25=formal();
					PopFollow();

					stream_formal.Add(formal25.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: formal
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 190:3: -> ^( FunctionArgsList ( formal )+ )
			{
				DebugLocation(190, 5);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:190:5: ^( FunctionArgsList ( formal )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(190, 7);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FunctionArgsList, "FunctionArgsList"), root_1);

				DebugLocation(190, 24);
				if (!(stream_formal.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_formal.HasNext )
				{
					DebugLocation(190, 24);
					adaptor.AddChild(root_1, stream_formal.NextTree());

				}
				stream_formal.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formal_parameters", 6);
			LeaveRule("formal_parameters", 6);
			LeaveRule_formal_parameters();
		}
		DebugLocation(191, 2);
		} finally { DebugExitRule(GrammarFileName, "formal_parameters"); }
		return retval;

	}
	// $ANTLR end "formal_parameters"

	partial void EnterRule_formal();
	partial void LeaveRule_formal();

	// $ANTLR start "formal"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:193:1: formal : OBJ_ID COLON TYPE_ID -> ^( COLON OBJ_ID TYPE_ID ) ;
	[GrammarRule("formal")]
	private AstParserRuleReturnScope<object, IToken> formal()
	{
		EnterRule_formal();
		EnterRule("formal", 7);
		TraceIn("formal", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OBJ_ID26 = default(IToken);
		IToken COLON27 = default(IToken);
		IToken TYPE_ID28 = default(IToken);

		object OBJ_ID26_tree = default(object);
		object COLON27_tree = default(object);
		object TYPE_ID28_tree = default(object);
		RewriteRuleITokenStream stream_TYPE_ID=new RewriteRuleITokenStream(adaptor,"token TYPE_ID");
		RewriteRuleITokenStream stream_OBJ_ID=new RewriteRuleITokenStream(adaptor,"token OBJ_ID");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		try { DebugEnterRule(GrammarFileName, "formal");
		DebugLocation(193, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:193:9: ( OBJ_ID COLON TYPE_ID -> ^( COLON OBJ_ID TYPE_ID ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:194:3: OBJ_ID COLON TYPE_ID
			{
			DebugLocation(194, 3);
			OBJ_ID26=(IToken)Match(input,OBJ_ID,Follow._OBJ_ID_in_formal1095);  
			stream_OBJ_ID.Add(OBJ_ID26);

			DebugLocation(194, 11);
			COLON27=(IToken)Match(input,COLON,Follow._COLON_in_formal1098);  
			stream_COLON.Add(COLON27);

			DebugLocation(194, 18);
			TYPE_ID28=(IToken)Match(input,TYPE_ID,Follow._TYPE_ID_in_formal1101);  
			stream_TYPE_ID.Add(TYPE_ID28);



			{
			// AST REWRITE
			// elements: TYPE_ID, OBJ_ID, COLON
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 195:3: -> ^( COLON OBJ_ID TYPE_ID )
			{
				DebugLocation(195, 5);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:195:5: ^( COLON OBJ_ID TYPE_ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(195, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_COLON.NextNode(), root_1);

				DebugLocation(195, 14);
				adaptor.AddChild(root_1, stream_OBJ_ID.NextNode());
				DebugLocation(195, 21);
				adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formal", 7);
			LeaveRule("formal", 7);
			LeaveRule_formal();
		}
		DebugLocation(196, 2);
		} finally { DebugExitRule(GrammarFileName, "formal"); }
		return retval;

	}
	// $ANTLR end "formal"

	partial void EnterRule_localOrFieldInit();
	partial void LeaveRule_localOrFieldInit();

	// $ANTLR start "localOrFieldInit"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:198:1: localOrFieldInit : OBJ_ID COLON TYPE_ID ( ASSIGN expression )? -> ^( LocalOrFieldInit OBJ_ID TYPE_ID ( expression )? ) ;
	[GrammarRule("localOrFieldInit")]
	private AstParserRuleReturnScope<object, IToken> localOrFieldInit()
	{
		EnterRule_localOrFieldInit();
		EnterRule("localOrFieldInit", 8);
		TraceIn("localOrFieldInit", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OBJ_ID29 = default(IToken);
		IToken COLON30 = default(IToken);
		IToken TYPE_ID31 = default(IToken);
		IToken ASSIGN32 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression33 = default(AstParserRuleReturnScope<object, IToken>);

		object OBJ_ID29_tree = default(object);
		object COLON30_tree = default(object);
		object TYPE_ID31_tree = default(object);
		object ASSIGN32_tree = default(object);
		RewriteRuleITokenStream stream_TYPE_ID=new RewriteRuleITokenStream(adaptor,"token TYPE_ID");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleITokenStream stream_OBJ_ID=new RewriteRuleITokenStream(adaptor,"token OBJ_ID");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "localOrFieldInit");
		DebugLocation(198, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:198:18: ( OBJ_ID COLON TYPE_ID ( ASSIGN expression )? -> ^( LocalOrFieldInit OBJ_ID TYPE_ID ( expression )? ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:199:3: OBJ_ID COLON TYPE_ID ( ASSIGN expression )?
			{
			DebugLocation(199, 3);
			OBJ_ID29=(IToken)Match(input,OBJ_ID,Follow._OBJ_ID_in_localOrFieldInit1128);  
			stream_OBJ_ID.Add(OBJ_ID29);

			DebugLocation(199, 11);
			COLON30=(IToken)Match(input,COLON,Follow._COLON_in_localOrFieldInit1131);  
			stream_COLON.Add(COLON30);

			DebugLocation(199, 18);
			TYPE_ID31=(IToken)Match(input,TYPE_ID,Follow._TYPE_ID_in_localOrFieldInit1134);  
			stream_TYPE_ID.Add(TYPE_ID31);

			DebugLocation(199, 26);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:199:26: ( ASSIGN expression )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==ASSIGN))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:199:27: ASSIGN expression
				{
				DebugLocation(199, 27);
				ASSIGN32=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_localOrFieldInit1137);  
				stream_ASSIGN.Add(ASSIGN32);

				DebugLocation(199, 35);
				PushFollow(Follow._expression_in_localOrFieldInit1140);
				expression33=expression();
				PopFollow();

				stream_expression.Add(expression33.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }



			{
			// AST REWRITE
			// elements: TYPE_ID, OBJ_ID, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 200:4: -> ^( LocalOrFieldInit OBJ_ID TYPE_ID ( expression )? )
			{
				DebugLocation(200, 7);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:200:7: ^( LocalOrFieldInit OBJ_ID TYPE_ID ( expression )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(200, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LocalOrFieldInit, "LocalOrFieldInit"), root_1);

				DebugLocation(200, 26);
				adaptor.AddChild(root_1, stream_OBJ_ID.NextNode());
				DebugLocation(200, 34);
				adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());
				DebugLocation(200, 42);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:200:42: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(200, 42);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("localOrFieldInit", 8);
			LeaveRule("localOrFieldInit", 8);
			LeaveRule_localOrFieldInit();
		}
		DebugLocation(201, 2);
		} finally { DebugExitRule(GrammarFileName, "localOrFieldInit"); }
		return retval;

	}
	// $ANTLR end "localOrFieldInit"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:203:1: expression : ( let -> let | assig_expr -> assig_expr );
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<object, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 9);
		TraceIn("expression", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> let34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assig_expr35 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_assig_expr=new RewriteRuleSubtreeStream(adaptor,"rule assig_expr");
		RewriteRuleSubtreeStream stream_let=new RewriteRuleSubtreeStream(adaptor,"rule let");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(203, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:203:13: ( let -> let | assig_expr -> assig_expr )
			int alt8=2;
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==LET))
			{
				alt8 = 1;
			}
			else if ((LA8_0==CASE||LA8_0==DO||LA8_0==FALSE||LA8_0==IF||(LA8_0>=INTEGER && LA8_0<=ISVOID)||LA8_0==LKEY||LA8_0==LPAREN||(LA8_0>=NEG && LA8_0<=OBJ_ID)||LA8_0==SELF||LA8_0==STRING||LA8_0==TRUE||LA8_0==WHILE))
			{
				alt8 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:203:17: let
				{
				DebugLocation(203, 17);
				PushFollow(Follow._let_in_expression1179);
				let34=let();
				PopFollow();

				stream_let.Add(let34.Tree);


				{
				// AST REWRITE
				// elements: let
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 203:21: -> let
				{
					DebugLocation(203, 23);
					adaptor.AddChild(root_0, stream_let.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:204:6: assig_expr
				{
				DebugLocation(204, 6);
				PushFollow(Follow._assig_expr_in_expression1189);
				assig_expr35=assig_expr();
				PopFollow();

				stream_assig_expr.Add(assig_expr35.Tree);


				{
				// AST REWRITE
				// elements: assig_expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 204:17: -> assig_expr
				{
					DebugLocation(204, 20);
					adaptor.AddChild(root_0, stream_assig_expr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 9);
			LeaveRule("expression", 9);
			LeaveRule_expression();
		}
		DebugLocation(205, 2);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_assig_expr();
	partial void LeaveRule_assig_expr();

	// $ANTLR start "assig_expr"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:206:1: assig_expr : ( OBJ_ID ASSIGN ^)* not_expr ;
	[GrammarRule("assig_expr")]
	private AstParserRuleReturnScope<object, IToken> assig_expr()
	{
		EnterRule_assig_expr();
		EnterRule("assig_expr", 10);
		TraceIn("assig_expr", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OBJ_ID36 = default(IToken);
		IToken ASSIGN37 = default(IToken);
		AstParserRuleReturnScope<object, IToken> not_expr38 = default(AstParserRuleReturnScope<object, IToken>);

		object OBJ_ID36_tree = default(object);
		object ASSIGN37_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assig_expr");
		DebugLocation(206, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:206:13: ( ( OBJ_ID ASSIGN ^)* not_expr )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:206:16: ( OBJ_ID ASSIGN ^)* not_expr
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(206, 16);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:206:16: ( OBJ_ID ASSIGN ^)*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==OBJ_ID))
				{
					int LA9_2 = input.LA(2);

					if ((LA9_2==ASSIGN))
					{
						alt9 = 1;
					}


				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:206:17: OBJ_ID ASSIGN ^
					{
					DebugLocation(206, 17);
					OBJ_ID36=(IToken)Match(input,OBJ_ID,Follow._OBJ_ID_in_assig_expr1210); 
					OBJ_ID36_tree = (object)adaptor.Create(OBJ_ID36);
					adaptor.AddChild(root_0, OBJ_ID36_tree);
					DebugLocation(206, 30);
					ASSIGN37=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_assig_expr1212); 
					ASSIGN37_tree = (object)adaptor.Create(ASSIGN37);
					root_0 = (object)adaptor.BecomeRoot(ASSIGN37_tree, root_0);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(206, 36);
			PushFollow(Follow._not_expr_in_assig_expr1219);
			not_expr38=not_expr();
			PopFollow();

			adaptor.AddChild(root_0, not_expr38.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assig_expr", 10);
			LeaveRule("assig_expr", 10);
			LeaveRule_assig_expr();
		}
		DebugLocation(207, 2);
		} finally { DebugExitRule(GrammarFileName, "assig_expr"); }
		return retval;

	}
	// $ANTLR end "assig_expr"

	partial void EnterRule_not_expr();
	partial void LeaveRule_not_expr();

	// $ANTLR start "not_expr"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:208:1: not_expr : ( NOT ^)* relation ;
	[GrammarRule("not_expr")]
	private AstParserRuleReturnScope<object, IToken> not_expr()
	{
		EnterRule_not_expr();
		EnterRule("not_expr", 11);
		TraceIn("not_expr", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NOT39 = default(IToken);
		AstParserRuleReturnScope<object, IToken> relation40 = default(AstParserRuleReturnScope<object, IToken>);

		object NOT39_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "not_expr");
		DebugLocation(208, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:208:11: ( ( NOT ^)* relation )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:208:13: ( NOT ^)* relation
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(208, 13);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:208:13: ( NOT ^)*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==NOT))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:208:14: NOT ^
					{
					DebugLocation(208, 17);
					NOT39=(IToken)Match(input,NOT,Follow._NOT_in_not_expr1234); 
					NOT39_tree = (object)adaptor.Create(NOT39);
					root_0 = (object)adaptor.BecomeRoot(NOT39_tree, root_0);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(208, 23);
			PushFollow(Follow._relation_in_not_expr1241);
			relation40=relation();
			PopFollow();

			adaptor.AddChild(root_0, relation40.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("not_expr", 11);
			LeaveRule("not_expr", 11);
			LeaveRule_not_expr();
		}
		DebugLocation(209, 2);
		} finally { DebugExitRule(GrammarFileName, "not_expr"); }
		return retval;

	}
	// $ANTLR end "not_expr"

	partial void EnterRule_relation();
	partial void LeaveRule_relation();

	// $ANTLR start "relation"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:1: relation : ( compare_expr ) ( ( OR ^| AND ^) compare_expr )* ;
	[GrammarRule("relation")]
	private AstParserRuleReturnScope<object, IToken> relation()
	{
		EnterRule_relation();
		EnterRule("relation", 12);
		TraceIn("relation", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR42 = default(IToken);
		IToken AND43 = default(IToken);
		AstParserRuleReturnScope<object, IToken> compare_expr41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> compare_expr44 = default(AstParserRuleReturnScope<object, IToken>);

		object OR42_tree = default(object);
		object AND43_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "relation");
		DebugLocation(210, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:11: ( ( compare_expr ) ( ( OR ^| AND ^) compare_expr )* )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:13: ( compare_expr ) ( ( OR ^| AND ^) compare_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(210, 13);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:13: ( compare_expr )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:14: compare_expr
			{
			DebugLocation(210, 14);
			PushFollow(Follow._compare_expr_in_relation1255);
			compare_expr41=compare_expr();
			PopFollow();

			adaptor.AddChild(root_0, compare_expr41.Tree);

			}

			DebugLocation(210, 29);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:29: ( ( OR ^| AND ^) compare_expr )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==AND||LA12_0==OR))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:30: ( OR ^| AND ^) compare_expr
					{
					DebugLocation(210, 30);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:30: ( OR ^| AND ^)
					int alt11=2;
					try { DebugEnterSubRule(11);
					try { DebugEnterDecision(11, false);
					int LA11_0 = input.LA(1);

					if ((LA11_0==OR))
					{
						alt11 = 1;
					}
					else if ((LA11_0==AND))
					{
						alt11 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:31: OR ^
						{
						DebugLocation(210, 33);
						OR42=(IToken)Match(input,OR,Follow._OR_in_relation1261); 
						OR42_tree = (object)adaptor.Create(OR42);
						root_0 = (object)adaptor.BecomeRoot(OR42_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:35: AND ^
						{
						DebugLocation(210, 38);
						AND43=(IToken)Match(input,AND,Follow._AND_in_relation1264); 
						AND43_tree = (object)adaptor.Create(AND43);
						root_0 = (object)adaptor.BecomeRoot(AND43_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(11); }

					DebugLocation(210, 42);
					PushFollow(Follow._compare_expr_in_relation1269);
					compare_expr44=compare_expr();
					PopFollow();

					adaptor.AddChild(root_0, compare_expr44.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relation", 12);
			LeaveRule("relation", 12);
			LeaveRule_relation();
		}
		DebugLocation(211, 2);
		} finally { DebugExitRule(GrammarFileName, "relation"); }
		return retval;

	}
	// $ANTLR end "relation"

	partial void EnterRule_compare_expr();
	partial void LeaveRule_compare_expr();

	// $ANTLR start "compare_expr"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:1: compare_expr : ( arith_expr ) ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) arith_expr )* ;
	[GrammarRule("compare_expr")]
	private AstParserRuleReturnScope<object, IToken> compare_expr()
	{
		EnterRule_compare_expr();
		EnterRule("compare_expr", 13);
		TraceIn("compare_expr", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LE46 = default(IToken);
		IToken LT47 = default(IToken);
		IToken GE48 = default(IToken);
		IToken GT49 = default(IToken);
		IToken EQUAL50 = default(IToken);
		AstParserRuleReturnScope<object, IToken> arith_expr45 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arith_expr51 = default(AstParserRuleReturnScope<object, IToken>);

		object LE46_tree = default(object);
		object LT47_tree = default(object);
		object GE48_tree = default(object);
		object GT49_tree = default(object);
		object EQUAL50_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "compare_expr");
		DebugLocation(212, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:14: ( ( arith_expr ) ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) arith_expr )* )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:16: ( arith_expr ) ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) arith_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(212, 16);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:16: ( arith_expr )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:17: arith_expr
			{
			DebugLocation(212, 17);
			PushFollow(Follow._arith_expr_in_compare_expr1284);
			arith_expr45=arith_expr();
			PopFollow();

			adaptor.AddChild(root_0, arith_expr45.Tree);

			}

			DebugLocation(212, 29);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:29: ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) arith_expr )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==EQUAL||(LA14_0>=GE && LA14_0<=GT)||LA14_0==LE||LA14_0==LT))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:31: ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) arith_expr
					{
					DebugLocation(212, 31);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:31: ( LE ^| LT ^| GE ^| GT ^| EQUAL ^)
					int alt13=5;
					try { DebugEnterSubRule(13);
					try { DebugEnterDecision(13, false);
					switch (input.LA(1))
					{
					case LE:
						{
						alt13 = 1;
						}
						break;
					case LT:
						{
						alt13 = 2;
						}
						break;
					case GE:
						{
						alt13 = 3;
						}
						break;
					case GT:
						{
						alt13 = 4;
						}
						break;
					case EQUAL:
						{
						alt13 = 5;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(13); }
					switch (alt13)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:33: LE ^
						{
						DebugLocation(212, 35);
						LE46=(IToken)Match(input,LE,Follow._LE_in_compare_expr1291); 
						LE46_tree = (object)adaptor.Create(LE46);
						root_0 = (object)adaptor.BecomeRoot(LE46_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:38: LT ^
						{
						DebugLocation(212, 40);
						LT47=(IToken)Match(input,LT,Follow._LT_in_compare_expr1295); 
						LT47_tree = (object)adaptor.Create(LT47);
						root_0 = (object)adaptor.BecomeRoot(LT47_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:43: GE ^
						{
						DebugLocation(212, 45);
						GE48=(IToken)Match(input,GE,Follow._GE_in_compare_expr1299); 
						GE48_tree = (object)adaptor.Create(GE48);
						root_0 = (object)adaptor.BecomeRoot(GE48_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:48: GT ^
						{
						DebugLocation(212, 50);
						GT49=(IToken)Match(input,GT,Follow._GT_in_compare_expr1303); 
						GT49_tree = (object)adaptor.Create(GT49);
						root_0 = (object)adaptor.BecomeRoot(GT49_tree, root_0);

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:54: EQUAL ^
						{
						DebugLocation(212, 59);
						EQUAL50=(IToken)Match(input,EQUAL,Follow._EQUAL_in_compare_expr1308); 
						EQUAL50_tree = (object)adaptor.Create(EQUAL50);
						root_0 = (object)adaptor.BecomeRoot(EQUAL50_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(13); }

					DebugLocation(212, 63);
					PushFollow(Follow._arith_expr_in_compare_expr1313);
					arith_expr51=arith_expr();
					PopFollow();

					adaptor.AddChild(root_0, arith_expr51.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compare_expr", 13);
			LeaveRule("compare_expr", 13);
			LeaveRule_compare_expr();
		}
		DebugLocation(213, 2);
		} finally { DebugExitRule(GrammarFileName, "compare_expr"); }
		return retval;

	}
	// $ANTLR end "compare_expr"

	partial void EnterRule_arith_expr();
	partial void LeaveRule_arith_expr();

	// $ANTLR start "arith_expr"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:1: arith_expr : ( mult_expr ) ( ( PLUS ^| MINUS ^) mult_expr )* ;
	[GrammarRule("arith_expr")]
	private AstParserRuleReturnScope<object, IToken> arith_expr()
	{
		EnterRule_arith_expr();
		EnterRule("arith_expr", 14);
		TraceIn("arith_expr", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PLUS53 = default(IToken);
		IToken MINUS54 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mult_expr52 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mult_expr55 = default(AstParserRuleReturnScope<object, IToken>);

		object PLUS53_tree = default(object);
		object MINUS54_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "arith_expr");
		DebugLocation(214, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:13: ( ( mult_expr ) ( ( PLUS ^| MINUS ^) mult_expr )* )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:16: ( mult_expr ) ( ( PLUS ^| MINUS ^) mult_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(214, 16);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:16: ( mult_expr )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:17: mult_expr
			{
			DebugLocation(214, 17);
			PushFollow(Follow._mult_expr_in_arith_expr1329);
			mult_expr52=mult_expr();
			PopFollow();

			adaptor.AddChild(root_0, mult_expr52.Tree);

			}

			DebugLocation(214, 28);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:28: ( ( PLUS ^| MINUS ^) mult_expr )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==MINUS||LA16_0==PLUS))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:29: ( PLUS ^| MINUS ^) mult_expr
					{
					DebugLocation(214, 29);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:29: ( PLUS ^| MINUS ^)
					int alt15=2;
					try { DebugEnterSubRule(15);
					try { DebugEnterDecision(15, false);
					int LA15_0 = input.LA(1);

					if ((LA15_0==PLUS))
					{
						alt15 = 1;
					}
					else if ((LA15_0==MINUS))
					{
						alt15 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(15); }
					switch (alt15)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:31: PLUS ^
						{
						DebugLocation(214, 35);
						PLUS53=(IToken)Match(input,PLUS,Follow._PLUS_in_arith_expr1335); 
						PLUS53_tree = (object)adaptor.Create(PLUS53);
						root_0 = (object)adaptor.BecomeRoot(PLUS53_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:38: MINUS ^
						{
						DebugLocation(214, 43);
						MINUS54=(IToken)Match(input,MINUS,Follow._MINUS_in_arith_expr1339); 
						MINUS54_tree = (object)adaptor.Create(MINUS54);
						root_0 = (object)adaptor.BecomeRoot(MINUS54_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(15); }

					DebugLocation(214, 46);
					PushFollow(Follow._mult_expr_in_arith_expr1343);
					mult_expr55=mult_expr();
					PopFollow();

					adaptor.AddChild(root_0, mult_expr55.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arith_expr", 14);
			LeaveRule("arith_expr", 14);
			LeaveRule_arith_expr();
		}
		DebugLocation(215, 2);
		} finally { DebugExitRule(GrammarFileName, "arith_expr"); }
		return retval;

	}
	// $ANTLR end "arith_expr"

	partial void EnterRule_mult_expr();
	partial void LeaveRule_mult_expr();

	// $ANTLR start "mult_expr"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:1: mult_expr : ( isVoid_expr ) ( ( MULT ^| DIV ^) isVoid_expr )* ;
	[GrammarRule("mult_expr")]
	private AstParserRuleReturnScope<object, IToken> mult_expr()
	{
		EnterRule_mult_expr();
		EnterRule("mult_expr", 15);
		TraceIn("mult_expr", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MULT57 = default(IToken);
		IToken DIV58 = default(IToken);
		AstParserRuleReturnScope<object, IToken> isVoid_expr56 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> isVoid_expr59 = default(AstParserRuleReturnScope<object, IToken>);

		object MULT57_tree = default(object);
		object DIV58_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mult_expr");
		DebugLocation(216, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:12: ( ( isVoid_expr ) ( ( MULT ^| DIV ^) isVoid_expr )* )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:15: ( isVoid_expr ) ( ( MULT ^| DIV ^) isVoid_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(216, 15);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:15: ( isVoid_expr )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:16: isVoid_expr
			{
			DebugLocation(216, 16);
			PushFollow(Follow._isVoid_expr_in_mult_expr1358);
			isVoid_expr56=isVoid_expr();
			PopFollow();

			adaptor.AddChild(root_0, isVoid_expr56.Tree);

			}

			DebugLocation(216, 29);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:29: ( ( MULT ^| DIV ^) isVoid_expr )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==DIV||LA18_0==MULT))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:31: ( MULT ^| DIV ^) isVoid_expr
					{
					DebugLocation(216, 31);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:31: ( MULT ^| DIV ^)
					int alt17=2;
					try { DebugEnterSubRule(17);
					try { DebugEnterDecision(17, false);
					int LA17_0 = input.LA(1);

					if ((LA17_0==MULT))
					{
						alt17 = 1;
					}
					else if ((LA17_0==DIV))
					{
						alt17 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(17); }
					switch (alt17)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:32: MULT ^
						{
						DebugLocation(216, 36);
						MULT57=(IToken)Match(input,MULT,Follow._MULT_in_mult_expr1364); 
						MULT57_tree = (object)adaptor.Create(MULT57);
						root_0 = (object)adaptor.BecomeRoot(MULT57_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:40: DIV ^
						{
						DebugLocation(216, 44);
						DIV58=(IToken)Match(input,DIV,Follow._DIV_in_mult_expr1369); 
						DIV58_tree = (object)adaptor.Create(DIV58);
						root_0 = (object)adaptor.BecomeRoot(DIV58_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(17); }

					DebugLocation(216, 47);
					PushFollow(Follow._isVoid_expr_in_mult_expr1374);
					isVoid_expr59=isVoid_expr();
					PopFollow();

					adaptor.AddChild(root_0, isVoid_expr59.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mult_expr", 15);
			LeaveRule("mult_expr", 15);
			LeaveRule_mult_expr();
		}
		DebugLocation(217, 2);
		} finally { DebugExitRule(GrammarFileName, "mult_expr"); }
		return retval;

	}
	// $ANTLR end "mult_expr"

	partial void EnterRule_isVoid_expr();
	partial void LeaveRule_isVoid_expr();

	// $ANTLR start "isVoid_expr"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:218:1: isVoid_expr : ( ISVOID ^)* neg_expr ;
	[GrammarRule("isVoid_expr")]
	private AstParserRuleReturnScope<object, IToken> isVoid_expr()
	{
		EnterRule_isVoid_expr();
		EnterRule("isVoid_expr", 16);
		TraceIn("isVoid_expr", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ISVOID60 = default(IToken);
		AstParserRuleReturnScope<object, IToken> neg_expr61 = default(AstParserRuleReturnScope<object, IToken>);

		object ISVOID60_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "isVoid_expr");
		DebugLocation(218, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:218:14: ( ( ISVOID ^)* neg_expr )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:218:17: ( ISVOID ^)* neg_expr
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(218, 17);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:218:17: ( ISVOID ^)*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==ISVOID))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:218:18: ISVOID ^
					{
					DebugLocation(218, 24);
					ISVOID60=(IToken)Match(input,ISVOID,Follow._ISVOID_in_isVoid_expr1390); 
					ISVOID60_tree = (object)adaptor.Create(ISVOID60);
					root_0 = (object)adaptor.BecomeRoot(ISVOID60_tree, root_0);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(218, 29);
			PushFollow(Follow._neg_expr_in_isVoid_expr1396);
			neg_expr61=neg_expr();
			PopFollow();

			adaptor.AddChild(root_0, neg_expr61.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("isVoid_expr", 16);
			LeaveRule("isVoid_expr", 16);
			LeaveRule_isVoid_expr();
		}
		DebugLocation(219, 2);
		} finally { DebugExitRule(GrammarFileName, "isVoid_expr"); }
		return retval;

	}
	// $ANTLR end "isVoid_expr"

	partial void EnterRule_neg_expr();
	partial void LeaveRule_neg_expr();

	// $ANTLR start "neg_expr"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:220:1: neg_expr : ( NEG ^)* dot_expr ;
	[GrammarRule("neg_expr")]
	private AstParserRuleReturnScope<object, IToken> neg_expr()
	{
		EnterRule_neg_expr();
		EnterRule("neg_expr", 17);
		TraceIn("neg_expr", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NEG62 = default(IToken);
		AstParserRuleReturnScope<object, IToken> dot_expr63 = default(AstParserRuleReturnScope<object, IToken>);

		object NEG62_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "neg_expr");
		DebugLocation(220, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:220:11: ( ( NEG ^)* dot_expr )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:220:14: ( NEG ^)* dot_expr
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(220, 14);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:220:14: ( NEG ^)*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==NEG))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:220:15: NEG ^
					{
					DebugLocation(220, 18);
					NEG62=(IToken)Match(input,NEG,Follow._NEG_in_neg_expr1409); 
					NEG62_tree = (object)adaptor.Create(NEG62);
					root_0 = (object)adaptor.BecomeRoot(NEG62_tree, root_0);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(220, 24);
			PushFollow(Follow._dot_expr_in_neg_expr1416);
			dot_expr63=dot_expr();
			PopFollow();

			adaptor.AddChild(root_0, dot_expr63.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("neg_expr", 17);
			LeaveRule("neg_expr", 17);
			LeaveRule_neg_expr();
		}
		DebugLocation(221, 2);
		} finally { DebugExitRule(GrammarFileName, "neg_expr"); }
		return retval;

	}
	// $ANTLR end "neg_expr"

	partial void EnterRule_dot_expr();
	partial void LeaveRule_dot_expr();

	// $ANTLR start "dot_expr"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:222:1: dot_expr : ( term -> term ) ( ATSIGN TYPE_ID DOT call_expr -> ^( DotTypeInvoke $dot_expr TYPE_ID call_expr ) | DOT call_expr -> ^( DotObjectInvoke $dot_expr call_expr ) )* ;
	[GrammarRule("dot_expr")]
	private AstParserRuleReturnScope<object, IToken> dot_expr()
	{
		EnterRule_dot_expr();
		EnterRule("dot_expr", 18);
		TraceIn("dot_expr", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ATSIGN65 = default(IToken);
		IToken TYPE_ID66 = default(IToken);
		IToken DOT67 = default(IToken);
		IToken DOT69 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term64 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> call_expr68 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> call_expr70 = default(AstParserRuleReturnScope<object, IToken>);

		object ATSIGN65_tree = default(object);
		object TYPE_ID66_tree = default(object);
		object DOT67_tree = default(object);
		object DOT69_tree = default(object);
		RewriteRuleITokenStream stream_TYPE_ID=new RewriteRuleITokenStream(adaptor,"token TYPE_ID");
		RewriteRuleITokenStream stream_ATSIGN=new RewriteRuleITokenStream(adaptor,"token ATSIGN");
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_call_expr=new RewriteRuleSubtreeStream(adaptor,"rule call_expr");
		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term");
		try { DebugEnterRule(GrammarFileName, "dot_expr");
		DebugLocation(222, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:222:11: ( ( term -> term ) ( ATSIGN TYPE_ID DOT call_expr -> ^( DotTypeInvoke $dot_expr TYPE_ID call_expr ) | DOT call_expr -> ^( DotObjectInvoke $dot_expr call_expr ) )* )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:222:14: ( term -> term ) ( ATSIGN TYPE_ID DOT call_expr -> ^( DotTypeInvoke $dot_expr TYPE_ID call_expr ) | DOT call_expr -> ^( DotObjectInvoke $dot_expr call_expr ) )*
			{
			DebugLocation(222, 14);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:222:14: ( term -> term )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:222:16: term
			{
			DebugLocation(222, 16);
			PushFollow(Follow._term_in_dot_expr1430);
			term64=term();
			PopFollow();

			stream_term.Add(term64.Tree);


			{
			// AST REWRITE
			// elements: term
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 222:21: -> term
			{
				DebugLocation(222, 24);
				adaptor.AddChild(root_0, stream_term.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(223, 26);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:223:26: ( ATSIGN TYPE_ID DOT call_expr -> ^( DotTypeInvoke $dot_expr TYPE_ID call_expr ) | DOT call_expr -> ^( DotObjectInvoke $dot_expr call_expr ) )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=3;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==ATSIGN))
				{
					alt21 = 1;
				}
				else if ((LA21_0==DOT))
				{
					alt21 = 2;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:223:27: ATSIGN TYPE_ID DOT call_expr
					{
					DebugLocation(223, 27);
					ATSIGN65=(IToken)Match(input,ATSIGN,Follow._ATSIGN_in_dot_expr1465);  
					stream_ATSIGN.Add(ATSIGN65);

					DebugLocation(223, 35);
					TYPE_ID66=(IToken)Match(input,TYPE_ID,Follow._TYPE_ID_in_dot_expr1468);  
					stream_TYPE_ID.Add(TYPE_ID66);

					DebugLocation(223, 43);
					DOT67=(IToken)Match(input,DOT,Follow._DOT_in_dot_expr1470);  
					stream_DOT.Add(DOT67);

					DebugLocation(223, 48);
					PushFollow(Follow._call_expr_in_dot_expr1473);
					call_expr68=call_expr();
					PopFollow();

					stream_call_expr.Add(call_expr68.Tree);


					{
					// AST REWRITE
					// elements: call_expr, dot_expr, TYPE_ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 223:59: -> ^( DotTypeInvoke $dot_expr TYPE_ID call_expr )
					{
						DebugLocation(223, 62);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:223:62: ^( DotTypeInvoke $dot_expr TYPE_ID call_expr )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(223, 64);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DotTypeInvoke, "DotTypeInvoke"), root_1);

						DebugLocation(223, 80);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(223, 90);
						adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());
						DebugLocation(223, 98);
						adaptor.AddChild(root_1, stream_call_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:225:6: DOT call_expr
					{
					DebugLocation(225, 6);
					DOT69=(IToken)Match(input,DOT,Follow._DOT_in_dot_expr1500);  
					stream_DOT.Add(DOT69);

					DebugLocation(225, 11);
					PushFollow(Follow._call_expr_in_dot_expr1503);
					call_expr70=call_expr();
					PopFollow();

					stream_call_expr.Add(call_expr70.Tree);


					{
					// AST REWRITE
					// elements: call_expr, dot_expr
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 226:4: -> ^( DotObjectInvoke $dot_expr call_expr )
					{
						DebugLocation(226, 7);
						// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:226:7: ^( DotObjectInvoke $dot_expr call_expr )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(226, 9);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DotObjectInvoke, "DotObjectInvoke"), root_1);

						DebugLocation(226, 27);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(226, 37);
						adaptor.AddChild(root_1, stream_call_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dot_expr", 18);
			LeaveRule("dot_expr", 18);
			LeaveRule_dot_expr();
		}
		DebugLocation(227, 2);
		} finally { DebugExitRule(GrammarFileName, "dot_expr"); }
		return retval;

	}
	// $ANTLR end "dot_expr"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:231:1: term : ( call_expr -> call_expr | conditionals_expr -> conditionals_expr | loops -> loops | blocks -> blocks | case -> case | new -> new | LPAREN expression RPAREN -> expression | constants -> constants | identifiers -> identifiers );
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 19);
		TraceIn("term", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN77 = default(IToken);
		IToken RPAREN79 = default(IToken);
		AstParserRuleReturnScope<object, IToken> call_expr71 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> conditionals_expr72 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> loops73 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> blocks74 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> case75 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> new76 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression78 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constants80 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifiers81 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN77_tree = default(object);
		object RPAREN79_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_case=new RewriteRuleSubtreeStream(adaptor,"rule case");
		RewriteRuleSubtreeStream stream_call_expr=new RewriteRuleSubtreeStream(adaptor,"rule call_expr");
		RewriteRuleSubtreeStream stream_identifiers=new RewriteRuleSubtreeStream(adaptor,"rule identifiers");
		RewriteRuleSubtreeStream stream_new=new RewriteRuleSubtreeStream(adaptor,"rule new");
		RewriteRuleSubtreeStream stream_blocks=new RewriteRuleSubtreeStream(adaptor,"rule blocks");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_loops=new RewriteRuleSubtreeStream(adaptor,"rule loops");
		RewriteRuleSubtreeStream stream_constants=new RewriteRuleSubtreeStream(adaptor,"rule constants");
		RewriteRuleSubtreeStream stream_conditionals_expr=new RewriteRuleSubtreeStream(adaptor,"rule conditionals_expr");
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(231, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:231:7: ( call_expr -> call_expr | conditionals_expr -> conditionals_expr | loops -> loops | blocks -> blocks | case -> case | new -> new | LPAREN expression RPAREN -> expression | constants -> constants | identifiers -> identifiers )
			int alt22=9;
			try { DebugEnterDecision(22, false);
			switch (input.LA(1))
			{
			case OBJ_ID:
				{
				int LA22_1 = input.LA(2);

				if ((LA22_1==LPAREN))
				{
					alt22 = 1;
				}
				else if ((LA22_1==AND||LA22_1==ATSIGN||LA22_1==COMMA||LA22_1==DIV||LA22_1==DOT||(LA22_1>=ELSE && LA22_1<=EQUAL)||LA22_1==FI||(LA22_1>=GE && LA22_1<=GT)||LA22_1==IN||LA22_1==LE||LA22_1==LOOP||LA22_1==LT||(LA22_1>=MINUS && LA22_1<=MULT)||(LA22_1>=OD && LA22_1<=POOL)||(LA22_1>=RKEY && LA22_1<=RPAREN)||LA22_1==SEMI||LA22_1==THEN||LA22_1==WHILE))
				{
					alt22 = 9;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 22, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IF:
				{
				alt22 = 2;
				}
				break;
			case DO:
			case WHILE:
				{
				alt22 = 3;
				}
				break;
			case LKEY:
				{
				alt22 = 4;
				}
				break;
			case CASE:
				{
				alt22 = 5;
				}
				break;
			case NEW:
				{
				alt22 = 6;
				}
				break;
			case LPAREN:
				{
				alt22 = 7;
				}
				break;
			case FALSE:
			case INTEGER:
			case STRING:
			case TRUE:
				{
				alt22 = 8;
				}
				break;
			case SELF:
				{
				alt22 = 9;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:231:13: call_expr
				{
				DebugLocation(231, 13);
				PushFollow(Follow._call_expr_in_term1548);
				call_expr71=call_expr();
				PopFollow();

				stream_call_expr.Add(call_expr71.Tree);


				{
				// AST REWRITE
				// elements: call_expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 231:23: -> call_expr
				{
					DebugLocation(231, 28);
					adaptor.AddChild(root_0, stream_call_expr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:232:6: conditionals_expr
				{
				DebugLocation(232, 6);
				PushFollow(Follow._conditionals_expr_in_term1562);
				conditionals_expr72=conditionals_expr();
				PopFollow();

				stream_conditionals_expr.Add(conditionals_expr72.Tree);


				{
				// AST REWRITE
				// elements: conditionals_expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 232:24: -> conditionals_expr
				{
					DebugLocation(232, 27);
					adaptor.AddChild(root_0, stream_conditionals_expr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:233:7: loops
				{
				DebugLocation(233, 7);
				PushFollow(Follow._loops_in_term1575);
				loops73=loops();
				PopFollow();

				stream_loops.Add(loops73.Tree);


				{
				// AST REWRITE
				// elements: loops
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 233:13: -> loops
				{
					DebugLocation(233, 16);
					adaptor.AddChild(root_0, stream_loops.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:234:9: blocks
				{
				DebugLocation(234, 9);
				PushFollow(Follow._blocks_in_term1589);
				blocks74=blocks();
				PopFollow();

				stream_blocks.Add(blocks74.Tree);


				{
				// AST REWRITE
				// elements: blocks
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 234:16: -> blocks
				{
					DebugLocation(234, 19);
					adaptor.AddChild(root_0, stream_blocks.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:235:6: case
				{
				DebugLocation(235, 6);
				PushFollow(Follow._case_in_term1601);
				case75=@case();
				PopFollow();

				stream_case.Add(case75.Tree);


				{
				// AST REWRITE
				// elements: case
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 235:11: -> case
				{
					DebugLocation(235, 14);
					adaptor.AddChild(root_0, stream_case.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:236:6: new
				{
				DebugLocation(236, 6);
				PushFollow(Follow._new_in_term1612);
				new76=@new();
				PopFollow();

				stream_new.Add(new76.Tree);


				{
				// AST REWRITE
				// elements: new
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 236:10: -> new
				{
					DebugLocation(236, 13);
					adaptor.AddChild(root_0, stream_new.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:237:6: LPAREN expression RPAREN
				{
				DebugLocation(237, 6);
				LPAREN77=(IToken)Match(input,LPAREN,Follow._LPAREN_in_term1623);  
				stream_LPAREN.Add(LPAREN77);

				DebugLocation(237, 13);
				PushFollow(Follow._expression_in_term1625);
				expression78=expression();
				PopFollow();

				stream_expression.Add(expression78.Tree);
				DebugLocation(237, 24);
				RPAREN79=(IToken)Match(input,RPAREN,Follow._RPAREN_in_term1627);  
				stream_RPAREN.Add(RPAREN79);



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 237:31: -> expression
				{
					DebugLocation(237, 34);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:238:6: constants
				{
				DebugLocation(238, 6);
				PushFollow(Follow._constants_in_term1638);
				constants80=constants();
				PopFollow();

				stream_constants.Add(constants80.Tree);


				{
				// AST REWRITE
				// elements: constants
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 238:20: -> constants
				{
					DebugLocation(238, 23);
					adaptor.AddChild(root_0, stream_constants.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:239:6: identifiers
				{
				DebugLocation(239, 6);
				PushFollow(Follow._identifiers_in_term1653);
				identifiers81=identifiers();
				PopFollow();

				stream_identifiers.Add(identifiers81.Tree);


				{
				// AST REWRITE
				// elements: identifiers
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 239:20: -> identifiers
				{
					DebugLocation(239, 23);
					adaptor.AddChild(root_0, stream_identifiers.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 19);
			LeaveRule("term", 19);
			LeaveRule_term();
		}
		DebugLocation(240, 2);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_identifiers();
	partial void LeaveRule_identifiers();

	// $ANTLR start "identifiers"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:242:1: identifiers : ( OBJ_ID ^| SELF ^);
	[GrammarRule("identifiers")]
	private AstParserRuleReturnScope<object, IToken> identifiers()
	{
		EnterRule_identifiers();
		EnterRule("identifiers", 20);
		TraceIn("identifiers", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OBJ_ID82 = default(IToken);
		IToken SELF83 = default(IToken);

		object OBJ_ID82_tree = default(object);
		object SELF83_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "identifiers");
		DebugLocation(242, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:242:14: ( OBJ_ID ^| SELF ^)
			int alt23=2;
			try { DebugEnterDecision(23, false);
			int LA23_0 = input.LA(1);

			if ((LA23_0==OBJ_ID))
			{
				alt23 = 1;
			}
			else if ((LA23_0==SELF))
			{
				alt23 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:242:17: OBJ_ID ^
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(242, 23);
				OBJ_ID82=(IToken)Match(input,OBJ_ID,Follow._OBJ_ID_in_identifiers1672); 
				OBJ_ID82_tree = (object)adaptor.Create(OBJ_ID82);
				root_0 = (object)adaptor.BecomeRoot(OBJ_ID82_tree, root_0);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:243:6: SELF ^
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(243, 10);
				SELF83=(IToken)Match(input,SELF,Follow._SELF_in_identifiers1681); 
				SELF83_tree = (object)adaptor.Create(SELF83);
				root_0 = (object)adaptor.BecomeRoot(SELF83_tree, root_0);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifiers", 20);
			LeaveRule("identifiers", 20);
			LeaveRule_identifiers();
		}
		DebugLocation(244, 2);
		} finally { DebugExitRule(GrammarFileName, "identifiers"); }
		return retval;

	}
	// $ANTLR end "identifiers"

	partial void EnterRule_constants();
	partial void LeaveRule_constants();

	// $ANTLR start "constants"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:245:1: constants : ( TRUE ^| FALSE ^| INTEGER ^| STRING ^);
	[GrammarRule("constants")]
	private AstParserRuleReturnScope<object, IToken> constants()
	{
		EnterRule_constants();
		EnterRule("constants", 21);
		TraceIn("constants", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TRUE84 = default(IToken);
		IToken FALSE85 = default(IToken);
		IToken INTEGER86 = default(IToken);
		IToken STRING87 = default(IToken);

		object TRUE84_tree = default(object);
		object FALSE85_tree = default(object);
		object INTEGER86_tree = default(object);
		object STRING87_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "constants");
		DebugLocation(245, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:245:12: ( TRUE ^| FALSE ^| INTEGER ^| STRING ^)
			int alt24=4;
			try { DebugEnterDecision(24, false);
			switch (input.LA(1))
			{
			case TRUE:
				{
				alt24 = 1;
				}
				break;
			case FALSE:
				{
				alt24 = 2;
				}
				break;
			case INTEGER:
				{
				alt24 = 3;
				}
				break;
			case STRING:
				{
				alt24 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:245:14: TRUE ^
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(245, 18);
				TRUE84=(IToken)Match(input,TRUE,Follow._TRUE_in_constants1696); 
				TRUE84_tree = (object)adaptor.Create(TRUE84);
				root_0 = (object)adaptor.BecomeRoot(TRUE84_tree, root_0);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:246:5: FALSE ^
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(246, 10);
				FALSE85=(IToken)Match(input,FALSE,Follow._FALSE_in_constants1704); 
				FALSE85_tree = (object)adaptor.Create(FALSE85);
				root_0 = (object)adaptor.BecomeRoot(FALSE85_tree, root_0);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:247:5: INTEGER ^
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(247, 12);
				INTEGER86=(IToken)Match(input,INTEGER,Follow._INTEGER_in_constants1711); 
				INTEGER86_tree = (object)adaptor.Create(INTEGER86);
				root_0 = (object)adaptor.BecomeRoot(INTEGER86_tree, root_0);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:248:6: STRING ^
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(248, 12);
				STRING87=(IToken)Match(input,STRING,Follow._STRING_in_constants1719); 
				STRING87_tree = (object)adaptor.Create(STRING87);
				root_0 = (object)adaptor.BecomeRoot(STRING87_tree, root_0);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constants", 21);
			LeaveRule("constants", 21);
			LeaveRule_constants();
		}
		DebugLocation(249, 2);
		} finally { DebugExitRule(GrammarFileName, "constants"); }
		return retval;

	}
	// $ANTLR end "constants"

	partial void EnterRule_call_expr();
	partial void LeaveRule_call_expr();

	// $ANTLR start "call_expr"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:251:2: call_expr : OBJ_ID LPAREN ( invokeExpressions )? RPAREN -> ^( ImplicitInvoke OBJ_ID ( invokeExpressions )? ) ;
	[GrammarRule("call_expr")]
	private AstParserRuleReturnScope<object, IToken> call_expr()
	{
		EnterRule_call_expr();
		EnterRule("call_expr", 22);
		TraceIn("call_expr", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OBJ_ID88 = default(IToken);
		IToken LPAREN89 = default(IToken);
		IToken RPAREN91 = default(IToken);
		AstParserRuleReturnScope<object, IToken> invokeExpressions90 = default(AstParserRuleReturnScope<object, IToken>);

		object OBJ_ID88_tree = default(object);
		object LPAREN89_tree = default(object);
		object RPAREN91_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_OBJ_ID=new RewriteRuleITokenStream(adaptor,"token OBJ_ID");
		RewriteRuleSubtreeStream stream_invokeExpressions=new RewriteRuleSubtreeStream(adaptor,"rule invokeExpressions");
		try { DebugEnterRule(GrammarFileName, "call_expr");
		DebugLocation(251, 3);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:251:13: ( OBJ_ID LPAREN ( invokeExpressions )? RPAREN -> ^( ImplicitInvoke OBJ_ID ( invokeExpressions )? ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:252:6: OBJ_ID LPAREN ( invokeExpressions )? RPAREN
			{
			DebugLocation(252, 6);
			OBJ_ID88=(IToken)Match(input,OBJ_ID,Follow._OBJ_ID_in_call_expr1741);  
			stream_OBJ_ID.Add(OBJ_ID88);

			DebugLocation(252, 14);
			LPAREN89=(IToken)Match(input,LPAREN,Follow._LPAREN_in_call_expr1744);  
			stream_LPAREN.Add(LPAREN89);

			DebugLocation(252, 21);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:252:21: ( invokeExpressions )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_0 = input.LA(1);

			if ((LA25_0==CASE||LA25_0==DO||LA25_0==FALSE||LA25_0==IF||(LA25_0>=INTEGER && LA25_0<=ISVOID)||(LA25_0>=LET && LA25_0<=LKEY)||LA25_0==LPAREN||(LA25_0>=NEG && LA25_0<=OBJ_ID)||LA25_0==SELF||LA25_0==STRING||LA25_0==TRUE||LA25_0==WHILE))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:252:21: invokeExpressions
				{
				DebugLocation(252, 21);
				PushFollow(Follow._invokeExpressions_in_call_expr1746);
				invokeExpressions90=invokeExpressions();
				PopFollow();

				stream_invokeExpressions.Add(invokeExpressions90.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(252, 41);
			RPAREN91=(IToken)Match(input,RPAREN,Follow._RPAREN_in_call_expr1750);  
			stream_RPAREN.Add(RPAREN91);



			{
			// AST REWRITE
			// elements: invokeExpressions, OBJ_ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 253:5: -> ^( ImplicitInvoke OBJ_ID ( invokeExpressions )? )
			{
				DebugLocation(253, 7);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:253:7: ^( ImplicitInvoke OBJ_ID ( invokeExpressions )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(253, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ImplicitInvoke, "ImplicitInvoke"), root_1);

				DebugLocation(253, 24);
				adaptor.AddChild(root_1, stream_OBJ_ID.NextNode());
				DebugLocation(253, 31);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:253:31: ( invokeExpressions )?
				if (stream_invokeExpressions.HasNext)
				{
					DebugLocation(253, 31);
					adaptor.AddChild(root_1, stream_invokeExpressions.NextTree());

				}
				stream_invokeExpressions.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("call_expr", 22);
			LeaveRule("call_expr", 22);
			LeaveRule_call_expr();
		}
		DebugLocation(254, 3);
		} finally { DebugExitRule(GrammarFileName, "call_expr"); }
		return retval;

	}
	// $ANTLR end "call_expr"

	partial void EnterRule_invokeExpressions();
	partial void LeaveRule_invokeExpressions();

	// $ANTLR start "invokeExpressions"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:256:1: invokeExpressions : expression ( COMMA expression )* -> ^( Params ( expression )+ ) ;
	[GrammarRule("invokeExpressions")]
	private AstParserRuleReturnScope<object, IToken> invokeExpressions()
	{
		EnterRule_invokeExpressions();
		EnterRule("invokeExpressions", 23);
		TraceIn("invokeExpressions", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA93 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression92 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression94 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA93_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "invokeExpressions");
		DebugLocation(256, 2);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:256:19: ( expression ( COMMA expression )* -> ^( Params ( expression )+ ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:256:23: expression ( COMMA expression )*
			{
			DebugLocation(256, 23);
			PushFollow(Follow._expression_in_invokeExpressions1782);
			expression92=expression();
			PopFollow();

			stream_expression.Add(expression92.Tree);
			DebugLocation(256, 33);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:256:33: ( COMMA expression )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_0 = input.LA(1);

				if ((LA26_0==COMMA))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:256:35: COMMA expression
					{
					DebugLocation(256, 35);
					COMMA93=(IToken)Match(input,COMMA,Follow._COMMA_in_invokeExpressions1785);  
					stream_COMMA.Add(COMMA93);

					DebugLocation(256, 41);
					PushFollow(Follow._expression_in_invokeExpressions1787);
					expression94=expression();
					PopFollow();

					stream_expression.Add(expression94.Tree);

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 257:4: -> ^( Params ( expression )+ )
			{
				DebugLocation(257, 6);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:257:6: ^( Params ( expression )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(257, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(Params, "Params"), root_1);

				DebugLocation(257, 15);
				if (!(stream_expression.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.HasNext )
				{
					DebugLocation(257, 15);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("invokeExpressions", 23);
			LeaveRule("invokeExpressions", 23);
			LeaveRule_invokeExpressions();
		}
		DebugLocation(258, 2);
		} finally { DebugExitRule(GrammarFileName, "invokeExpressions"); }
		return retval;

	}
	// $ANTLR end "invokeExpressions"

	partial void EnterRule_conditionals_expr();
	partial void LeaveRule_conditionals_expr();

	// $ANTLR start "conditionals_expr"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:259:1: conditionals_expr : IF cond= expression THEN e1= expression ( ELSE e2= expression )? FI -> ^( IF $cond $e1 ( $e2)? ) ;
	[GrammarRule("conditionals_expr")]
	private AstParserRuleReturnScope<object, IToken> conditionals_expr()
	{
		EnterRule_conditionals_expr();
		EnterRule("conditionals_expr", 24);
		TraceIn("conditionals_expr", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IF95 = default(IToken);
		IToken THEN96 = default(IToken);
		IToken ELSE97 = default(IToken);
		IToken FI98 = default(IToken);
		AstParserRuleReturnScope<object, IToken> cond = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> e1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> e2 = default(AstParserRuleReturnScope<object, IToken>);

		object IF95_tree = default(object);
		object THEN96_tree = default(object);
		object ELSE97_tree = default(object);
		object FI98_tree = default(object);
		RewriteRuleITokenStream stream_FI=new RewriteRuleITokenStream(adaptor,"token FI");
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleITokenStream stream_THEN=new RewriteRuleITokenStream(adaptor,"token THEN");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "conditionals_expr");
		DebugLocation(259, 1);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:260:2: ( IF cond= expression THEN e1= expression ( ELSE e2= expression )? FI -> ^( IF $cond $e1 ( $e2)? ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:260:4: IF cond= expression THEN e1= expression ( ELSE e2= expression )? FI
			{
			DebugLocation(260, 4);
			IF95=(IToken)Match(input,IF,Follow._IF_in_conditionals_expr1813);  
			stream_IF.Add(IF95);

			DebugLocation(260, 11);
			PushFollow(Follow._expression_in_conditionals_expr1817);
			cond=expression();
			PopFollow();

			stream_expression.Add(cond.Tree);
			DebugLocation(260, 24);
			THEN96=(IToken)Match(input,THEN,Follow._THEN_in_conditionals_expr1820);  
			stream_THEN.Add(THEN96);

			DebugLocation(260, 31);
			PushFollow(Follow._expression_in_conditionals_expr1825);
			e1=expression();
			PopFollow();

			stream_expression.Add(e1.Tree);
			DebugLocation(260, 45);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:260:45: ( ELSE e2= expression )?
			int alt27=2;
			try { DebugEnterSubRule(27);
			try { DebugEnterDecision(27, false);
			int LA27_0 = input.LA(1);

			if ((LA27_0==ELSE))
			{
				alt27 = 1;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:260:46: ELSE e2= expression
				{
				DebugLocation(260, 46);
				ELSE97=(IToken)Match(input,ELSE,Follow._ELSE_in_conditionals_expr1829);  
				stream_ELSE.Add(ELSE97);

				DebugLocation(260, 54);
				PushFollow(Follow._expression_in_conditionals_expr1835);
				e2=expression();
				PopFollow();

				stream_expression.Add(e2.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(27); }

			DebugLocation(260, 70);
			FI98=(IToken)Match(input,FI,Follow._FI_in_conditionals_expr1840);  
			stream_FI.Add(FI98);



			{
			// AST REWRITE
			// elements: e2, IF, e1, cond
			// token labels: 
			// rule labels: e1, e2, retval, cond
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.Tree:null);
			RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_cond=new RewriteRuleSubtreeStream(adaptor,"rule cond",cond!=null?cond.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 261:3: -> ^( IF $cond $e1 ( $e2)? )
			{
				DebugLocation(261, 6);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:261:6: ^( IF $cond $e1 ( $e2)? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(261, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_IF.NextNode(), root_1);

				DebugLocation(261, 13);
				adaptor.AddChild(root_1, stream_cond.NextTree());
				DebugLocation(261, 19);
				adaptor.AddChild(root_1, stream_e1.NextTree());
				DebugLocation(261, 23);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:261:23: ( $e2)?
				if (stream_e2.HasNext)
				{
					DebugLocation(261, 23);
					adaptor.AddChild(root_1, stream_e2.NextTree());

				}
				stream_e2.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionals_expr", 24);
			LeaveRule("conditionals_expr", 24);
			LeaveRule_conditionals_expr();
		}
		DebugLocation(262, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionals_expr"); }
		return retval;

	}
	// $ANTLR end "conditionals_expr"

	partial void EnterRule_loops();
	partial void LeaveRule_loops();

	// $ANTLR start "loops"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:263:1: loops : ( WHILE cond= expression LOOP loop= expression POOL -> ^( WHILE $cond $loop) | DO loop= expression WHILE cond= expression OD -> ^( DoWhile $loop $cond) );
	[GrammarRule("loops")]
	private AstParserRuleReturnScope<object, IToken> loops()
	{
		EnterRule_loops();
		EnterRule("loops", 25);
		TraceIn("loops", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WHILE99 = default(IToken);
		IToken LOOP100 = default(IToken);
		IToken POOL101 = default(IToken);
		IToken DO102 = default(IToken);
		IToken WHILE103 = default(IToken);
		IToken OD104 = default(IToken);
		AstParserRuleReturnScope<object, IToken> cond = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> loop = default(AstParserRuleReturnScope<object, IToken>);

		object WHILE99_tree = default(object);
		object LOOP100_tree = default(object);
		object POOL101_tree = default(object);
		object DO102_tree = default(object);
		object WHILE103_tree = default(object);
		object OD104_tree = default(object);
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleITokenStream stream_OD=new RewriteRuleITokenStream(adaptor,"token OD");
		RewriteRuleITokenStream stream_DO=new RewriteRuleITokenStream(adaptor,"token DO");
		RewriteRuleITokenStream stream_LOOP=new RewriteRuleITokenStream(adaptor,"token LOOP");
		RewriteRuleITokenStream stream_POOL=new RewriteRuleITokenStream(adaptor,"token POOL");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "loops");
		DebugLocation(263, 1);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:263:7: ( WHILE cond= expression LOOP loop= expression POOL -> ^( WHILE $cond $loop) | DO loop= expression WHILE cond= expression OD -> ^( DoWhile $loop $cond) )
			int alt28=2;
			try { DebugEnterDecision(28, false);
			int LA28_0 = input.LA(1);

			if ((LA28_0==WHILE))
			{
				alt28 = 1;
			}
			else if ((LA28_0==DO))
			{
				alt28 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:263:10: WHILE cond= expression LOOP loop= expression POOL
				{
				DebugLocation(263, 10);
				WHILE99=(IToken)Match(input,WHILE,Follow._WHILE_in_loops1871);  
				stream_WHILE.Add(WHILE99);

				DebugLocation(263, 21);
				PushFollow(Follow._expression_in_loops1877);
				cond=expression();
				PopFollow();

				stream_expression.Add(cond.Tree);
				DebugLocation(263, 34);
				LOOP100=(IToken)Match(input,LOOP,Follow._LOOP_in_loops1879);  
				stream_LOOP.Add(LOOP100);

				DebugLocation(263, 44);
				PushFollow(Follow._expression_in_loops1885);
				loop=expression();
				PopFollow();

				stream_expression.Add(loop.Tree);
				DebugLocation(263, 57);
				POOL101=(IToken)Match(input,POOL,Follow._POOL_in_loops1887);  
				stream_POOL.Add(POOL101);



				{
				// AST REWRITE
				// elements: WHILE, cond, loop
				// token labels: 
				// rule labels: loop, retval, cond
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_loop=new RewriteRuleSubtreeStream(adaptor,"rule loop",loop!=null?loop.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_cond=new RewriteRuleSubtreeStream(adaptor,"rule cond",cond!=null?cond.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 264:3: -> ^( WHILE $cond $loop)
				{
					DebugLocation(264, 5);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:264:5: ^( WHILE $cond $loop)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(264, 8);
					root_1 = (object)adaptor.BecomeRoot(stream_WHILE.NextNode(), root_1);

					DebugLocation(264, 15);
					adaptor.AddChild(root_1, stream_cond.NextTree());
					DebugLocation(264, 21);
					adaptor.AddChild(root_1, stream_loop.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:266:3: DO loop= expression WHILE cond= expression OD
				{
				DebugLocation(266, 3);
				DO102=(IToken)Match(input,DO,Follow._DO_in_loops1910);  
				stream_DO.Add(DO102);

				DebugLocation(266, 10);
				PushFollow(Follow._expression_in_loops1914);
				loop=expression();
				PopFollow();

				stream_expression.Add(loop.Tree);
				DebugLocation(266, 23);
				WHILE103=(IToken)Match(input,WHILE,Follow._WHILE_in_loops1917);  
				stream_WHILE.Add(WHILE103);

				DebugLocation(266, 33);
				PushFollow(Follow._expression_in_loops1921);
				cond=expression();
				PopFollow();

				stream_expression.Add(cond.Tree);
				DebugLocation(266, 45);
				OD104=(IToken)Match(input,OD,Follow._OD_in_loops1923);  
				stream_OD.Add(OD104);



				{
				// AST REWRITE
				// elements: cond, loop
				// token labels: 
				// rule labels: loop, retval, cond
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_loop=new RewriteRuleSubtreeStream(adaptor,"rule loop",loop!=null?loop.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_cond=new RewriteRuleSubtreeStream(adaptor,"rule cond",cond!=null?cond.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 267:3: -> ^( DoWhile $loop $cond)
				{
					DebugLocation(267, 5);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:267:5: ^( DoWhile $loop $cond)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(267, 7);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DoWhile, "DoWhile"), root_1);

					DebugLocation(267, 17);
					adaptor.AddChild(root_1, stream_loop.NextTree());
					DebugLocation(267, 24);
					adaptor.AddChild(root_1, stream_cond.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("loops", 25);
			LeaveRule("loops", 25);
			LeaveRule_loops();
		}
		DebugLocation(268, 1);
		} finally { DebugExitRule(GrammarFileName, "loops"); }
		return retval;

	}
	// $ANTLR end "loops"

	partial void EnterRule_blocks();
	partial void LeaveRule_blocks();

	// $ANTLR start "blocks"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:270:1: blocks : LKEY ( expression SEMI )+ RKEY -> ^( Block ( expression )+ ) ;
	[GrammarRule("blocks")]
	private AstParserRuleReturnScope<object, IToken> blocks()
	{
		EnterRule_blocks();
		EnterRule("blocks", 26);
		TraceIn("blocks", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LKEY105 = default(IToken);
		IToken SEMI107 = default(IToken);
		IToken RKEY108 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression106 = default(AstParserRuleReturnScope<object, IToken>);

		object LKEY105_tree = default(object);
		object SEMI107_tree = default(object);
		object RKEY108_tree = default(object);
		RewriteRuleITokenStream stream_RKEY=new RewriteRuleITokenStream(adaptor,"token RKEY");
		RewriteRuleITokenStream stream_LKEY=new RewriteRuleITokenStream(adaptor,"token LKEY");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "blocks");
		DebugLocation(270, 1);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:270:8: ( LKEY ( expression SEMI )+ RKEY -> ^( Block ( expression )+ ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:270:11: LKEY ( expression SEMI )+ RKEY
			{
			DebugLocation(270, 11);
			LKEY105=(IToken)Match(input,LKEY,Follow._LKEY_in_blocks1950);  
			stream_LKEY.Add(LKEY105);

			DebugLocation(270, 17);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:270:17: ( expression SEMI )+
			int cnt29=0;
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_0 = input.LA(1);

				if ((LA29_0==CASE||LA29_0==DO||LA29_0==FALSE||LA29_0==IF||(LA29_0>=INTEGER && LA29_0<=ISVOID)||(LA29_0>=LET && LA29_0<=LKEY)||LA29_0==LPAREN||(LA29_0>=NEG && LA29_0<=OBJ_ID)||LA29_0==SELF||LA29_0==STRING||LA29_0==TRUE||LA29_0==WHILE))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:270:18: expression SEMI
					{
					DebugLocation(270, 18);
					PushFollow(Follow._expression_in_blocks1954);
					expression106=expression();
					PopFollow();

					stream_expression.Add(expression106.Tree);
					DebugLocation(270, 29);
					SEMI107=(IToken)Match(input,SEMI,Follow._SEMI_in_blocks1956);  
					stream_SEMI.Add(SEMI107);


					}
					break;

				default:
					if (cnt29 >= 1)
						goto loop29;

					EarlyExitException eee29 = new EarlyExitException( 29, input );
					DebugRecognitionException(eee29);
					throw eee29;
				}
				cnt29++;
			}
			loop29:
				;

			} finally { DebugExitSubRule(29); }

			DebugLocation(270, 36);
			RKEY108=(IToken)Match(input,RKEY,Follow._RKEY_in_blocks1960);  
			stream_RKEY.Add(RKEY108);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 271:3: -> ^( Block ( expression )+ )
			{
				DebugLocation(271, 5);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:271:5: ^( Block ( expression )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(271, 7);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(Block, "Block"), root_1);

				DebugLocation(271, 13);
				if (!(stream_expression.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.HasNext )
				{
					DebugLocation(271, 13);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("blocks", 26);
			LeaveRule("blocks", 26);
			LeaveRule_blocks();
		}
		DebugLocation(272, 1);
		} finally { DebugExitRule(GrammarFileName, "blocks"); }
		return retval;

	}
	// $ANTLR end "blocks"

	partial void EnterRule_let();
	partial void LeaveRule_let();

	// $ANTLR start "let"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:274:1: let : LET letExprs IN child= expression -> ^( LET letExprs $child) ;
	[GrammarRule("let")]
	private AstParserRuleReturnScope<object, IToken> let()
	{
		EnterRule_let();
		EnterRule("let", 27);
		TraceIn("let", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LET109 = default(IToken);
		IToken IN111 = default(IToken);
		AstParserRuleReturnScope<object, IToken> child = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> letExprs110 = default(AstParserRuleReturnScope<object, IToken>);

		object LET109_tree = default(object);
		object IN111_tree = default(object);
		RewriteRuleITokenStream stream_LET=new RewriteRuleITokenStream(adaptor,"token LET");
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleSubtreeStream stream_letExprs=new RewriteRuleSubtreeStream(adaptor,"rule letExprs");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "let");
		DebugLocation(274, 1);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:274:6: ( LET letExprs IN child= expression -> ^( LET letExprs $child) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:274:8: LET letExprs IN child= expression
			{
			DebugLocation(274, 8);
			LET109=(IToken)Match(input,LET,Follow._LET_in_let1984);  
			stream_LET.Add(LET109);

			DebugLocation(274, 13);
			PushFollow(Follow._letExprs_in_let1987);
			letExprs110=letExprs();
			PopFollow();

			stream_letExprs.Add(letExprs110.Tree);
			DebugLocation(274, 22);
			IN111=(IToken)Match(input,IN,Follow._IN_in_let1989);  
			stream_IN.Add(IN111);

			DebugLocation(274, 30);
			PushFollow(Follow._expression_in_let1994);
			child=expression();
			PopFollow();

			stream_expression.Add(child.Tree);


			{
			// AST REWRITE
			// elements: letExprs, LET, child
			// token labels: 
			// rule labels: child, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_child=new RewriteRuleSubtreeStream(adaptor,"rule child",child!=null?child.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 275:3: -> ^( LET letExprs $child)
			{
				DebugLocation(275, 6);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:275:6: ^( LET letExprs $child)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(275, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_LET.NextNode(), root_1);

				DebugLocation(275, 13);
				adaptor.AddChild(root_1, stream_letExprs.NextTree());
				DebugLocation(275, 23);
				adaptor.AddChild(root_1, stream_child.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("let", 27);
			LeaveRule("let", 27);
			LeaveRule_let();
		}
		DebugLocation(276, 1);
		} finally { DebugExitRule(GrammarFileName, "let"); }
		return retval;

	}
	// $ANTLR end "let"

	partial void EnterRule_letExprs();
	partial void LeaveRule_letExprs();

	// $ANTLR start "letExprs"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:278:1: letExprs : localOrFieldInit ( COMMA localOrFieldInit )* -> ^( LetExprs ( localOrFieldInit )+ ) ;
	[GrammarRule("letExprs")]
	private AstParserRuleReturnScope<object, IToken> letExprs()
	{
		EnterRule_letExprs();
		EnterRule("letExprs", 28);
		TraceIn("letExprs", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA113 = default(IToken);
		AstParserRuleReturnScope<object, IToken> localOrFieldInit112 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> localOrFieldInit114 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA113_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_localOrFieldInit=new RewriteRuleSubtreeStream(adaptor,"rule localOrFieldInit");
		try { DebugEnterRule(GrammarFileName, "letExprs");
		DebugLocation(278, 1);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:278:10: ( localOrFieldInit ( COMMA localOrFieldInit )* -> ^( LetExprs ( localOrFieldInit )+ ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:278:13: localOrFieldInit ( COMMA localOrFieldInit )*
			{
			DebugLocation(278, 13);
			PushFollow(Follow._localOrFieldInit_in_letExprs2022);
			localOrFieldInit112=localOrFieldInit();
			PopFollow();

			stream_localOrFieldInit.Add(localOrFieldInit112.Tree);
			DebugLocation(278, 30);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:278:30: ( COMMA localOrFieldInit )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_0 = input.LA(1);

				if ((LA30_0==COMMA))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:278:31: COMMA localOrFieldInit
					{
					DebugLocation(278, 31);
					COMMA113=(IToken)Match(input,COMMA,Follow._COMMA_in_letExprs2025);  
					stream_COMMA.Add(COMMA113);

					DebugLocation(278, 37);
					PushFollow(Follow._localOrFieldInit_in_letExprs2027);
					localOrFieldInit114=localOrFieldInit();
					PopFollow();

					stream_localOrFieldInit.Add(localOrFieldInit114.Tree);

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }



			{
			// AST REWRITE
			// elements: localOrFieldInit
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 279:3: -> ^( LetExprs ( localOrFieldInit )+ )
			{
				DebugLocation(279, 5);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:279:5: ^( LetExprs ( localOrFieldInit )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(279, 7);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LetExprs, "LetExprs"), root_1);

				DebugLocation(279, 16);
				if (!(stream_localOrFieldInit.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_localOrFieldInit.HasNext )
				{
					DebugLocation(279, 16);
					adaptor.AddChild(root_1, stream_localOrFieldInit.NextTree());

				}
				stream_localOrFieldInit.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("letExprs", 28);
			LeaveRule("letExprs", 28);
			LeaveRule_letExprs();
		}
		DebugLocation(280, 1);
		} finally { DebugExitRule(GrammarFileName, "letExprs"); }
		return retval;

	}
	// $ANTLR end "letExprs"

	partial void EnterRule_case();
	partial void LeaveRule_case();

	// $ANTLR start "case"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:282:1: case : CASE expression OF ( caseExprs )+ ESAC -> ^( CASE expression ( caseExprs )+ ) ;
	[GrammarRule("case")]
	private AstParserRuleReturnScope<object, IToken> @case()
	{
		EnterRule_case();
		EnterRule("case", 29);
		TraceIn("case", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CASE115 = default(IToken);
		IToken OF117 = default(IToken);
		IToken ESAC119 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression116 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> caseExprs118 = default(AstParserRuleReturnScope<object, IToken>);

		object CASE115_tree = default(object);
		object OF117_tree = default(object);
		object ESAC119_tree = default(object);
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_ESAC=new RewriteRuleITokenStream(adaptor,"token ESAC");
		RewriteRuleITokenStream stream_CASE=new RewriteRuleITokenStream(adaptor,"token CASE");
		RewriteRuleSubtreeStream stream_caseExprs=new RewriteRuleSubtreeStream(adaptor,"rule caseExprs");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "case");
		DebugLocation(282, 1);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:282:6: ( CASE expression OF ( caseExprs )+ ESAC -> ^( CASE expression ( caseExprs )+ ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:282:9: CASE expression OF ( caseExprs )+ ESAC
			{
			DebugLocation(282, 9);
			CASE115=(IToken)Match(input,CASE,Follow._CASE_in_case2051);  
			stream_CASE.Add(CASE115);

			DebugLocation(282, 14);
			PushFollow(Follow._expression_in_case2053);
			expression116=expression();
			PopFollow();

			stream_expression.Add(expression116.Tree);
			DebugLocation(282, 26);
			OF117=(IToken)Match(input,OF,Follow._OF_in_case2056);  
			stream_OF.Add(OF117);

			DebugLocation(282, 29);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:282:29: ( caseExprs )+
			int cnt31=0;
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				int LA31_0 = input.LA(1);

				if ((LA31_0==OBJ_ID))
				{
					alt31 = 1;
				}


				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:282:29: caseExprs
					{
					DebugLocation(282, 29);
					PushFollow(Follow._caseExprs_in_case2058);
					caseExprs118=caseExprs();
					PopFollow();

					stream_caseExprs.Add(caseExprs118.Tree);

					}
					break;

				default:
					if (cnt31 >= 1)
						goto loop31;

					EarlyExitException eee31 = new EarlyExitException( 31, input );
					DebugRecognitionException(eee31);
					throw eee31;
				}
				cnt31++;
			}
			loop31:
				;

			} finally { DebugExitSubRule(31); }

			DebugLocation(282, 41);
			ESAC119=(IToken)Match(input,ESAC,Follow._ESAC_in_case2062);  
			stream_ESAC.Add(ESAC119);



			{
			// AST REWRITE
			// elements: caseExprs, CASE, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 283:3: -> ^( CASE expression ( caseExprs )+ )
			{
				DebugLocation(283, 6);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:283:6: ^( CASE expression ( caseExprs )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(283, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_CASE.NextNode(), root_1);

				DebugLocation(283, 13);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(283, 24);
				if (!(stream_caseExprs.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_caseExprs.HasNext )
				{
					DebugLocation(283, 24);
					adaptor.AddChild(root_1, stream_caseExprs.NextTree());

				}
				stream_caseExprs.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("case", 29);
			LeaveRule("case", 29);
			LeaveRule_case();
		}
		DebugLocation(284, 1);
		} finally { DebugExitRule(GrammarFileName, "case"); }
		return retval;

	}
	// $ANTLR end "case"

	partial void EnterRule_caseExprs();
	partial void LeaveRule_caseExprs();

	// $ANTLR start "caseExprs"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:285:1: caseExprs : OBJ_ID COLON TYPE_ID HENCE expression SEMI -> ^( CaseExpr OBJ_ID TYPE_ID expression ) ;
	[GrammarRule("caseExprs")]
	private AstParserRuleReturnScope<object, IToken> caseExprs()
	{
		EnterRule_caseExprs();
		EnterRule("caseExprs", 30);
		TraceIn("caseExprs", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OBJ_ID120 = default(IToken);
		IToken COLON121 = default(IToken);
		IToken TYPE_ID122 = default(IToken);
		IToken HENCE123 = default(IToken);
		IToken SEMI125 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression124 = default(AstParserRuleReturnScope<object, IToken>);

		object OBJ_ID120_tree = default(object);
		object COLON121_tree = default(object);
		object TYPE_ID122_tree = default(object);
		object HENCE123_tree = default(object);
		object SEMI125_tree = default(object);
		RewriteRuleITokenStream stream_TYPE_ID=new RewriteRuleITokenStream(adaptor,"token TYPE_ID");
		RewriteRuleITokenStream stream_OBJ_ID=new RewriteRuleITokenStream(adaptor,"token OBJ_ID");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_HENCE=new RewriteRuleITokenStream(adaptor,"token HENCE");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "caseExprs");
		DebugLocation(285, 1);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:285:11: ( OBJ_ID COLON TYPE_ID HENCE expression SEMI -> ^( CaseExpr OBJ_ID TYPE_ID expression ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:285:14: OBJ_ID COLON TYPE_ID HENCE expression SEMI
			{
			DebugLocation(285, 14);
			OBJ_ID120=(IToken)Match(input,OBJ_ID,Follow._OBJ_ID_in_caseExprs2085);  
			stream_OBJ_ID.Add(OBJ_ID120);

			DebugLocation(285, 21);
			COLON121=(IToken)Match(input,COLON,Follow._COLON_in_caseExprs2087);  
			stream_COLON.Add(COLON121);

			DebugLocation(285, 28);
			TYPE_ID122=(IToken)Match(input,TYPE_ID,Follow._TYPE_ID_in_caseExprs2090);  
			stream_TYPE_ID.Add(TYPE_ID122);

			DebugLocation(285, 36);
			HENCE123=(IToken)Match(input,HENCE,Follow._HENCE_in_caseExprs2092);  
			stream_HENCE.Add(HENCE123);

			DebugLocation(285, 42);
			PushFollow(Follow._expression_in_caseExprs2094);
			expression124=expression();
			PopFollow();

			stream_expression.Add(expression124.Tree);
			DebugLocation(285, 53);
			SEMI125=(IToken)Match(input,SEMI,Follow._SEMI_in_caseExprs2096);  
			stream_SEMI.Add(SEMI125);



			{
			// AST REWRITE
			// elements: OBJ_ID, expression, TYPE_ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 286:3: -> ^( CaseExpr OBJ_ID TYPE_ID expression )
			{
				DebugLocation(286, 5);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:286:5: ^( CaseExpr OBJ_ID TYPE_ID expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(286, 7);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CaseExpr, "CaseExpr"), root_1);

				DebugLocation(286, 16);
				adaptor.AddChild(root_1, stream_OBJ_ID.NextNode());
				DebugLocation(286, 23);
				adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());
				DebugLocation(286, 31);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseExprs", 30);
			LeaveRule("caseExprs", 30);
			LeaveRule_caseExprs();
		}
		DebugLocation(287, 1);
		} finally { DebugExitRule(GrammarFileName, "caseExprs"); }
		return retval;

	}
	// $ANTLR end "caseExprs"

	partial void EnterRule_new();
	partial void LeaveRule_new();

	// $ANTLR start "new"
	// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:288:1: new : NEW TYPE_ID -> ^( NEW TYPE_ID ) ;
	[GrammarRule("new")]
	private AstParserRuleReturnScope<object, IToken> @new()
	{
		EnterRule_new();
		EnterRule("new", 31);
		TraceIn("new", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NEW126 = default(IToken);
		IToken TYPE_ID127 = default(IToken);

		object NEW126_tree = default(object);
		object TYPE_ID127_tree = default(object);
		RewriteRuleITokenStream stream_TYPE_ID=new RewriteRuleITokenStream(adaptor,"token TYPE_ID");
		RewriteRuleITokenStream stream_NEW=new RewriteRuleITokenStream(adaptor,"token NEW");
		try { DebugEnterRule(GrammarFileName, "new");
		DebugLocation(288, 1);
		try
		{
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:288:6: ( NEW TYPE_ID -> ^( NEW TYPE_ID ) )
			DebugEnterAlt(1);
			// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:288:9: NEW TYPE_ID
			{
			DebugLocation(288, 9);
			NEW126=(IToken)Match(input,NEW,Follow._NEW_in_new2120);  
			stream_NEW.Add(NEW126);

			DebugLocation(288, 13);
			TYPE_ID127=(IToken)Match(input,TYPE_ID,Follow._TYPE_ID_in_new2122);  
			stream_TYPE_ID.Add(TYPE_ID127);



			{
			// AST REWRITE
			// elements: TYPE_ID, NEW
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 289:3: -> ^( NEW TYPE_ID )
			{
				DebugLocation(289, 6);
				// E:\\De Hiran\\CoolCompiler\\ANTLR\\CoolGrammar.g:289:6: ^( NEW TYPE_ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(289, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_NEW.NextNode(), root_1);

				DebugLocation(289, 12);
				adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("new", 31);
			LeaveRule("new", 31);
			LeaveRule_new();
		}
		DebugLocation(290, 1);
		} finally { DebugExitRule(GrammarFileName, "new"); }
		return retval;

	}
	// $ANTLR end "new"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _class_in_program851 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _SEMI_in_program853 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _CLASS_in_class886 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _TYPE_ID_in_class888 = new BitSet(new ulong[]{0x204000000000UL});
		public static readonly BitSet _INHERITS_in_class891 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _TYPE_ID_in_class893 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _LKEY_in_class897 = new BitSet(new ulong[]{0x400000000000000UL,0x4UL});
		public static readonly BitSet _feature_list_in_class899 = new BitSet(new ulong[]{0x0UL,0x4UL});
		public static readonly BitSet _RKEY_in_class902 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _feature_in_feature_list933 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _SEMI_in_feature_list935 = new BitSet(new ulong[]{0x400000000000002UL});
		public static readonly BitSet _localOrFieldInit_in_feature969 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_in_feature982 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBJ_ID_in_method1003 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _LPAREN_in_method1005 = new BitSet(new ulong[]{0x400000000000000UL,0x8UL});
		public static readonly BitSet _formal_parameters_in_method1008 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _RPAREN_in_method1012 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _COLON_in_method1015 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _TYPE_ID_in_method1018 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _LKEY_in_method1020 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_method1022 = new BitSet(new ulong[]{0x0UL,0x4UL});
		public static readonly BitSet _RKEY_in_method1024 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _formal_in_formal_parameters1058 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _COMMA_in_formal_parameters1063 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _formal_in_formal_parameters1065 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _OBJ_ID_in_formal1095 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _COLON_in_formal1098 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _TYPE_ID_in_formal1101 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBJ_ID_in_localOrFieldInit1128 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _COLON_in_localOrFieldInit1131 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _TYPE_ID_in_localOrFieldInit1134 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _ASSIGN_in_localOrFieldInit1137 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_localOrFieldInit1140 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _let_in_expression1179 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assig_expr_in_expression1189 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBJ_ID_in_assig_expr1210 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_assig_expr1212 = new BitSet(new ulong[]{0x781219010080400UL,0x550UL});
		public static readonly BitSet _not_expr_in_assig_expr1219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_not_expr1234 = new BitSet(new ulong[]{0x781219010080400UL,0x550UL});
		public static readonly BitSet _relation_in_not_expr1241 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _compare_expr_in_relation1255 = new BitSet(new ulong[]{0x2000000000000012UL});
		public static readonly BitSet _OR_in_relation1261 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _AND_in_relation1264 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _compare_expr_in_relation1269 = new BitSet(new ulong[]{0x2000000000000012UL});
		public static readonly BitSet _arith_expr_in_compare_expr1284 = new BitSet(new ulong[]{0x2080602000002UL});
		public static readonly BitSet _LE_in_compare_expr1291 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _LT_in_compare_expr1295 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _GE_in_compare_expr1299 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _GT_in_compare_expr1303 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _EQUAL_in_compare_expr1308 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _arith_expr_in_compare_expr1313 = new BitSet(new ulong[]{0x2080602000002UL});
		public static readonly BitSet _mult_expr_in_arith_expr1329 = new BitSet(new ulong[]{0x4010000000000002UL});
		public static readonly BitSet _PLUS_in_arith_expr1335 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _MINUS_in_arith_expr1339 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _mult_expr_in_arith_expr1343 = new BitSet(new ulong[]{0x4010000000000002UL});
		public static readonly BitSet _isVoid_expr_in_mult_expr1358 = new BitSet(new ulong[]{0x20000000040002UL});
		public static readonly BitSet _MULT_in_mult_expr1364 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _DIV_in_mult_expr1369 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _isVoid_expr_in_mult_expr1374 = new BitSet(new ulong[]{0x20000000040002UL});
		public static readonly BitSet _ISVOID_in_isVoid_expr1390 = new BitSet(new ulong[]{0x581219010080400UL,0x550UL});
		public static readonly BitSet _neg_expr_in_isVoid_expr1396 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEG_in_neg_expr1409 = new BitSet(new ulong[]{0x581209010080400UL,0x550UL});
		public static readonly BitSet _dot_expr_in_neg_expr1416 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_dot_expr1430 = new BitSet(new ulong[]{0x100042UL});
		public static readonly BitSet _ATSIGN_in_dot_expr1465 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _TYPE_ID_in_dot_expr1468 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _DOT_in_dot_expr1470 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _call_expr_in_dot_expr1473 = new BitSet(new ulong[]{0x100042UL});
		public static readonly BitSet _DOT_in_dot_expr1500 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _call_expr_in_dot_expr1503 = new BitSet(new ulong[]{0x100042UL});
		public static readonly BitSet _call_expr_in_term1548 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionals_expr_in_term1562 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _loops_in_term1575 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _blocks_in_term1589 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _case_in_term1601 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _new_in_term1612 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_term1623 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_term1625 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _RPAREN_in_term1627 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constants_in_term1638 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifiers_in_term1653 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBJ_ID_in_identifiers1672 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SELF_in_identifiers1681 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_constants1696 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_constants1704 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_constants1711 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_constants1719 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBJ_ID_in_call_expr1741 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _LPAREN_in_call_expr1744 = new BitSet(new ulong[]{0x781319010080400UL,0x558UL});
		public static readonly BitSet _invokeExpressions_in_call_expr1746 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _RPAREN_in_call_expr1750 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_invokeExpressions1782 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _COMMA_in_invokeExpressions1785 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_invokeExpressions1787 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _IF_in_conditionals_expr1813 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_conditionals_expr1817 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _THEN_in_conditionals_expr1820 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_conditionals_expr1825 = new BitSet(new ulong[]{0x21000000UL});
		public static readonly BitSet _ELSE_in_conditionals_expr1829 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_conditionals_expr1835 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _FI_in_conditionals_expr1840 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_loops1871 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_loops1877 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _LOOP_in_loops1879 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_loops1885 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _POOL_in_loops1887 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DO_in_loops1910 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_loops1914 = new BitSet(new ulong[]{0x0UL,0x400UL});
		public static readonly BitSet _WHILE_in_loops1917 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_loops1921 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _OD_in_loops1923 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LKEY_in_blocks1950 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_blocks1954 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _SEMI_in_blocks1956 = new BitSet(new ulong[]{0x781319010080400UL,0x554UL});
		public static readonly BitSet _RKEY_in_blocks1960 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LET_in_let1984 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _letExprs_in_let1987 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _IN_in_let1989 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_let1994 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _localOrFieldInit_in_letExprs2022 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _COMMA_in_letExprs2025 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _localOrFieldInit_in_letExprs2027 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _CASE_in_case2051 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_case2053 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _OF_in_case2056 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _caseExprs_in_case2058 = new BitSet(new ulong[]{0x400000004000000UL});
		public static readonly BitSet _ESAC_in_case2062 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBJ_ID_in_caseExprs2085 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _COLON_in_caseExprs2087 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _TYPE_ID_in_caseExprs2090 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _HENCE_in_caseExprs2092 = new BitSet(new ulong[]{0x781319010080400UL,0x550UL});
		public static readonly BitSet _expression_in_caseExprs2094 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _SEMI_in_caseExprs2096 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_new2120 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _TYPE_ID_in_new2122 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace CoolGrammar
