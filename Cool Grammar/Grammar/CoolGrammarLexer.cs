//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: null
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR null \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g 2019-02-25 21:55:41

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Text;
using CoolGrammar.Grammar;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace CoolGrammar
{
    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "null")]
    [System.CLSCompliant(false)]
    public partial class CoolGrammarLexer : Antlr.Runtime.Lexer
    {
        public const int EOF = -1;
        public const int AND = 4;
        public const int ASSIGN = 5;
        public const int ATSIGN = 6;
        public const int BREAK = 7;
        public const int Block = 8;
        public const int CAPITAL_LETTER = 9;
        public const int CASE = 10;
        public const int CLASS = 11;
        public const int COLON = 12;
        public const int COMMA = 13;
        public const int COMMENT = 14;
        public const int CaseExpr = 15;
        public const int Class = 16;
        public const int DIGIT = 17;
        public const int DIV = 18;
        public const int DO = 19;
        public const int DOT = 20;
        public const int DoWhile = 21;
        public const int DotObjectInvoke = 22;
        public const int DotTypeInvoke = 23;
        public const int ELSE = 24;
        public const int EQUAL = 25;
        public const int ESAC = 26;
        public const int ExprList = 27;
        public const int FALSE = 28;
        public const int FI = 29;
        public const int FeatureList = 30;
        public const int FuncDef = 31;
        public const int FunctionArgsList = 32;
        public const int GE = 33;
        public const int GT = 34;
        public const int HENCE = 35;
        public const int IF = 36;
        public const int IN = 37;
        public const int INHERITS = 38;
        public const int INTEGER = 39;
        public const int ISVOID = 40;
        public const int IdValue = 41;
        public const int ImplicitInvoke = 42;
        public const int LE = 43;
        public const int LET = 44;
        public const int LKEY = 45;
        public const int LOOP = 46;
        public const int LOWER_LETTER = 47;
        public const int LPAREN = 48;
        public const int LT = 49;
        public const int LetExprs = 50;
        public const int LocalOrFieldInit = 51;
        public const int MINUS = 52;
        public const int MULT = 53;
        public const int MULTILINE_COMMENT = 54;
        public const int NEG = 55;
        public const int NEW = 56;
        public const int NOT = 57;
        public const int OBJ_ID = 58;
        public const int OD = 59;
        public const int OF = 60;
        public const int OR = 61;
        public const int PLUS = 62;
        public const int POOL = 63;
        public const int Params = 64;
        public const int Program = 65;
        public const int RKEY = 66;
        public const int RPAREN = 67;
        public const int SELF = 68;
        public const int SEMI = 69;
        public const int STRING = 70;
        public const int THEN = 71;
        public const int TRUE = 72;
        public const int TYPE_ID = 73;
        public const int WHILE = 74;
        public const int WS = 75;

        public override void ReportError(RecognitionException e)
        {
            base.ReportError(e);
            var stringerror = GetErrorMessage(e, TokenNames);
            Logger.LogError(e.Line, e.CharPositionInLine, stringerror);
        }


        // delegates
        // delegators

        public CoolGrammarLexer()
        {
            OnCreated();
        }

        public CoolGrammarLexer(ICharStream input)
            : this(input, new RecognizerSharedState())
        {
        }

        public CoolGrammarLexer(ICharStream input, RecognizerSharedState state)
            : base(input, state)
        {

            OnCreated();
        }
        public override string GrammarFileName { get { return "\\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g"; } }


        partial void OnCreated();
        partial void EnterRule(string ruleName, int ruleIndex);
        partial void LeaveRule(string ruleName, int ruleIndex);

        partial void EnterRule_DIGIT();
        partial void LeaveRule_DIGIT();

        // $ANTLR start "DIGIT"
        [GrammarRule("DIGIT")]
        private void mDIGIT()
        {
            EnterRule_DIGIT();
            EnterRule("DIGIT", 1);
            TraceIn("DIGIT", 1);
            try
            {
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:61:6: ( '0' .. '9' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:
                {
                    DebugLocation(61, 6);
                    if ((input.LA(1) >= '0' && input.LA(1) <= '9'))
                    {
                        input.Consume();
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        Recover(mse);
                        throw mse;
                    }


                }

            }
            finally
            {
                TraceOut("DIGIT", 1);
                LeaveRule("DIGIT", 1);
                LeaveRule_DIGIT();
            }
        }
        // $ANTLR end "DIGIT"

        partial void EnterRule_CAPITAL_LETTER();
        partial void LeaveRule_CAPITAL_LETTER();

        // $ANTLR start "CAPITAL_LETTER"
        [GrammarRule("CAPITAL_LETTER")]
        private void mCAPITAL_LETTER()
        {
            EnterRule_CAPITAL_LETTER();
            EnterRule("CAPITAL_LETTER", 2);
            TraceIn("CAPITAL_LETTER", 2);
            try
            {
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:63:6: ( ( 'A' .. 'Z' ) )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:
                {
                    DebugLocation(63, 6);
                    if ((input.LA(1) >= 'A' && input.LA(1) <= 'Z'))
                    {
                        input.Consume();
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        Recover(mse);
                        throw mse;
                    }


                }

            }
            finally
            {
                TraceOut("CAPITAL_LETTER", 2);
                LeaveRule("CAPITAL_LETTER", 2);
                LeaveRule_CAPITAL_LETTER();
            }
        }
        // $ANTLR end "CAPITAL_LETTER"

        partial void EnterRule_LOWER_LETTER();
        partial void LeaveRule_LOWER_LETTER();

        // $ANTLR start "LOWER_LETTER"
        [GrammarRule("LOWER_LETTER")]
        private void mLOWER_LETTER()
        {
            EnterRule_LOWER_LETTER();
            EnterRule("LOWER_LETTER", 3);
            TraceIn("LOWER_LETTER", 3);
            try
            {
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:65:2: ( ( 'a' .. 'z' ) )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:
                {
                    DebugLocation(65, 2);
                    if ((input.LA(1) >= 'a' && input.LA(1) <= 'z'))
                    {
                        input.Consume();
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        Recover(mse);
                        throw mse;
                    }


                }

            }
            finally
            {
                TraceOut("LOWER_LETTER", 3);
                LeaveRule("LOWER_LETTER", 3);
                LeaveRule_LOWER_LETTER();
            }
        }
        // $ANTLR end "LOWER_LETTER"

        partial void EnterRule_CLASS();
        partial void LeaveRule_CLASS();

        // $ANTLR start "CLASS"
        [GrammarRule("CLASS")]
        private void mCLASS()
        {
            EnterRule_CLASS();
            EnterRule("CLASS", 4);
            TraceIn("CLASS", 4);
            try
            {
                int _type = CLASS;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:69:12: ( 'class' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:69:14: 'class'
                {
                    DebugLocation(69, 14);
                    Match("class");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("CLASS", 4);
                LeaveRule("CLASS", 4);
                LeaveRule_CLASS();
            }
        }
        // $ANTLR end "CLASS"

        partial void EnterRule_ELSE();
        partial void LeaveRule_ELSE();

        // $ANTLR start "ELSE"
        [GrammarRule("ELSE")]
        private void mELSE()
        {
            EnterRule_ELSE();
            EnterRule("ELSE", 5);
            TraceIn("ELSE", 5);
            try
            {
                int _type = ELSE;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:70:10: ( 'else' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:70:12: 'else'
                {
                    DebugLocation(70, 12);
                    Match("else");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("ELSE", 5);
                LeaveRule("ELSE", 5);
                LeaveRule_ELSE();
            }
        }
        // $ANTLR end "ELSE"

        partial void EnterRule_FALSE();
        partial void LeaveRule_FALSE();

        // $ANTLR start "FALSE"
        [GrammarRule("FALSE")]
        private void mFALSE()
        {
            EnterRule_FALSE();
            EnterRule("FALSE", 6);
            TraceIn("FALSE", 6);
            try
            {
                int _type = FALSE;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:71:11: ( 'false' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:71:13: 'false'
                {
                    DebugLocation(71, 13);
                    Match("false");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("FALSE", 6);
                LeaveRule("FALSE", 6);
                LeaveRule_FALSE();
            }
        }
        // $ANTLR end "FALSE"

        partial void EnterRule_FI();
        partial void LeaveRule_FI();

        // $ANTLR start "FI"
        [GrammarRule("FI")]
        private void mFI()
        {
            EnterRule_FI();
            EnterRule("FI", 7);
            TraceIn("FI", 7);
            try
            {
                int _type = FI;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:72:12: ( 'fi' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:72:14: 'fi'
                {
                    DebugLocation(72, 14);
                    Match("fi");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("FI", 7);
                LeaveRule("FI", 7);
                LeaveRule_FI();
            }
        }
        // $ANTLR end "FI"

        partial void EnterRule_IF();
        partial void LeaveRule_IF();

        // $ANTLR start "IF"
        [GrammarRule("IF")]
        private void mIF()
        {
            EnterRule_IF();
            EnterRule("IF", 8);
            TraceIn("IF", 8);
            try
            {
                int _type = IF;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:73:13: ( 'if' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:73:15: 'if'
                {
                    DebugLocation(73, 15);
                    Match("if");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("IF", 8);
                LeaveRule("IF", 8);
                LeaveRule_IF();
            }
        }
        // $ANTLR end "IF"

        partial void EnterRule_IN();
        partial void LeaveRule_IN();

        // $ANTLR start "IN"
        [GrammarRule("IN")]
        private void mIN()
        {
            EnterRule_IN();
            EnterRule("IN", 9);
            TraceIn("IN", 9);
            try
            {
                int _type = IN;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:74:12: ( 'in' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:74:15: 'in'
                {
                    DebugLocation(74, 15);
                    Match("in");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("IN", 9);
                LeaveRule("IN", 9);
                LeaveRule_IN();
            }
        }
        // $ANTLR end "IN"

        partial void EnterRule_INHERITS();
        partial void LeaveRule_INHERITS();

        // $ANTLR start "INHERITS"
        [GrammarRule("INHERITS")]
        private void mINHERITS()
        {
            EnterRule_INHERITS();
            EnterRule("INHERITS", 10);
            TraceIn("INHERITS", 10);
            try
            {
                int _type = INHERITS;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:75:10: ( 'inherits' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:75:12: 'inherits'
                {
                    DebugLocation(75, 12);
                    Match("inherits");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("INHERITS", 10);
                LeaveRule("INHERITS", 10);
                LeaveRule_INHERITS();
            }
        }
        // $ANTLR end "INHERITS"

        partial void EnterRule_ISVOID();
        partial void LeaveRule_ISVOID();

        // $ANTLR start "ISVOID"
        [GrammarRule("ISVOID")]
        private void mISVOID()
        {
            EnterRule_ISVOID();
            EnterRule("ISVOID", 11);
            TraceIn("ISVOID", 11);
            try
            {
                int _type = ISVOID;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:76:12: ( 'isvoid' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:76:14: 'isvoid'
                {
                    DebugLocation(76, 14);
                    Match("isvoid");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("ISVOID", 11);
                LeaveRule("ISVOID", 11);
                LeaveRule_ISVOID();
            }
        }
        // $ANTLR end "ISVOID"

        partial void EnterRule_LET();
        partial void LeaveRule_LET();

        // $ANTLR start "LET"
        [GrammarRule("LET")]
        private void mLET()
        {
            EnterRule_LET();
            EnterRule("LET", 12);
            TraceIn("LET", 12);
            try
            {
                int _type = LET;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:77:13: ( 'let' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:77:15: 'let'
                {
                    DebugLocation(77, 15);
                    Match("let");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("LET", 12);
                LeaveRule("LET", 12);
                LeaveRule_LET();
            }
        }
        // $ANTLR end "LET"

        partial void EnterRule_LOOP();
        partial void LeaveRule_LOOP();

        // $ANTLR start "LOOP"
        [GrammarRule("LOOP")]
        private void mLOOP()
        {
            EnterRule_LOOP();
            EnterRule("LOOP", 13);
            TraceIn("LOOP", 13);
            try
            {
                int _type = LOOP;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:78:11: ( 'loop' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:78:13: 'loop'
                {
                    DebugLocation(78, 13);
                    Match("loop");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("LOOP", 13);
                LeaveRule("LOOP", 13);
                LeaveRule_LOOP();
            }
        }
        // $ANTLR end "LOOP"

        partial void EnterRule_POOL();
        partial void LeaveRule_POOL();

        // $ANTLR start "POOL"
        [GrammarRule("POOL")]
        private void mPOOL()
        {
            EnterRule_POOL();
            EnterRule("POOL", 14);
            TraceIn("POOL", 14);
            try
            {
                int _type = POOL;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:79:11: ( 'pool' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:79:13: 'pool'
                {
                    DebugLocation(79, 13);
                    Match("pool");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("POOL", 14);
                LeaveRule("POOL", 14);
                LeaveRule_POOL();
            }
        }
        // $ANTLR end "POOL"

        partial void EnterRule_THEN();
        partial void LeaveRule_THEN();

        // $ANTLR start "THEN"
        [GrammarRule("THEN")]
        private void mTHEN()
        {
            EnterRule_THEN();
            EnterRule("THEN", 15);
            TraceIn("THEN", 15);
            try
            {
                int _type = THEN;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:80:11: ( 'then' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:80:13: 'then'
                {
                    DebugLocation(80, 13);
                    Match("then");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("THEN", 15);
                LeaveRule("THEN", 15);
                LeaveRule_THEN();
            }
        }
        // $ANTLR end "THEN"

        partial void EnterRule_WHILE();
        partial void LeaveRule_WHILE();

        // $ANTLR start "WHILE"
        [GrammarRule("WHILE")]
        private void mWHILE()
        {
            EnterRule_WHILE();
            EnterRule("WHILE", 16);
            TraceIn("WHILE", 16);
            try
            {
                int _type = WHILE;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:81:12: ( 'while' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:81:14: 'while'
                {
                    DebugLocation(81, 14);
                    Match("while");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("WHILE", 16);
                LeaveRule("WHILE", 16);
                LeaveRule_WHILE();
            }
        }
        // $ANTLR end "WHILE"

        partial void EnterRule_DO();
        partial void LeaveRule_DO();

        // $ANTLR start "DO"
        [GrammarRule("DO")]
        private void mDO()
        {
            EnterRule_DO();
            EnterRule("DO", 17);
            TraceIn("DO", 17);
            try
            {
                int _type = DO;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:82:12: ( 'do' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:82:16: 'do'
                {
                    DebugLocation(82, 16);
                    Match("do");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("DO", 17);
                LeaveRule("DO", 17);
                LeaveRule_DO();
            }
        }
        // $ANTLR end "DO"

        partial void EnterRule_OD();
        partial void LeaveRule_OD();

        // $ANTLR start "OD"
        [GrammarRule("OD")]
        private void mOD()
        {
            EnterRule_OD();
            EnterRule("OD", 18);
            TraceIn("OD", 18);
            try
            {
                int _type = OD;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:83:12: ( 'od' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:83:14: 'od'
                {
                    DebugLocation(83, 14);
                    Match("od");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("OD", 18);
                LeaveRule("OD", 18);
                LeaveRule_OD();
            }
        }
        // $ANTLR end "OD"

        partial void EnterRule_CASE();
        partial void LeaveRule_CASE();

        // $ANTLR start "CASE"
        [GrammarRule("CASE")]
        private void mCASE()
        {
            EnterRule_CASE();
            EnterRule("CASE", 19);
            TraceIn("CASE", 19);
            try
            {
                int _type = CASE;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:84:11: ( 'case' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:84:13: 'case'
                {
                    DebugLocation(84, 13);
                    Match("case");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("CASE", 19);
                LeaveRule("CASE", 19);
                LeaveRule_CASE();
            }
        }
        // $ANTLR end "CASE"

        partial void EnterRule_ESAC();
        partial void LeaveRule_ESAC();

        // $ANTLR start "ESAC"
        [GrammarRule("ESAC")]
        private void mESAC()
        {
            EnterRule_ESAC();
            EnterRule("ESAC", 20);
            TraceIn("ESAC", 20);
            try
            {
                int _type = ESAC;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:85:11: ( 'esac' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:85:13: 'esac'
                {
                    DebugLocation(85, 13);
                    Match("esac");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("ESAC", 20);
                LeaveRule("ESAC", 20);
                LeaveRule_ESAC();
            }
        }
        // $ANTLR end "ESAC"

        partial void EnterRule_NEW();
        partial void LeaveRule_NEW();

        // $ANTLR start "NEW"
        [GrammarRule("NEW")]
        private void mNEW()
        {
            EnterRule_NEW();
            EnterRule("NEW", 21);
            TraceIn("NEW", 21);
            try
            {
                int _type = NEW;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:86:10: ( 'new' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:86:12: 'new'
                {
                    DebugLocation(86, 12);
                    Match("new");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("NEW", 21);
                LeaveRule("NEW", 21);
                LeaveRule_NEW();
            }
        }
        // $ANTLR end "NEW"

        partial void EnterRule_OF();
        partial void LeaveRule_OF();

        // $ANTLR start "OF"
        [GrammarRule("OF")]
        private void mOF()
        {
            EnterRule_OF();
            EnterRule("OF", 22);
            TraceIn("OF", 22);
            try
            {
                int _type = OF;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:87:13: ( 'of' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:87:17: 'of'
                {
                    DebugLocation(87, 17);
                    Match("of");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("OF", 22);
                LeaveRule("OF", 22);
                LeaveRule_OF();
            }
        }
        // $ANTLR end "OF"

        partial void EnterRule_NOT();
        partial void LeaveRule_NOT();

        // $ANTLR start "NOT"
        [GrammarRule("NOT")]
        private void mNOT()
        {
            EnterRule_NOT();
            EnterRule("NOT", 23);
            TraceIn("NOT", 23);
            try
            {
                int _type = NOT;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:88:10: ( 'not' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:88:12: 'not'
                {
                    DebugLocation(88, 12);
                    Match("not");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("NOT", 23);
                LeaveRule("NOT", 23);
                LeaveRule_NOT();
            }
        }
        // $ANTLR end "NOT"

        partial void EnterRule_TRUE();
        partial void LeaveRule_TRUE();

        // $ANTLR start "TRUE"
        [GrammarRule("TRUE")]
        private void mTRUE()
        {
            EnterRule_TRUE();
            EnterRule("TRUE", 24);
            TraceIn("TRUE", 24);
            try
            {
                int _type = TRUE;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:89:11: ( 'true' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:89:13: 'true'
                {
                    DebugLocation(89, 13);
                    Match("true");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("TRUE", 24);
                LeaveRule("TRUE", 24);
                LeaveRule_TRUE();
            }
        }
        // $ANTLR end "TRUE"

        partial void EnterRule_SELF();
        partial void LeaveRule_SELF();

        // $ANTLR start "SELF"
        [GrammarRule("SELF")]
        private void mSELF()
        {
            EnterRule_SELF();
            EnterRule("SELF", 25);
            TraceIn("SELF", 25);
            try
            {
                int _type = SELF;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:90:11: ( 'self' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:90:13: 'self'
                {
                    DebugLocation(90, 13);
                    Match("self");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("SELF", 25);
                LeaveRule("SELF", 25);
                LeaveRule_SELF();
            }
        }
        // $ANTLR end "SELF"

        partial void EnterRule_BREAK();
        partial void LeaveRule_BREAK();

        // $ANTLR start "BREAK"
        [GrammarRule("BREAK")]
        private void mBREAK()
        {
            EnterRule_BREAK();
            EnterRule("BREAK", 26);
            TraceIn("BREAK", 26);
            try
            {
                int _type = BREAK;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:91:11: ( 'break' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:91:13: 'break'
                {
                    DebugLocation(91, 13);
                    Match("break");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("BREAK", 26);
                LeaveRule("BREAK", 26);
                LeaveRule_BREAK();
            }
        }
        // $ANTLR end "BREAK"

        partial void EnterRule_STRING();
        partial void LeaveRule_STRING();

        // $ANTLR start "STRING"
        [GrammarRule("STRING")]
        private void mSTRING()
        {
            EnterRule_STRING();
            EnterRule("STRING", 27);
            TraceIn("STRING", 27);
            try
            {
                int _type = STRING;
                int _channel = DefaultTokenChannel;
                int c = 0;

                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:92:12: ( '\"' ( '\"' '\"' |c=~ ( '\"' | '\\r' | '\\n' ) )* '\"' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:92:14: '\"' ( '\"' '\"' |c=~ ( '\"' | '\\r' | '\\n' ) )* '\"'
                {
                    DebugLocation(92, 14);
                    Match('\"');
                    DebugLocation(93, 3);
                    StringBuilder b = new StringBuilder();
                    DebugLocation(94, 3);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:94:3: ( '\"' '\"' |c=~ ( '\"' | '\\r' | '\\n' ) )*
                    try
                    {
                        DebugEnterSubRule(1);
                        while (true)
                        {
                            int alt1 = 3;
                            try
                            {
                                DebugEnterDecision(1, false);
                                int LA1_1 = input.LA(1);

                                if ((LA1_1 == '\"'))
                                {
                                    int LA1_2 = input.LA(2);

                                    if ((LA1_2 == '\"'))
                                    {
                                        alt1 = 1;
                                    }


                                }
                                else if (((LA1_1 >= '\u0000' && LA1_1 <= '\t') || (LA1_1 >= '\u000B' && LA1_1 <= '\f') || (LA1_1 >= '\u000E' && LA1_1 <= '!') || (LA1_1 >= '#' && LA1_1 <= '\uFFFF')))
                                {
                                    alt1 = 2;
                                }


                            }
                            finally { DebugExitDecision(1); }
                            switch (alt1)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:94:5: '\"' '\"'
                                    {
                                        DebugLocation(94, 5);
                                        Match('\"');
                                        DebugLocation(94, 9);
                                        Match('\"');
                                        DebugLocation(94, 13);
                                        b.Append('"');

                                    }
                                    break;
                                case 2:
                                    DebugEnterAlt(2);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:95:5: c=~ ( '\"' | '\\r' | '\\n' )
                                    {
                                        DebugLocation(95, 6);
                                        c = input.LA(1);
                                        input.Consume();

                                        DebugLocation(95, 24);
                                        b.Append((char)c);

                                    }
                                    break;

                                default:
                                    goto loop1;
                            }
                        }

                    loop1:
                        ;

                    }
                    finally { DebugExitSubRule(1); }

                    DebugLocation(97, 3);
                    Match('\"');
                    DebugLocation(98, 3);
                    Text = b.ToString();

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("STRING", 27);
                LeaveRule("STRING", 27);
                LeaveRule_STRING();
            }
        }
        // $ANTLR end "STRING"

        partial void EnterRule_INTEGER();
        partial void LeaveRule_INTEGER();

        // $ANTLR start "INTEGER"
        [GrammarRule("INTEGER")]
        private void mINTEGER()
        {
            EnterRule_INTEGER();
            EnterRule("INTEGER", 28);
            TraceIn("INTEGER", 28);
            try
            {
                int _type = INTEGER;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:100:9: ( ( DIGIT )+ )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:100:12: ( DIGIT )+
                {
                    DebugLocation(100, 12);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:100:12: ( DIGIT )+
                    int cnt2 = 0;
                    try
                    {
                        DebugEnterSubRule(2);
                        while (true)
                        {
                            int alt2 = 2;
                            try
                            {
                                DebugEnterDecision(2, false);
                                int LA2_1 = input.LA(1);

                                if (((LA2_1 >= '0' && LA2_1 <= '9')))
                                {
                                    alt2 = 1;
                                }


                            }
                            finally { DebugExitDecision(2); }
                            switch (alt2)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:
                                    {
                                        DebugLocation(100, 12);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt2 >= 1)
                                        goto loop2;

                                    EarlyExitException eee2 = new EarlyExitException(2, input);
                                    DebugRecognitionException(eee2);
                                    throw eee2;
                            }
                            cnt2++;
                        }
                    loop2:
                        ;

                    }
                    finally { DebugExitSubRule(2); }


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("INTEGER", 28);
                LeaveRule("INTEGER", 28);
                LeaveRule_INTEGER();
            }
        }
        // $ANTLR end "INTEGER"

        partial void EnterRule_DOT();
        partial void LeaveRule_DOT();

        // $ANTLR start "DOT"
        [GrammarRule("DOT")]
        private void mDOT()
        {
            EnterRule_DOT();
            EnterRule("DOT", 29);
            TraceIn("DOT", 29);
            try
            {
                int _type = DOT;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:104:9: ( '.' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:104:11: '.'
                {
                    DebugLocation(104, 11);
                    Match('.');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("DOT", 29);
                LeaveRule("DOT", 29);
                LeaveRule_DOT();
            }
        }
        // $ANTLR end "DOT"

        partial void EnterRule_ATSIGN();
        partial void LeaveRule_ATSIGN();

        // $ANTLR start "ATSIGN"
        [GrammarRule("ATSIGN")]
        private void mATSIGN()
        {
            EnterRule_ATSIGN();
            EnterRule("ATSIGN", 30);
            TraceIn("ATSIGN", 30);
            try
            {
                int _type = ATSIGN;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:105:8: ( '@' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:105:10: '@'
                {
                    DebugLocation(105, 10);
                    Match('@');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("ATSIGN", 30);
                LeaveRule("ATSIGN", 30);
                LeaveRule_ATSIGN();
            }
        }
        // $ANTLR end "ATSIGN"

        partial void EnterRule_OR();
        partial void LeaveRule_OR();

        // $ANTLR start "OR"
        [GrammarRule("OR")]
        private void mOR()
        {
            EnterRule_OR();
            EnterRule("OR", 31);
            TraceIn("OR", 31);
            try
            {
                int _type = OR;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:106:8: ( '|' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:106:10: '|'
                {
                    DebugLocation(106, 10);
                    Match('|');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("OR", 31);
                LeaveRule("OR", 31);
                LeaveRule_OR();
            }
        }
        // $ANTLR end "OR"

        partial void EnterRule_AND();
        partial void LeaveRule_AND();

        // $ANTLR start "AND"
        [GrammarRule("AND")]
        private void mAND()
        {
            EnterRule_AND();
            EnterRule("AND", 32);
            TraceIn("AND", 32);
            try
            {
                int _type = AND;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:107:9: ( '&' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:107:11: '&'
                {
                    DebugLocation(107, 11);
                    Match('&');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("AND", 32);
                LeaveRule("AND", 32);
                LeaveRule_AND();
            }
        }
        // $ANTLR end "AND"

        partial void EnterRule_NEG();
        partial void LeaveRule_NEG();

        // $ANTLR start "NEG"
        [GrammarRule("NEG")]
        private void mNEG()
        {
            EnterRule_NEG();
            EnterRule("NEG", 33);
            TraceIn("NEG", 33);
            try
            {
                int _type = NEG;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:108:9: ( '~' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:108:13: '~'
                {
                    DebugLocation(108, 13);
                    Match('~');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("NEG", 33);
                LeaveRule("NEG", 33);
                LeaveRule_NEG();
            }
        }
        // $ANTLR end "NEG"

        partial void EnterRule_MULT();
        partial void LeaveRule_MULT();

        // $ANTLR start "MULT"
        [GrammarRule("MULT")]
        private void mMULT()
        {
            EnterRule_MULT();
            EnterRule("MULT", 34);
            TraceIn("MULT", 34);
            try
            {
                int _type = MULT;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:109:6: ( '*' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:109:8: '*'
                {
                    DebugLocation(109, 8);
                    Match('*');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("MULT", 34);
                LeaveRule("MULT", 34);
                LeaveRule_MULT();
            }
        }
        // $ANTLR end "MULT"

        partial void EnterRule_DIV();
        partial void LeaveRule_DIV();

        // $ANTLR start "DIV"
        [GrammarRule("DIV")]
        private void mDIV()
        {
            EnterRule_DIV();
            EnterRule("DIV", 35);
            TraceIn("DIV", 35);
            try
            {
                int _type = DIV;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:110:9: ( '/' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:110:11: '/'
                {
                    DebugLocation(110, 11);
                    Match('/');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("DIV", 35);
                LeaveRule("DIV", 35);
                LeaveRule_DIV();
            }
        }
        // $ANTLR end "DIV"

        partial void EnterRule_PLUS();
        partial void LeaveRule_PLUS();

        // $ANTLR start "PLUS"
        [GrammarRule("PLUS")]
        private void mPLUS()
        {
            EnterRule_PLUS();
            EnterRule("PLUS", 36);
            TraceIn("PLUS", 36);
            try
            {
                int _type = PLUS;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:111:6: ( '+' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:111:8: '+'
                {
                    DebugLocation(111, 8);
                    Match('+');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("PLUS", 36);
                LeaveRule("PLUS", 36);
                LeaveRule_PLUS();
            }
        }
        // $ANTLR end "PLUS"

        partial void EnterRule_MINUS();
        partial void LeaveRule_MINUS();

        // $ANTLR start "MINUS"
        [GrammarRule("MINUS")]
        private void mMINUS()
        {
            EnterRule_MINUS();
            EnterRule("MINUS", 37);
            TraceIn("MINUS", 37);
            try
            {
                int _type = MINUS;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:112:7: ( '-' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:112:9: '-'
                {
                    DebugLocation(112, 9);
                    Match('-');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("MINUS", 37);
                LeaveRule("MINUS", 37);
                LeaveRule_MINUS();
            }
        }
        // $ANTLR end "MINUS"

        partial void EnterRule_LE();
        partial void LeaveRule_LE();

        // $ANTLR start "LE"
        [GrammarRule("LE")]
        private void mLE()
        {
            EnterRule_LE();
            EnterRule("LE", 38);
            TraceIn("LE", 38);
            try
            {
                int _type = LE;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:113:8: ( '<=' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:113:10: '<='
                {
                    DebugLocation(113, 10);
                    Match("<=");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("LE", 38);
                LeaveRule("LE", 38);
                LeaveRule_LE();
            }
        }
        // $ANTLR end "LE"

        partial void EnterRule_LT();
        partial void LeaveRule_LT();

        // $ANTLR start "LT"
        [GrammarRule("LT")]
        private void mLT()
        {
            EnterRule_LT();
            EnterRule("LT", 39);
            TraceIn("LT", 39);
            try
            {
                int _type = LT;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:114:8: ( '<' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:114:10: '<'
                {
                    DebugLocation(114, 10);
                    Match('<');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("LT", 39);
                LeaveRule("LT", 39);
                LeaveRule_LT();
            }
        }
        // $ANTLR end "LT"

        partial void EnterRule_GE();
        partial void LeaveRule_GE();

        // $ANTLR start "GE"
        [GrammarRule("GE")]
        private void mGE()
        {
            EnterRule_GE();
            EnterRule("GE", 40);
            TraceIn("GE", 40);
            try
            {
                int _type = GE;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:115:8: ( '>=' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:115:10: '>='
                {
                    DebugLocation(115, 10);
                    Match(">=");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("GE", 40);
                LeaveRule("GE", 40);
                LeaveRule_GE();
            }
        }
        // $ANTLR end "GE"

        partial void EnterRule_GT();
        partial void LeaveRule_GT();

        // $ANTLR start "GT"
        [GrammarRule("GT")]
        private void mGT()
        {
            EnterRule_GT();
            EnterRule("GT", 41);
            TraceIn("GT", 41);
            try
            {
                int _type = GT;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:116:8: ( '>' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:116:10: '>'
                {
                    DebugLocation(116, 10);
                    Match('>');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("GT", 41);
                LeaveRule("GT", 41);
                LeaveRule_GT();
            }
        }
        // $ANTLR end "GT"

        partial void EnterRule_EQUAL();
        partial void LeaveRule_EQUAL();

        // $ANTLR start "EQUAL"
        [GrammarRule("EQUAL")]
        private void mEQUAL()
        {
            EnterRule_EQUAL();
            EnterRule("EQUAL", 42);
            TraceIn("EQUAL", 42);
            try
            {
                int _type = EQUAL;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:117:7: ( '=' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:117:9: '='
                {
                    DebugLocation(117, 9);
                    Match('=');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("EQUAL", 42);
                LeaveRule("EQUAL", 42);
                LeaveRule_EQUAL();
            }
        }
        // $ANTLR end "EQUAL"

        partial void EnterRule_ASSIGN();
        partial void LeaveRule_ASSIGN();

        // $ANTLR start "ASSIGN"
        [GrammarRule("ASSIGN")]
        private void mASSIGN()
        {
            EnterRule_ASSIGN();
            EnterRule("ASSIGN", 43);
            TraceIn("ASSIGN", 43);
            try
            {
                int _type = ASSIGN;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:118:8: ( '<-' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:118:10: '<-'
                {
                    DebugLocation(118, 10);
                    Match("<-");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("ASSIGN", 43);
                LeaveRule("ASSIGN", 43);
                LeaveRule_ASSIGN();
            }
        }
        // $ANTLR end "ASSIGN"

        partial void EnterRule_SEMI();
        partial void LeaveRule_SEMI();

        // $ANTLR start "SEMI"
        [GrammarRule("SEMI")]
        private void mSEMI()
        {
            EnterRule_SEMI();
            EnterRule("SEMI", 44);
            TraceIn("SEMI", 44);
            try
            {
                int _type = SEMI;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:119:6: ( ';' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:119:8: ';'
                {
                    DebugLocation(119, 8);
                    Match(';');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("SEMI", 44);
                LeaveRule("SEMI", 44);
                LeaveRule_SEMI();
            }
        }
        // $ANTLR end "SEMI"

        partial void EnterRule_LPAREN();
        partial void LeaveRule_LPAREN();

        // $ANTLR start "LPAREN"
        [GrammarRule("LPAREN")]
        private void mLPAREN()
        {
            EnterRule_LPAREN();
            EnterRule("LPAREN", 45);
            TraceIn("LPAREN", 45);
            try
            {
                int _type = LPAREN;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:120:8: ( '(' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:120:10: '('
                {
                    DebugLocation(120, 10);
                    Match('(');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("LPAREN", 45);
                LeaveRule("LPAREN", 45);
                LeaveRule_LPAREN();
            }
        }
        // $ANTLR end "LPAREN"

        partial void EnterRule_RPAREN();
        partial void LeaveRule_RPAREN();

        // $ANTLR start "RPAREN"
        [GrammarRule("RPAREN")]
        private void mRPAREN()
        {
            EnterRule_RPAREN();
            EnterRule("RPAREN", 46);
            TraceIn("RPAREN", 46);
            try
            {
                int _type = RPAREN;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:121:8: ( ')' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:121:10: ')'
                {
                    DebugLocation(121, 10);
                    Match(')');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("RPAREN", 46);
                LeaveRule("RPAREN", 46);
                LeaveRule_RPAREN();
            }
        }
        // $ANTLR end "RPAREN"

        partial void EnterRule_LKEY();
        partial void LeaveRule_LKEY();

        // $ANTLR start "LKEY"
        [GrammarRule("LKEY")]
        private void mLKEY()
        {
            EnterRule_LKEY();
            EnterRule("LKEY", 47);
            TraceIn("LKEY", 47);
            try
            {
                int _type = LKEY;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:122:6: ( '{' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:122:8: '{'
                {
                    DebugLocation(122, 8);
                    Match('{');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("LKEY", 47);
                LeaveRule("LKEY", 47);
                LeaveRule_LKEY();
            }
        }
        // $ANTLR end "LKEY"

        partial void EnterRule_RKEY();
        partial void LeaveRule_RKEY();

        // $ANTLR start "RKEY"
        [GrammarRule("RKEY")]
        private void mRKEY()
        {
            EnterRule_RKEY();
            EnterRule("RKEY", 48);
            TraceIn("RKEY", 48);
            try
            {
                int _type = RKEY;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:123:6: ( '}' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:123:8: '}'
                {
                    DebugLocation(123, 8);
                    Match('}');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("RKEY", 48);
                LeaveRule("RKEY", 48);
                LeaveRule_RKEY();
            }
        }
        // $ANTLR end "RKEY"

        partial void EnterRule_COMMA();
        partial void LeaveRule_COMMA();

        // $ANTLR start "COMMA"
        [GrammarRule("COMMA")]
        private void mCOMMA()
        {
            EnterRule_COMMA();
            EnterRule("COMMA", 49);
            TraceIn("COMMA", 49);
            try
            {
                int _type = COMMA;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:124:7: ( ',' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:124:9: ','
                {
                    DebugLocation(124, 9);
                    Match(',');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("COMMA", 49);
                LeaveRule("COMMA", 49);
                LeaveRule_COMMA();
            }
        }
        // $ANTLR end "COMMA"

        partial void EnterRule_COLON();
        partial void LeaveRule_COLON();

        // $ANTLR start "COLON"
        [GrammarRule("COLON")]
        private void mCOLON()
        {
            EnterRule_COLON();
            EnterRule("COLON", 50);
            TraceIn("COLON", 50);
            try
            {
                int _type = COLON;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:125:7: ( ':' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:125:9: ':'
                {
                    DebugLocation(125, 9);
                    Match(':');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("COLON", 50);
                LeaveRule("COLON", 50);
                LeaveRule_COLON();
            }
        }
        // $ANTLR end "COLON"

        partial void EnterRule_HENCE();
        partial void LeaveRule_HENCE();

        // $ANTLR start "HENCE"
        [GrammarRule("HENCE")]
        private void mHENCE()
        {
            EnterRule_HENCE();
            EnterRule("HENCE", 51);
            TraceIn("HENCE", 51);
            try
            {
                int _type = HENCE;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:126:7: ( '=>' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:126:9: '=>'
                {
                    DebugLocation(126, 9);
                    Match("=>");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("HENCE", 51);
                LeaveRule("HENCE", 51);
                LeaveRule_HENCE();
            }
        }
        // $ANTLR end "HENCE"

        partial void EnterRule_MULTILINE_COMMENT();
        partial void LeaveRule_MULTILINE_COMMENT();

        // $ANTLR start "MULTILINE_COMMENT"
        [GrammarRule("MULTILINE_COMMENT")]
        private void mMULTILINE_COMMENT()
        {
            EnterRule_MULTILINE_COMMENT();
            EnterRule("MULTILINE_COMMENT", 52);
            TraceIn("MULTILINE_COMMENT", 52);
            try
            {
                int _type = MULTILINE_COMMENT;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:128:19: ( '(*' ( . )* '*)' )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:128:21: '(*' ( . )* '*)'
                {
                    DebugLocation(128, 21);
                    Match("(*");

                    DebugLocation(128, 26);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:128:26: ( . )*
                    try
                    {
                        DebugEnterSubRule(3);
                        while (true)
                        {
                            int alt3 = 2;
                            try
                            {
                                DebugEnterDecision(3, false);
                                int LA3_1 = input.LA(1);

                                if ((LA3_1 == '*'))
                                {
                                    int LA3_2 = input.LA(2);

                                    if ((LA3_2 == ')'))
                                    {
                                        alt3 = 2;
                                    }
                                    else if (((LA3_2 >= '\u0000' && LA3_2 <= '(') || (LA3_2 >= '*' && LA3_2 <= '\uFFFF')))
                                    {
                                        alt3 = 1;
                                    }


                                }
                                else if (((LA3_1 >= '\u0000' && LA3_1 <= ')') || (LA3_1 >= '+' && LA3_1 <= '\uFFFF')))
                                {
                                    alt3 = 1;
                                }


                            }
                            finally { DebugExitDecision(3); }
                            switch (alt3)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:128:26: .
                                    {
                                        DebugLocation(128, 26);
                                        MatchAny();

                                    }
                                    break;

                                default:
                                    goto loop3;
                            }
                        }

                    loop3:
                        ;

                    }
                    finally { DebugExitSubRule(3); }

                    DebugLocation(128, 29);
                    Match("*)");

                    DebugLocation(128, 34);
                    _channel = Hidden;

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("MULTILINE_COMMENT", 52);
                LeaveRule("MULTILINE_COMMENT", 52);
                LeaveRule_MULTILINE_COMMENT();
            }
        }
        // $ANTLR end "MULTILINE_COMMENT"

        partial void EnterRule_COMMENT();
        partial void LeaveRule_COMMENT();

        // $ANTLR start "COMMENT"
        [GrammarRule("COMMENT")]
        private void mCOMMENT()
        {
            EnterRule_COMMENT();
            EnterRule("COMMENT", 53);
            TraceIn("COMMENT", 53);
            try
            {
                int _type = COMMENT;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:129:9: ( '--' ( . )* ( '\\n' | '\\r' ) )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:129:11: '--' ( . )* ( '\\n' | '\\r' )
                {
                    DebugLocation(129, 11);
                    Match("--");

                    DebugLocation(129, 16);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:129:16: ( . )*
                    try
                    {
                        DebugEnterSubRule(4);
                        while (true)
                        {
                            int alt4 = 2;
                            try
                            {
                                DebugEnterDecision(4, false);
                                int LA4_1 = input.LA(1);

                                if ((LA4_1 == '\n' || LA4_1 == '\r'))
                                {
                                    alt4 = 2;
                                }
                                else if (((LA4_1 >= '\u0000' && LA4_1 <= '\t') || (LA4_1 >= '\u000B' && LA4_1 <= '\f') || (LA4_1 >= '\u000E' && LA4_1 <= '\uFFFF')))
                                {
                                    alt4 = 1;
                                }


                            }
                            finally { DebugExitDecision(4); }
                            switch (alt4)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:129:16: .
                                    {
                                        DebugLocation(129, 16);
                                        MatchAny();

                                    }
                                    break;

                                default:
                                    goto loop4;
                            }
                        }

                    loop4:
                        ;

                    }
                    finally { DebugExitSubRule(4); }

                    DebugLocation(129, 19);
                    if (input.LA(1) == '\n' || input.LA(1) == '\r')
                    {
                        input.Consume();
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        Recover(mse);
                        throw mse;
                    }

                    DebugLocation(129, 31);
                    _channel = Hidden;

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("COMMENT", 53);
                LeaveRule("COMMENT", 53);
                LeaveRule_COMMENT();
            }
        }
        // $ANTLR end "COMMENT"

        partial void EnterRule_TYPE_ID();
        partial void LeaveRule_TYPE_ID();

        // $ANTLR start "TYPE_ID"
        [GrammarRule("TYPE_ID")]
        private void mTYPE_ID()
        {
            EnterRule_TYPE_ID();
            EnterRule("TYPE_ID", 54);
            TraceIn("TYPE_ID", 54);
            try
            {
                int _type = TYPE_ID;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:131:9: ( ( CAPITAL_LETTER ) ( ( CAPITAL_LETTER | LOWER_LETTER ) | DIGIT | '_' )* )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:131:11: ( CAPITAL_LETTER ) ( ( CAPITAL_LETTER | LOWER_LETTER ) | DIGIT | '_' )*
                {
                    DebugLocation(131, 11);
                    if ((input.LA(1) >= 'A' && input.LA(1) <= 'Z'))
                    {
                        input.Consume();
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        Recover(mse);
                        throw mse;
                    }

                    DebugLocation(131, 27);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:131:27: ( ( CAPITAL_LETTER | LOWER_LETTER ) | DIGIT | '_' )*
                    try
                    {
                        DebugEnterSubRule(5);
                        while (true)
                        {
                            int alt5 = 2;
                            try
                            {
                                DebugEnterDecision(5, false);
                                int LA5_1 = input.LA(1);

                                if (((LA5_1 >= '0' && LA5_1 <= '9') || (LA5_1 >= 'A' && LA5_1 <= 'Z') || LA5_1 == '_' || (LA5_1 >= 'a' && LA5_1 <= 'z')))
                                {
                                    alt5 = 1;
                                }


                            }
                            finally { DebugExitDecision(5); }
                            switch (alt5)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:
                                    {
                                        DebugLocation(131, 27);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    goto loop5;
                            }
                        }

                    loop5:
                        ;

                    }
                    finally { DebugExitSubRule(5); }


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("TYPE_ID", 54);
                LeaveRule("TYPE_ID", 54);
                LeaveRule_TYPE_ID();
            }
        }
        // $ANTLR end "TYPE_ID"

        partial void EnterRule_OBJ_ID();
        partial void LeaveRule_OBJ_ID();

        // $ANTLR start "OBJ_ID"
        [GrammarRule("OBJ_ID")]
        private void mOBJ_ID()
        {
            EnterRule_OBJ_ID();
            EnterRule("OBJ_ID", 55);
            TraceIn("OBJ_ID", 55);
            try
            {
                int _type = OBJ_ID;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:133:8: ( ( LOWER_LETTER ) ( ( CAPITAL_LETTER | LOWER_LETTER ) | DIGIT | '_' )* )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:133:10: ( LOWER_LETTER ) ( ( CAPITAL_LETTER | LOWER_LETTER ) | DIGIT | '_' )*
                {
                    DebugLocation(133, 10);
                    if ((input.LA(1) >= 'a' && input.LA(1) <= 'z'))
                    {
                        input.Consume();
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        Recover(mse);
                        throw mse;
                    }

                    DebugLocation(133, 24);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:133:24: ( ( CAPITAL_LETTER | LOWER_LETTER ) | DIGIT | '_' )*
                    try
                    {
                        DebugEnterSubRule(6);
                        while (true)
                        {
                            int alt6 = 2;
                            try
                            {
                                DebugEnterDecision(6, false);
                                int LA6_1 = input.LA(1);

                                if (((LA6_1 >= '0' && LA6_1 <= '9') || (LA6_1 >= 'A' && LA6_1 <= 'Z') || LA6_1 == '_' || (LA6_1 >= 'a' && LA6_1 <= 'z')))
                                {
                                    alt6 = 1;
                                }


                            }
                            finally { DebugExitDecision(6); }
                            switch (alt6)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:
                                    {
                                        DebugLocation(133, 24);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    goto loop6;
                            }
                        }

                    loop6:
                        ;

                    }
                    finally { DebugExitSubRule(6); }


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("OBJ_ID", 55);
                LeaveRule("OBJ_ID", 55);
                LeaveRule_OBJ_ID();
            }
        }
        // $ANTLR end "OBJ_ID"

        partial void EnterRule_WS();
        partial void LeaveRule_WS();

        // $ANTLR start "WS"
        [GrammarRule("WS")]
        private void mWS()
        {
            EnterRule_WS();
            EnterRule("WS", 56);
            TraceIn("WS", 56);
            try
            {
                int _type = WS;
                int _channel = DefaultTokenChannel;
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:135:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
                DebugEnterAlt(1);
                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:135:9: ( ' ' | '\\t' | '\\r' | '\\n' )
                {
                    DebugLocation(135, 9);
                    if ((input.LA(1) >= '\t' && input.LA(1) <= '\n') || input.LA(1) == '\r' || input.LA(1) == ' ')
                    {
                        input.Consume();
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        Recover(mse);
                        throw mse;
                    }

                    DebugLocation(135, 30);
                    _channel = Hidden;

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("WS", 56);
                LeaveRule("WS", 56);
                LeaveRule_WS();
            }
        }
        // $ANTLR end "WS"

        public override void mTokens()
        {
            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:8: ( CLASS | ELSE | FALSE | FI | IF | IN | INHERITS | ISVOID | LET | LOOP | POOL | THEN | WHILE | DO | OD | CASE | ESAC | NEW | OF | NOT | TRUE | SELF | BREAK | STRING | INTEGER | DOT | ATSIGN | OR | AND | NEG | MULT | DIV | PLUS | MINUS | LE | LT | GE | GT | EQUAL | ASSIGN | SEMI | LPAREN | RPAREN | LKEY | RKEY | COMMA | COLON | HENCE | MULTILINE_COMMENT | COMMENT | TYPE_ID | OBJ_ID | WS )
            int alt7 = 53;
            try
            {
                DebugEnterDecision(7, false);
                try
                {
                    alt7 = dfa7.Predict(input);
                }
                catch (NoViableAltException nvae)
                {
                    DebugRecognitionException(nvae);
                    throw;
                }
            }
            finally { DebugExitDecision(7); }
            switch (alt7)
            {
                case 1:
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:10: CLASS
                    {
                        DebugLocation(1, 10);
                        mCLASS();

                    }
                    break;
                case 2:
                    DebugEnterAlt(2);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:16: ELSE
                    {
                        DebugLocation(1, 16);
                        mELSE();

                    }
                    break;
                case 3:
                    DebugEnterAlt(3);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:21: FALSE
                    {
                        DebugLocation(1, 21);
                        mFALSE();

                    }
                    break;
                case 4:
                    DebugEnterAlt(4);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:27: FI
                    {
                        DebugLocation(1, 27);
                        mFI();

                    }
                    break;
                case 5:
                    DebugEnterAlt(5);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:30: IF
                    {
                        DebugLocation(1, 30);
                        mIF();

                    }
                    break;
                case 6:
                    DebugEnterAlt(6);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:33: IN
                    {
                        DebugLocation(1, 33);
                        mIN();

                    }
                    break;
                case 7:
                    DebugEnterAlt(7);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:36: INHERITS
                    {
                        DebugLocation(1, 36);
                        mINHERITS();

                    }
                    break;
                case 8:
                    DebugEnterAlt(8);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:45: ISVOID
                    {
                        DebugLocation(1, 45);
                        mISVOID();

                    }
                    break;
                case 9:
                    DebugEnterAlt(9);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:52: LET
                    {
                        DebugLocation(1, 52);
                        mLET();

                    }
                    break;
                case 10:
                    DebugEnterAlt(10);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:56: LOOP
                    {
                        DebugLocation(1, 56);
                        mLOOP();

                    }
                    break;
                case 11:
                    DebugEnterAlt(11);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:61: POOL
                    {
                        DebugLocation(1, 61);
                        mPOOL();

                    }
                    break;
                case 12:
                    DebugEnterAlt(12);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:66: THEN
                    {
                        DebugLocation(1, 66);
                        mTHEN();

                    }
                    break;
                case 13:
                    DebugEnterAlt(13);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:71: WHILE
                    {
                        DebugLocation(1, 71);
                        mWHILE();

                    }
                    break;
                case 14:
                    DebugEnterAlt(14);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:77: DO
                    {
                        DebugLocation(1, 77);
                        mDO();

                    }
                    break;
                case 15:
                    DebugEnterAlt(15);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:80: OD
                    {
                        DebugLocation(1, 80);
                        mOD();

                    }
                    break;
                case 16:
                    DebugEnterAlt(16);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:83: CASE
                    {
                        DebugLocation(1, 83);
                        mCASE();

                    }
                    break;
                case 17:
                    DebugEnterAlt(17);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:88: ESAC
                    {
                        DebugLocation(1, 88);
                        mESAC();

                    }
                    break;
                case 18:
                    DebugEnterAlt(18);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:93: NEW
                    {
                        DebugLocation(1, 93);
                        mNEW();

                    }
                    break;
                case 19:
                    DebugEnterAlt(19);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:97: OF
                    {
                        DebugLocation(1, 97);
                        mOF();

                    }
                    break;
                case 20:
                    DebugEnterAlt(20);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:100: NOT
                    {
                        DebugLocation(1, 100);
                        mNOT();

                    }
                    break;
                case 21:
                    DebugEnterAlt(21);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:104: TRUE
                    {
                        DebugLocation(1, 104);
                        mTRUE();

                    }
                    break;
                case 22:
                    DebugEnterAlt(22);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:109: SELF
                    {
                        DebugLocation(1, 109);
                        mSELF();

                    }
                    break;
                case 23:
                    DebugEnterAlt(23);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:114: BREAK
                    {
                        DebugLocation(1, 114);
                        mBREAK();

                    }
                    break;
                case 24:
                    DebugEnterAlt(24);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:120: STRING
                    {
                        DebugLocation(1, 120);
                        mSTRING();

                    }
                    break;
                case 25:
                    DebugEnterAlt(25);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:127: INTEGER
                    {
                        DebugLocation(1, 127);
                        mINTEGER();

                    }
                    break;
                case 26:
                    DebugEnterAlt(26);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:135: DOT
                    {
                        DebugLocation(1, 135);
                        mDOT();

                    }
                    break;
                case 27:
                    DebugEnterAlt(27);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:139: ATSIGN
                    {
                        DebugLocation(1, 139);
                        mATSIGN();

                    }
                    break;
                case 28:
                    DebugEnterAlt(28);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:146: OR
                    {
                        DebugLocation(1, 146);
                        mOR();

                    }
                    break;
                case 29:
                    DebugEnterAlt(29);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:149: AND
                    {
                        DebugLocation(1, 149);
                        mAND();

                    }
                    break;
                case 30:
                    DebugEnterAlt(30);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:153: NEG
                    {
                        DebugLocation(1, 153);
                        mNEG();

                    }
                    break;
                case 31:
                    DebugEnterAlt(31);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:157: MULT
                    {
                        DebugLocation(1, 157);
                        mMULT();

                    }
                    break;
                case 32:
                    DebugEnterAlt(32);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:162: DIV
                    {
                        DebugLocation(1, 162);
                        mDIV();

                    }
                    break;
                case 33:
                    DebugEnterAlt(33);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:166: PLUS
                    {
                        DebugLocation(1, 166);
                        mPLUS();

                    }
                    break;
                case 34:
                    DebugEnterAlt(34);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:171: MINUS
                    {
                        DebugLocation(1, 171);
                        mMINUS();

                    }
                    break;
                case 35:
                    DebugEnterAlt(35);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:177: LE
                    {
                        DebugLocation(1, 177);
                        mLE();

                    }
                    break;
                case 36:
                    DebugEnterAlt(36);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:180: LT
                    {
                        DebugLocation(1, 180);
                        mLT();

                    }
                    break;
                case 37:
                    DebugEnterAlt(37);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:183: GE
                    {
                        DebugLocation(1, 183);
                        mGE();

                    }
                    break;
                case 38:
                    DebugEnterAlt(38);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:186: GT
                    {
                        DebugLocation(1, 186);
                        mGT();

                    }
                    break;
                case 39:
                    DebugEnterAlt(39);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:189: EQUAL
                    {
                        DebugLocation(1, 189);
                        mEQUAL();

                    }
                    break;
                case 40:
                    DebugEnterAlt(40);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:195: ASSIGN
                    {
                        DebugLocation(1, 195);
                        mASSIGN();

                    }
                    break;
                case 41:
                    DebugEnterAlt(41);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:202: SEMI
                    {
                        DebugLocation(1, 202);
                        mSEMI();

                    }
                    break;
                case 42:
                    DebugEnterAlt(42);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:207: LPAREN
                    {
                        DebugLocation(1, 207);
                        mLPAREN();

                    }
                    break;
                case 43:
                    DebugEnterAlt(43);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:214: RPAREN
                    {
                        DebugLocation(1, 214);
                        mRPAREN();

                    }
                    break;
                case 44:
                    DebugEnterAlt(44);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:221: LKEY
                    {
                        DebugLocation(1, 221);
                        mLKEY();

                    }
                    break;
                case 45:
                    DebugEnterAlt(45);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:226: RKEY
                    {
                        DebugLocation(1, 226);
                        mRKEY();

                    }
                    break;
                case 46:
                    DebugEnterAlt(46);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:231: COMMA
                    {
                        DebugLocation(1, 231);
                        mCOMMA();

                    }
                    break;
                case 47:
                    DebugEnterAlt(47);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:237: COLON
                    {
                        DebugLocation(1, 237);
                        mCOLON();

                    }
                    break;
                case 48:
                    DebugEnterAlt(48);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:243: HENCE
                    {
                        DebugLocation(1, 243);
                        mHENCE();

                    }
                    break;
                case 49:
                    DebugEnterAlt(49);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:249: MULTILINE_COMMENT
                    {
                        DebugLocation(1, 249);
                        mMULTILINE_COMMENT();

                    }
                    break;
                case 50:
                    DebugEnterAlt(50);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:267: COMMENT
                    {
                        DebugLocation(1, 267);
                        mCOMMENT();

                    }
                    break;
                case 51:
                    DebugEnterAlt(51);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:275: TYPE_ID
                    {
                        DebugLocation(1, 275);
                        mTYPE_ID();

                    }
                    break;
                case 52:
                    DebugEnterAlt(52);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:283: OBJ_ID
                    {
                        DebugLocation(1, 283);
                        mOBJ_ID();

                    }
                    break;
                case 53:
                    DebugEnterAlt(53);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:1:290: WS
                    {
                        DebugLocation(1, 290);
                        mWS();

                    }
                    break;

            }

        }


        #region DFA
        DFA7 dfa7;

        protected override void InitDFAs()
        {
            base.InitDFAs();
            dfa7 = new DFA7(this);
        }

        private class DFA7 : DFA
        {
            private const string DFA7_eotS =
                "\x1\xFFFF\xD\x24\xA\xFFFF\x1\x3D\x1\x40\x1\x42\x1\x44\x1\xFFFF\x1\x46" +
                "\x8\xFFFF\x5\x24\x1\x4C\x1\x4D\x1\x4F\x7\x24\x1\x57\x1\x58\x1\x59\x4" +
                "\x24\xB\xFFFF\x5\x24\x2\xFFFF\x1\x24\x1\xFFFF\x1\x24\x1\x65\x5\x24\x3" +
                "\xFFFF\x1\x6B\x1\x6C\x3\x24\x1\x70\x1\x71\x1\x72\x3\x24\x1\xFFFF\x1\x76" +
                "\x1\x77\x1\x78\x1\x79\x1\x24\x2\xFFFF\x1\x7B\x1\x24\x1\x7D\x3\xFFFF\x1" +
                "\x7E\x2\x24\x4\xFFFF\x1\x81\x1\xFFFF\x1\x82\x2\xFFFF\x1\x24\x1\x84\x2" +
                "\xFFFF\x1\x24\x1\xFFFF\x1\x86\x1\xFFFF";
            private const string DFA7_eofS =
                "\x87\xFFFF";
            private const string DFA7_minS =
                "\x1\x9\x1\x61\x1\x6C\x1\x61\x1\x66\x1\x65\x1\x6F\x2\x68\x1\x6F\x1\x64" +
                "\x2\x65\x1\x72\xA\xFFFF\x2\x2D\x1\x3D\x1\x3E\x1\xFFFF\x1\x2A\x8\xFFFF" +
                "\x1\x61\x2\x73\x1\x61\x1\x6C\x3\x30\x1\x76\x1\x74\x2\x6F\x1\x65\x1\x75" +
                "\x1\x69\x3\x30\x1\x77\x1\x74\x1\x6C\x1\x65\xB\xFFFF\x1\x73\x2\x65\x1" +
                "\x63\x1\x73\x2\xFFFF\x1\x65\x1\xFFFF\x1\x6F\x1\x30\x1\x70\x1\x6C\x1\x6E" +
                "\x1\x65\x1\x6C\x3\xFFFF\x2\x30\x1\x66\x1\x61\x1\x73\x3\x30\x1\x65\x1" +
                "\x72\x1\x69\x1\xFFFF\x4\x30\x1\x65\x2\xFFFF\x1\x30\x1\x6B\x1\x30\x3\xFFFF" +
                "\x1\x30\x1\x69\x1\x64\x4\xFFFF\x1\x30\x1\xFFFF\x1\x30\x2\xFFFF\x1\x74" +
                "\x1\x30\x2\xFFFF\x1\x73\x1\xFFFF\x1\x30\x1\xFFFF";
            private const string DFA7_maxS =
                "\x1\x7E\x1\x6C\x1\x73\x1\x69\x1\x73\x2\x6F\x1\x72\x1\x68\x1\x6F\x1\x66" +
                "\x1\x6F\x1\x65\x1\x72\xA\xFFFF\x1\x2D\x2\x3D\x1\x3E\x1\xFFFF\x1\x2A\x8" +
                "\xFFFF\x1\x61\x2\x73\x1\x61\x1\x6C\x3\x7A\x1\x76\x1\x74\x2\x6F\x1\x65" +
                "\x1\x75\x1\x69\x3\x7A\x1\x77\x1\x74\x1\x6C\x1\x65\xB\xFFFF\x1\x73\x2" +
                "\x65\x1\x63\x1\x73\x2\xFFFF\x1\x65\x1\xFFFF\x1\x6F\x1\x7A\x1\x70\x1\x6C" +
                "\x1\x6E\x1\x65\x1\x6C\x3\xFFFF\x2\x7A\x1\x66\x1\x61\x1\x73\x3\x7A\x1" +
                "\x65\x1\x72\x1\x69\x1\xFFFF\x4\x7A\x1\x65\x2\xFFFF\x1\x7A\x1\x6B\x1\x7A" +
                "\x3\xFFFF\x1\x7A\x1\x69\x1\x64\x4\xFFFF\x1\x7A\x1\xFFFF\x1\x7A\x2\xFFFF" +
                "\x1\x74\x1\x7A\x2\xFFFF\x1\x73\x1\xFFFF\x1\x7A\x1\xFFFF";
            private const string DFA7_acceptS =
                "\xE\xFFFF\x1\x18\x1\x19\x1\x1A\x1\x1B\x1\x1C\x1\x1D\x1\x1E\x1\x1F\x1" +
                "\x20\x1\x21\x4\xFFFF\x1\x29\x1\xFFFF\x1\x2B\x1\x2C\x1\x2D\x1\x2E\x1\x2F" +
                "\x1\x33\x1\x34\x1\x35\x16\xFFFF\x1\x32\x1\x22\x1\x23\x1\x28\x1\x24\x1" +
                "\x25\x1\x26\x1\x30\x1\x27\x1\x31\x1\x2A\x5\xFFFF\x1\x4\x1\x5\x1\xFFFF" +
                "\x1\x6\x7\xFFFF\x1\xE\x1\xF\x1\x13\xB\xFFFF\x1\x9\x5\xFFFF\x1\x12\x1" +
                "\x14\x3\xFFFF\x1\x10\x1\x2\x1\x11\x3\xFFFF\x1\xA\x1\xB\x1\xC\x1\x15\x1" +
                "\xFFFF\x1\x16\x1\xFFFF\x1\x1\x1\x3\x2\xFFFF\x1\xD\x1\x17\x1\xFFFF\x1" +
                "\x8\x1\xFFFF\x1\x7";
            private const string DFA7_specialS =
                "\x87\xFFFF}>";
            private static readonly string[] DFA7_transitionS =
                {
                "\x2\x25\x2\xFFFF\x1\x25\x12\xFFFF\x1\x25\x1\xFFFF\x1\xE\x3\xFFFF\x1"+
                "\x13\x1\xFFFF\x1\x1D\x1\x1E\x1\x15\x1\x17\x1\x21\x1\x18\x1\x10\x1\x16"+
                "\xA\xF\x1\x22\x1\x1C\x1\x19\x1\x1B\x1\x1A\x1\xFFFF\x1\x11\x1A\x23\x6"+
                "\xFFFF\x1\x24\x1\xD\x1\x1\x1\x9\x1\x2\x1\x3\x2\x24\x1\x4\x2\x24\x1\x5"+
                "\x1\x24\x1\xB\x1\xA\x1\x6\x2\x24\x1\xC\x1\x7\x2\x24\x1\x8\x3\x24\x1"+
                "\x1F\x1\x12\x1\x20\x1\x14",
                "\x1\x27\xA\xFFFF\x1\x26",
                "\x1\x28\x6\xFFFF\x1\x29",
                "\x1\x2A\x7\xFFFF\x1\x2B",
                "\x1\x2C\x7\xFFFF\x1\x2D\x4\xFFFF\x1\x2E",
                "\x1\x2F\x9\xFFFF\x1\x30",
                "\x1\x31",
                "\x1\x32\x9\xFFFF\x1\x33",
                "\x1\x34",
                "\x1\x35",
                "\x1\x36\x1\xFFFF\x1\x37",
                "\x1\x38\x9\xFFFF\x1\x39",
                "\x1\x3A",
                "\x1\x3B",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "\x1\x3C",
                "\x1\x3F\xF\xFFFF\x1\x3E",
                "\x1\x41",
                "\x1\x43",
                "",
                "\x1\x45",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "\x1\x47",
                "\x1\x48",
                "\x1\x49",
                "\x1\x4A",
                "\x1\x4B",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x7\x24\x1\x4E\x12"+
                "\x24",
                "\x1\x50",
                "\x1\x51",
                "\x1\x52",
                "\x1\x53",
                "\x1\x54",
                "\x1\x55",
                "\x1\x56",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\x1\x5A",
                "\x1\x5B",
                "\x1\x5C",
                "\x1\x5D",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "\x1\x5E",
                "\x1\x5F",
                "\x1\x60",
                "\x1\x61",
                "\x1\x62",
                "",
                "",
                "\x1\x63",
                "",
                "\x1\x64",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\x1\x66",
                "\x1\x67",
                "\x1\x68",
                "\x1\x69",
                "\x1\x6A",
                "",
                "",
                "",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\x1\x6D",
                "\x1\x6E",
                "\x1\x6F",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\x1\x73",
                "\x1\x74",
                "\x1\x75",
                "",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\x1\x7A",
                "",
                "",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\x1\x7C",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "",
                "",
                "",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "\x1\x7F",
                "\x1\x80",
                "",
                "",
                "",
                "",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "",
                "",
                "\x1\x83",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                "",
                "",
                "\x1\x85",
                "",
                "\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
                ""
            };

            private static readonly short[] DFA7_eot = DFA.UnpackEncodedString(DFA7_eotS);
            private static readonly short[] DFA7_eof = DFA.UnpackEncodedString(DFA7_eofS);
            private static readonly char[] DFA7_min = DFA.UnpackEncodedStringToUnsignedChars(DFA7_minS);
            private static readonly char[] DFA7_max = DFA.UnpackEncodedStringToUnsignedChars(DFA7_maxS);
            private static readonly short[] DFA7_accept = DFA.UnpackEncodedString(DFA7_acceptS);
            private static readonly short[] DFA7_special = DFA.UnpackEncodedString(DFA7_specialS);
            private static readonly short[][] DFA7_transition;

            static DFA7()
            {
                int numStates = DFA7_transitionS.Length;
                DFA7_transition = new short[numStates][];
                for (int i = 0; i < numStates; i++)
                {
                    DFA7_transition[i] = DFA.UnpackEncodedString(DFA7_transitionS[i]);
                }
            }

            public DFA7(BaseRecognizer recognizer)
            {
                this.recognizer = recognizer;
                this.decisionNumber = 7;
                this.eot = DFA7_eot;
                this.eof = DFA7_eof;
                this.min = DFA7_min;
                this.max = DFA7_max;
                this.accept = DFA7_accept;
                this.special = DFA7_special;
                this.transition = DFA7_transition;
            }

            public override string Description { get { return "1:1: Tokens : ( CLASS | ELSE | FALSE | FI | IF | IN | INHERITS | ISVOID | LET | LOOP | POOL | THEN | WHILE | DO | OD | CASE | ESAC | NEW | OF | NOT | TRUE | SELF | BREAK | STRING | INTEGER | DOT | ATSIGN | OR | AND | NEG | MULT | DIV | PLUS | MINUS | LE | LT | GE | GT | EQUAL | ASSIGN | SEMI | LPAREN | RPAREN | LKEY | RKEY | COMMA | COLON | HENCE | MULTILINE_COMMENT | COMMENT | TYPE_ID | OBJ_ID | WS );"; } }

            public override void Error(NoViableAltException nvae)
            {
                DebugRecognitionException(nvae);
            }
        }


        #endregion

    }

} // namespace CoolGrammar
