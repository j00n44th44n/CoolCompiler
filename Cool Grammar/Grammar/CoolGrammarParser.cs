//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: null
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR null \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g 2019-02-25 21:55:37

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Text;
using CoolGrammar.Grammar;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace CoolGrammar
{
    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "null")]
    [System.CLSCompliant(false)]
    public partial class CoolGrammarParser : Antlr.Runtime.Parser
    {
        internal static readonly string[] tokenNames = new string[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASSIGN", "ATSIGN", "BREAK", "Block", "CAPITAL_LETTER", "CASE", "CLASS", "COLON", "COMMA", "COMMENT", "CaseExpr", "Class", "DIGIT", "DIV", "DO", "DOT", "DoWhile", "DotObjectInvoke", "DotTypeInvoke", "ELSE", "EQUAL", "ESAC", "ExprList", "FALSE", "FI", "FeatureList", "FuncDef", "FunctionArgsList", "GE", "GT", "HENCE", "IF", "IN", "INHERITS", "INTEGER", "ISVOID", "IdValue", "ImplicitInvoke", "LE", "LET", "LKEY", "LOOP", "LOWER_LETTER", "LPAREN", "LT", "LetExprs", "LocalOrFieldInit", "MINUS", "MULT", "MULTILINE_COMMENT", "NEG", "NEW", "NOT", "OBJ_ID", "OD", "OF", "OR", "PLUS", "POOL", "Params", "Program", "RKEY", "RPAREN", "SELF", "SEMI", "STRING", "THEN", "TRUE", "TYPE_ID", "WHILE", "WS"
    };
        public const int EOF = -1;
        public const int AND = 4;
        public const int ASSIGN = 5;
        public const int ATSIGN = 6;
        public const int BREAK = 7;
        public const int Block = 8;
        public const int CAPITAL_LETTER = 9;
        public const int CASE = 10;
        public const int CLASS = 11;
        public const int COLON = 12;
        public const int COMMA = 13;
        public const int COMMENT = 14;
        public const int CaseExpr = 15;
        public const int Class = 16;
        public const int DIGIT = 17;
        public const int DIV = 18;
        public const int DO = 19;
        public const int DOT = 20;
        public const int DoWhile = 21;
        public const int DotObjectInvoke = 22;
        public const int DotTypeInvoke = 23;
        public const int ELSE = 24;
        public const int EQUAL = 25;
        public const int ESAC = 26;
        public const int ExprList = 27;
        public const int FALSE = 28;
        public const int FI = 29;
        public const int FeatureList = 30;
        public const int FuncDef = 31;
        public const int FunctionArgsList = 32;
        public const int GE = 33;
        public const int GT = 34;
        public const int HENCE = 35;
        public const int IF = 36;
        public const int IN = 37;
        public const int INHERITS = 38;
        public const int INTEGER = 39;
        public const int ISVOID = 40;
        public const int IdValue = 41;
        public const int ImplicitInvoke = 42;
        public const int LE = 43;
        public const int LET = 44;
        public const int LKEY = 45;
        public const int LOOP = 46;
        public const int LOWER_LETTER = 47;
        public const int LPAREN = 48;
        public const int LT = 49;
        public const int LetExprs = 50;
        public const int LocalOrFieldInit = 51;
        public const int MINUS = 52;
        public const int MULT = 53;
        public const int MULTILINE_COMMENT = 54;
        public const int NEG = 55;
        public const int NEW = 56;
        public const int NOT = 57;
        public const int OBJ_ID = 58;
        public const int OD = 59;
        public const int OF = 60;
        public const int OR = 61;
        public const int PLUS = 62;
        public const int POOL = 63;
        public const int Params = 64;
        public const int Program = 65;
        public const int RKEY = 66;
        public const int RPAREN = 67;
        public const int SELF = 68;
        public const int SEMI = 69;
        public const int STRING = 70;
        public const int THEN = 71;
        public const int TRUE = 72;
        public const int TYPE_ID = 73;
        public const int WHILE = 74;
        public const int WS = 75;

        public CoolGrammarParser(ITokenStream input)
            : this(input, new RecognizerSharedState())
        {
        }
        public CoolGrammarParser(ITokenStream input, RecognizerSharedState state)
            : base(input, state)
        {
            ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
            CreateTreeAdaptor(ref treeAdaptor);
            TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
            OnCreated();
        }
        // Implement this function in your helper file to use a custom tree adaptor
        partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

        private ITreeAdaptor adaptor;

        public ITreeAdaptor TreeAdaptor
        {
            get
            {
                return adaptor;
            }

            set
            {
                this.adaptor = value;
            }
        }

        public override string[] TokenNames { get { return CoolGrammarParser.tokenNames; } }
        public override string GrammarFileName { get { return "\\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g"; } }



        public override void ReportError(RecognitionException e)
        {
            base.ReportError(e);
            var stringerror = GetErrorMessage(e, TokenNames);
            Logger.LogError(e.Line, e.CharPositionInLine, stringerror);

        }


        partial void OnCreated();
        partial void EnterRule(string ruleName, int ruleIndex);
        partial void LeaveRule(string ruleName, int ruleIndex);

        #region Rules
        partial void EnterRule_program();
        partial void LeaveRule_program();
        // $ANTLR start "program"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:140:8: public program : ( class SEMI )+ -> ^( Program ( class )+ ) ;
        [GrammarRule("program")]
        public AstParserRuleReturnScope<object, IToken> program()
        {
            EnterRule_program();
            EnterRule("program", 1);
            TraceIn("program", 1);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken SEMI2 = default(IToken);
            AstParserRuleReturnScope<object, IToken> class1 = default(AstParserRuleReturnScope<object, IToken>);

            object SEMI2_tree = default(object);
            RewriteRuleITokenStream stream_SEMI = new RewriteRuleITokenStream(adaptor, "token SEMI");
            RewriteRuleSubtreeStream stream_class = new RewriteRuleSubtreeStream(adaptor, "rule class");
            try
            {
                DebugEnterRule(GrammarFileName, "program");
                DebugLocation(140, 22);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:140:16: ( ( class SEMI )+ -> ^( Program ( class )+ ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:141:3: ( class SEMI )+
                    {
                        DebugLocation(141, 3);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:141:3: ( class SEMI )+
                        int cnt1 = 0;
                        try
                        {
                            DebugEnterSubRule(1);
                            while (true)
                            {
                                int alt1 = 2;
                                try
                                {
                                    DebugEnterDecision(1, false);
                                    int LA1_1 = input.LA(1);

                                    if ((LA1_1 == CLASS))
                                    {
                                        alt1 = 1;
                                    }


                                }
                                finally { DebugExitDecision(1); }
                                switch (alt1)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:141:4: class SEMI
                                        {
                                            DebugLocation(141, 4);
                                            PushFollow(Follow._class_in_program890);
                                            class1 = @class();
                                            PopFollow();

                                            stream_class.Add(class1.Tree);
                                            DebugLocation(141, 10);
                                            SEMI2 = (IToken)Match(input, SEMI, Follow._SEMI_in_program892);
                                            stream_SEMI.Add(SEMI2);


                                        }
                                        break;

                                    default:
                                        if (cnt1 >= 1)
                                            goto loop1;

                                        EarlyExitException eee1 = new EarlyExitException(1, input);
                                        DebugRecognitionException(eee1);
                                        throw eee1;
                                }
                                cnt1++;
                            }
                        loop1:
                            ;

                        }
                        finally { DebugExitSubRule(1); }



                        {
                            // AST REWRITE
                            // elements: class
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 142:3: -> ^( Program ( class )+ )
                            {
                                DebugLocation(142, 5);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:142:5: ^( Program ( class )+ )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(142, 8);
                                    root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(Program, "Program"), root_1);

                                    DebugLocation(142, 16);
                                    if (!(stream_class.HasNext))
                                    {
                                        throw new RewriteEarlyExitException();
                                    }
                                    while (stream_class.HasNext)
                                    {
                                        DebugLocation(142, 16);
                                        adaptor.AddChild(root_1, stream_class.NextTree());

                                    }
                                    stream_class.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("program", 1);
                    LeaveRule("program", 1);
                    LeaveRule_program();
                }
                DebugLocation(142, 22);
            }
            finally { DebugExitRule(GrammarFileName, "program"); }
            return retval;

        }
        // $ANTLR end "program"

        partial void EnterRule_class();
        partial void LeaveRule_class();
        // $ANTLR start "class"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:144:1: class : CLASS TYPE_ID ( INHERITS TYPE_ID )? LKEY feature_list RKEY -> ^( CLASS TYPE_ID feature_list ( TYPE_ID )? ) ;
        [GrammarRule("class")]
        private AstParserRuleReturnScope<object, IToken> @class()
        {
            EnterRule_class();
            EnterRule("class", 2);
            TraceIn("class", 2);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken CLASS3 = default(IToken);
            IToken TYPE_ID4 = default(IToken);
            IToken INHERITS5 = default(IToken);
            IToken TYPE_ID6 = default(IToken);
            IToken LKEY7 = default(IToken);
            IToken RKEY9 = default(IToken);
            AstParserRuleReturnScope<object, IToken> feature_list8 = default(AstParserRuleReturnScope<object, IToken>);

            object CLASS3_tree = default(object);
            object TYPE_ID4_tree = default(object);
            object INHERITS5_tree = default(object);
            object TYPE_ID6_tree = default(object);
            object LKEY7_tree = default(object);
            object RKEY9_tree = default(object);
            RewriteRuleITokenStream stream_LKEY = new RewriteRuleITokenStream(adaptor, "token LKEY");
            RewriteRuleITokenStream stream_TYPE_ID = new RewriteRuleITokenStream(adaptor, "token TYPE_ID");
            RewriteRuleITokenStream stream_INHERITS = new RewriteRuleITokenStream(adaptor, "token INHERITS");
            RewriteRuleITokenStream stream_CLASS = new RewriteRuleITokenStream(adaptor, "token CLASS");
            RewriteRuleITokenStream stream_RKEY = new RewriteRuleITokenStream(adaptor, "token RKEY");
            RewriteRuleSubtreeStream stream_feature_list = new RewriteRuleSubtreeStream(adaptor, "rule feature_list");
            try
            {
                DebugEnterRule(GrammarFileName, "class");
                DebugLocation(144, 2);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:144:7: ( CLASS TYPE_ID ( INHERITS TYPE_ID )? LKEY feature_list RKEY -> ^( CLASS TYPE_ID feature_list ( TYPE_ID )? ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:145:3: CLASS TYPE_ID ( INHERITS TYPE_ID )? LKEY feature_list RKEY
                    {
                        DebugLocation(145, 3);
                        CLASS3 = (IToken)Match(input, CLASS, Follow._CLASS_in_class925);
                        stream_CLASS.Add(CLASS3);

                        DebugLocation(145, 9);
                        TYPE_ID4 = (IToken)Match(input, TYPE_ID, Follow._TYPE_ID_in_class927);
                        stream_TYPE_ID.Add(TYPE_ID4);

                        DebugLocation(145, 17);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:145:17: ( INHERITS TYPE_ID )?
                        int alt2 = 2;
                        try
                        {
                            DebugEnterSubRule(2);
                            try
                            {
                                DebugEnterDecision(2, false);
                                int LA2_1 = input.LA(1);

                                if ((LA2_1 == INHERITS))
                                {
                                    alt2 = 1;
                                }
                            }
                            finally { DebugExitDecision(2); }
                            switch (alt2)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:145:18: INHERITS TYPE_ID
                                    {
                                        DebugLocation(145, 18);
                                        INHERITS5 = (IToken)Match(input, INHERITS, Follow._INHERITS_in_class930);
                                        stream_INHERITS.Add(INHERITS5);

                                        DebugLocation(145, 27);
                                        TYPE_ID6 = (IToken)Match(input, TYPE_ID, Follow._TYPE_ID_in_class932);
                                        stream_TYPE_ID.Add(TYPE_ID6);


                                    }
                                    break;

                            }
                        }
                        finally { DebugExitSubRule(2); }

                        DebugLocation(145, 37);
                        LKEY7 = (IToken)Match(input, LKEY, Follow._LKEY_in_class936);
                        stream_LKEY.Add(LKEY7);

                        DebugLocation(145, 42);
                        PushFollow(Follow._feature_list_in_class938);
                        feature_list8 = feature_list();
                        PopFollow();

                        stream_feature_list.Add(feature_list8.Tree);
                        DebugLocation(145, 56);
                        RKEY9 = (IToken)Match(input, RKEY, Follow._RKEY_in_class941);
                        stream_RKEY.Add(RKEY9);



                        {
                            // AST REWRITE
                            // elements: CLASS, TYPE_ID, TYPE_ID, feature_list
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 146:3: -> ^( CLASS TYPE_ID feature_list ( TYPE_ID )? )
                            {
                                DebugLocation(146, 6);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:146:6: ^( CLASS TYPE_ID feature_list ( TYPE_ID )? )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(146, 9);
                                    root_1 = (object)adaptor.BecomeRoot(stream_CLASS.NextNode(), root_1);

                                    DebugLocation(146, 15);
                                    adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());
                                    DebugLocation(146, 23);
                                    adaptor.AddChild(root_1, stream_feature_list.NextTree());
                                    DebugLocation(146, 36);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:146:36: ( TYPE_ID )?
                                    if (stream_TYPE_ID.HasNext)
                                    {
                                        DebugLocation(146, 36);
                                        adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());

                                    }
                                    stream_TYPE_ID.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("class", 2);
                    LeaveRule("class", 2);
                    LeaveRule_class();
                }
                DebugLocation(147, 2);
            }
            finally { DebugExitRule(GrammarFileName, "class"); }
            return retval;

        }
        // $ANTLR end "class"

        partial void EnterRule_feature_list();
        partial void LeaveRule_feature_list();
        // $ANTLR start "feature_list"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:149:1: feature_list : ( feature SEMI )* -> ^( FeatureList ( feature )* ) ;
        [GrammarRule("feature_list")]
        private AstParserRuleReturnScope<object, IToken> feature_list()
        {
            EnterRule_feature_list();
            EnterRule("feature_list", 3);
            TraceIn("feature_list", 3);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken SEMI11 = default(IToken);
            AstParserRuleReturnScope<object, IToken> feature10 = default(AstParserRuleReturnScope<object, IToken>);

            object SEMI11_tree = default(object);
            RewriteRuleITokenStream stream_SEMI = new RewriteRuleITokenStream(adaptor, "token SEMI");
            RewriteRuleSubtreeStream stream_feature = new RewriteRuleSubtreeStream(adaptor, "rule feature");
            try
            {
                DebugEnterRule(GrammarFileName, "feature_list");
                DebugLocation(149, 28);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:149:14: ( ( feature SEMI )* -> ^( FeatureList ( feature )* ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:150:3: ( feature SEMI )*
                    {
                        DebugLocation(150, 3);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:150:3: ( feature SEMI )*
                        try
                        {
                            DebugEnterSubRule(3);
                            while (true)
                            {
                                int alt3 = 2;
                                try
                                {
                                    DebugEnterDecision(3, false);
                                    int LA3_1 = input.LA(1);

                                    if ((LA3_1 == OBJ_ID))
                                    {
                                        alt3 = 1;
                                    }


                                }
                                finally { DebugExitDecision(3); }
                                switch (alt3)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:150:4: feature SEMI
                                        {
                                            DebugLocation(150, 4);
                                            PushFollow(Follow._feature_in_feature_list972);
                                            feature10 = feature();
                                            PopFollow();

                                            stream_feature.Add(feature10.Tree);
                                            DebugLocation(150, 12);
                                            SEMI11 = (IToken)Match(input, SEMI, Follow._SEMI_in_feature_list974);
                                            stream_SEMI.Add(SEMI11);


                                        }
                                        break;

                                    default:
                                        goto loop3;
                                }
                            }

                        loop3:
                            ;

                        }
                        finally { DebugExitSubRule(3); }



                        {
                            // AST REWRITE
                            // elements: feature
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 151:3: -> ^( FeatureList ( feature )* )
                            {
                                DebugLocation(151, 6);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:151:6: ^( FeatureList ( feature )* )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(151, 8);
                                    root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FeatureList, "FeatureList"), root_1);

                                    DebugLocation(151, 20);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:151:20: ( feature )*
                                    while (stream_feature.HasNext)
                                    {
                                        DebugLocation(151, 20);
                                        adaptor.AddChild(root_1, stream_feature.NextTree());

                                    }
                                    stream_feature.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("feature_list", 3);
                    LeaveRule("feature_list", 3);
                    LeaveRule_feature_list();
                }
                DebugLocation(151, 28);
            }
            finally { DebugExitRule(GrammarFileName, "feature_list"); }
            return retval;

        }
        // $ANTLR end "feature_list"

        partial void EnterRule_feature();
        partial void LeaveRule_feature();
        // $ANTLR start "feature"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:153:1: feature : ( localOrFieldInit -> localOrFieldInit | method -> method );
        [GrammarRule("feature")]
        private AstParserRuleReturnScope<object, IToken> feature()
        {
            EnterRule_feature();
            EnterRule("feature", 4);
            TraceIn("feature", 4);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            AstParserRuleReturnScope<object, IToken> localOrFieldInit12 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> method13 = default(AstParserRuleReturnScope<object, IToken>);

            RewriteRuleSubtreeStream stream_method = new RewriteRuleSubtreeStream(adaptor, "rule method");
            RewriteRuleSubtreeStream stream_localOrFieldInit = new RewriteRuleSubtreeStream(adaptor, "rule localOrFieldInit");
            try
            {
                DebugEnterRule(GrammarFileName, "feature");
                DebugLocation(153, 59);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:153:9: ( localOrFieldInit -> localOrFieldInit | method -> method )
                    int alt4 = 2;
                    try
                    {
                        DebugEnterDecision(4, false);
                        int LA4_1 = input.LA(1);

                        if ((LA4_1 == OBJ_ID))
                        {
                            int LA4_2 = input.LA(2);

                            if ((LA4_2 == COLON))
                            {
                                alt4 = 1;
                            }
                            else if ((LA4_2 == LPAREN))
                            {
                                alt4 = 2;
                            }
                            else
                            {
                                NoViableAltException nvae = new NoViableAltException("", 4, 1, input, 2);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                        }
                        else
                        {
                            NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
                            DebugRecognitionException(nvae);
                            throw nvae;
                        }
                    }
                    finally { DebugExitDecision(4); }
                    switch (alt4)
                    {
                        case 1:
                            DebugEnterAlt(1);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:154:5: localOrFieldInit
                            {
                                DebugLocation(154, 5);
                                PushFollow(Follow._localOrFieldInit_in_feature1002);
                                localOrFieldInit12 = localOrFieldInit();
                                PopFollow();

                                stream_localOrFieldInit.Add(localOrFieldInit12.Tree);


                                {
                                    // AST REWRITE
                                    // elements: localOrFieldInit
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 154:22: -> localOrFieldInit
                                    {
                                        DebugLocation(154, 25);
                                        adaptor.AddChild(root_0, stream_localOrFieldInit.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 2:
                            DebugEnterAlt(2);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:154:44: method
                            {
                                DebugLocation(154, 44);
                                PushFollow(Follow._method_in_feature1010);
                                method13 = method();
                                PopFollow();

                                stream_method.Add(method13.Tree);


                                {
                                    // AST REWRITE
                                    // elements: method
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 154:51: -> method
                                    {
                                        DebugLocation(154, 54);
                                        adaptor.AddChild(root_0, stream_method.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;

                    }
                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("feature", 4);
                    LeaveRule("feature", 4);
                    LeaveRule_feature();
                }
                DebugLocation(154, 59);
            }
            finally { DebugExitRule(GrammarFileName, "feature"); }
            return retval;

        }
        // $ANTLR end "feature"

        partial void EnterRule_method();
        partial void LeaveRule_method();
        // $ANTLR start "method"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:156:1: method : OBJ_ID LPAREN ( formal_parameters )? RPAREN COLON TYPE_ID LKEY expression RKEY -> ^( FuncDef OBJ_ID TYPE_ID ( formal_parameters )? expression ) ;
        [GrammarRule("method")]
        private AstParserRuleReturnScope<object, IToken> method()
        {
            EnterRule_method();
            EnterRule("method", 5);
            TraceIn("method", 5);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken OBJ_ID14 = default(IToken);
            IToken LPAREN15 = default(IToken);
            IToken RPAREN17 = default(IToken);
            IToken COLON18 = default(IToken);
            IToken TYPE_ID19 = default(IToken);
            IToken LKEY20 = default(IToken);
            IToken RKEY22 = default(IToken);
            AstParserRuleReturnScope<object, IToken> formal_parameters16 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> expression21 = default(AstParserRuleReturnScope<object, IToken>);

            object OBJ_ID14_tree = default(object);
            object LPAREN15_tree = default(object);
            object RPAREN17_tree = default(object);
            object COLON18_tree = default(object);
            object TYPE_ID19_tree = default(object);
            object LKEY20_tree = default(object);
            object RKEY22_tree = default(object);
            RewriteRuleITokenStream stream_OBJ_ID = new RewriteRuleITokenStream(adaptor, "token OBJ_ID");
            RewriteRuleITokenStream stream_LKEY = new RewriteRuleITokenStream(adaptor, "token LKEY");
            RewriteRuleITokenStream stream_TYPE_ID = new RewriteRuleITokenStream(adaptor, "token TYPE_ID");
            RewriteRuleITokenStream stream_LPAREN = new RewriteRuleITokenStream(adaptor, "token LPAREN");
            RewriteRuleITokenStream stream_COLON = new RewriteRuleITokenStream(adaptor, "token COLON");
            RewriteRuleITokenStream stream_RPAREN = new RewriteRuleITokenStream(adaptor, "token RPAREN");
            RewriteRuleITokenStream stream_RKEY = new RewriteRuleITokenStream(adaptor, "token RKEY");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            RewriteRuleSubtreeStream stream_formal_parameters = new RewriteRuleSubtreeStream(adaptor, "rule formal_parameters");
            try
            {
                DebugEnterRule(GrammarFileName, "method");
                DebugLocation(156, 60);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:156:8: ( OBJ_ID LPAREN ( formal_parameters )? RPAREN COLON TYPE_ID LKEY expression RKEY -> ^( FuncDef OBJ_ID TYPE_ID ( formal_parameters )? expression ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:157:4: OBJ_ID LPAREN ( formal_parameters )? RPAREN COLON TYPE_ID LKEY expression RKEY
                    {
                        DebugLocation(157, 4);
                        OBJ_ID14 = (IToken)Match(input, OBJ_ID, Follow._OBJ_ID_in_method1027);
                        stream_OBJ_ID.Add(OBJ_ID14);

                        DebugLocation(157, 11);
                        LPAREN15 = (IToken)Match(input, LPAREN, Follow._LPAREN_in_method1029);
                        stream_LPAREN.Add(LPAREN15);

                        DebugLocation(157, 18);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:157:18: ( formal_parameters )?
                        int alt5 = 2;
                        try
                        {
                            DebugEnterSubRule(5);
                            try
                            {
                                DebugEnterDecision(5, false);
                                int LA5_1 = input.LA(1);

                                if ((LA5_1 == OBJ_ID))
                                {
                                    alt5 = 1;
                                }
                            }
                            finally { DebugExitDecision(5); }
                            switch (alt5)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:157:19: formal_parameters
                                    {
                                        DebugLocation(157, 19);
                                        PushFollow(Follow._formal_parameters_in_method1032);
                                        formal_parameters16 = formal_parameters();
                                        PopFollow();

                                        stream_formal_parameters.Add(formal_parameters16.Tree);

                                    }
                                    break;

                            }
                        }
                        finally { DebugExitSubRule(5); }

                        DebugLocation(157, 39);
                        RPAREN17 = (IToken)Match(input, RPAREN, Follow._RPAREN_in_method1036);
                        stream_RPAREN.Add(RPAREN17);

                        DebugLocation(157, 47);
                        COLON18 = (IToken)Match(input, COLON, Follow._COLON_in_method1039);
                        stream_COLON.Add(COLON18);

                        DebugLocation(157, 54);
                        TYPE_ID19 = (IToken)Match(input, TYPE_ID, Follow._TYPE_ID_in_method1042);
                        stream_TYPE_ID.Add(TYPE_ID19);

                        DebugLocation(157, 62);
                        LKEY20 = (IToken)Match(input, LKEY, Follow._LKEY_in_method1044);
                        stream_LKEY.Add(LKEY20);

                        DebugLocation(157, 67);
                        PushFollow(Follow._expression_in_method1046);
                        expression21 = expression();
                        PopFollow();

                        stream_expression.Add(expression21.Tree);
                        DebugLocation(157, 78);
                        RKEY22 = (IToken)Match(input, RKEY, Follow._RKEY_in_method1048);
                        stream_RKEY.Add(RKEY22);



                        {
                            // AST REWRITE
                            // elements: expression, formal_parameters, OBJ_ID, TYPE_ID
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 158:4: -> ^( FuncDef OBJ_ID TYPE_ID ( formal_parameters )? expression )
                            {
                                DebugLocation(158, 6);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:158:6: ^( FuncDef OBJ_ID TYPE_ID ( formal_parameters )? expression )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(158, 8);
                                    root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FuncDef, "FuncDef"), root_1);

                                    DebugLocation(158, 16);
                                    adaptor.AddChild(root_1, stream_OBJ_ID.NextNode());
                                    DebugLocation(158, 23);
                                    adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());
                                    DebugLocation(158, 31);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:158:31: ( formal_parameters )?
                                    if (stream_formal_parameters.HasNext)
                                    {
                                        DebugLocation(158, 31);
                                        adaptor.AddChild(root_1, stream_formal_parameters.NextTree());

                                    }
                                    stream_formal_parameters.Reset();
                                    DebugLocation(158, 50);
                                    adaptor.AddChild(root_1, stream_expression.NextTree());

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("method", 5);
                    LeaveRule("method", 5);
                    LeaveRule_method();
                }
                DebugLocation(158, 60);
            }
            finally { DebugExitRule(GrammarFileName, "method"); }
            return retval;

        }
        // $ANTLR end "method"

        partial void EnterRule_formal_parameters();
        partial void LeaveRule_formal_parameters();
        // $ANTLR start "formal_parameters"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:160:1: formal_parameters : formal ( COMMA formal )* -> ^( FunctionArgsList ( formal )+ ) ;
        [GrammarRule("formal_parameters")]
        private AstParserRuleReturnScope<object, IToken> formal_parameters()
        {
            EnterRule_formal_parameters();
            EnterRule("formal_parameters", 6);
            TraceIn("formal_parameters", 6);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken COMMA24 = default(IToken);
            AstParserRuleReturnScope<object, IToken> formal23 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> formal25 = default(AstParserRuleReturnScope<object, IToken>);

            object COMMA24_tree = default(object);
            RewriteRuleITokenStream stream_COMMA = new RewriteRuleITokenStream(adaptor, "token COMMA");
            RewriteRuleSubtreeStream stream_formal = new RewriteRuleSubtreeStream(adaptor, "rule formal");
            try
            {
                DebugEnterRule(GrammarFileName, "formal_parameters");
                DebugLocation(160, 31);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:160:19: ( formal ( COMMA formal )* -> ^( FunctionArgsList ( formal )+ ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:161:3: formal ( COMMA formal )*
                    {
                        DebugLocation(161, 3);
                        PushFollow(Follow._formal_in_formal_parameters1076);
                        formal23 = formal();
                        PopFollow();

                        stream_formal.Add(formal23.Tree);
                        DebugLocation(161, 10);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:161:10: ( COMMA formal )*
                        try
                        {
                            DebugEnterSubRule(6);
                            while (true)
                            {
                                int alt6 = 2;
                                try
                                {
                                    DebugEnterDecision(6, false);
                                    int LA6_1 = input.LA(1);

                                    if ((LA6_1 == COMMA))
                                    {
                                        alt6 = 1;
                                    }


                                }
                                finally { DebugExitDecision(6); }
                                switch (alt6)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:161:11: COMMA formal
                                        {
                                            DebugLocation(161, 11);
                                            COMMA24 = (IToken)Match(input, COMMA, Follow._COMMA_in_formal_parameters1079);
                                            stream_COMMA.Add(COMMA24);

                                            DebugLocation(161, 17);
                                            PushFollow(Follow._formal_in_formal_parameters1081);
                                            formal25 = formal();
                                            PopFollow();

                                            stream_formal.Add(formal25.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop6;
                                }
                            }

                        loop6:
                            ;

                        }
                        finally { DebugExitSubRule(6); }



                        {
                            // AST REWRITE
                            // elements: formal
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 162:3: -> ^( FunctionArgsList ( formal )+ )
                            {
                                DebugLocation(162, 5);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:162:5: ^( FunctionArgsList ( formal )+ )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(162, 7);
                                    root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FunctionArgsList, "FunctionArgsList"), root_1);

                                    DebugLocation(162, 24);
                                    if (!(stream_formal.HasNext))
                                    {
                                        throw new RewriteEarlyExitException();
                                    }
                                    while (stream_formal.HasNext)
                                    {
                                        DebugLocation(162, 24);
                                        adaptor.AddChild(root_1, stream_formal.NextTree());

                                    }
                                    stream_formal.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("formal_parameters", 6);
                    LeaveRule("formal_parameters", 6);
                    LeaveRule_formal_parameters();
                }
                DebugLocation(162, 31);
            }
            finally { DebugExitRule(GrammarFileName, "formal_parameters"); }
            return retval;

        }
        // $ANTLR end "formal_parameters"

        partial void EnterRule_formal();
        partial void LeaveRule_formal();
        // $ANTLR start "formal"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:164:1: formal : OBJ_ID COLON TYPE_ID -> ^( COLON OBJ_ID TYPE_ID ) ;
        [GrammarRule("formal")]
        private AstParserRuleReturnScope<object, IToken> formal()
        {
            EnterRule_formal();
            EnterRule("formal", 7);
            TraceIn("formal", 7);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken OBJ_ID26 = default(IToken);
            IToken COLON27 = default(IToken);
            IToken TYPE_ID28 = default(IToken);

            object OBJ_ID26_tree = default(object);
            object COLON27_tree = default(object);
            object TYPE_ID28_tree = default(object);
            RewriteRuleITokenStream stream_OBJ_ID = new RewriteRuleITokenStream(adaptor, "token OBJ_ID");
            RewriteRuleITokenStream stream_TYPE_ID = new RewriteRuleITokenStream(adaptor, "token TYPE_ID");
            RewriteRuleITokenStream stream_COLON = new RewriteRuleITokenStream(adaptor, "token COLON");
            try
            {
                DebugEnterRule(GrammarFileName, "formal");
                DebugLocation(164, 28);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:164:8: ( OBJ_ID COLON TYPE_ID -> ^( COLON OBJ_ID TYPE_ID ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:165:3: OBJ_ID COLON TYPE_ID
                    {
                        DebugLocation(165, 3);
                        OBJ_ID26 = (IToken)Match(input, OBJ_ID, Follow._OBJ_ID_in_formal1107);
                        stream_OBJ_ID.Add(OBJ_ID26);

                        DebugLocation(165, 11);
                        COLON27 = (IToken)Match(input, COLON, Follow._COLON_in_formal1110);
                        stream_COLON.Add(COLON27);

                        DebugLocation(165, 18);
                        TYPE_ID28 = (IToken)Match(input, TYPE_ID, Follow._TYPE_ID_in_formal1113);
                        stream_TYPE_ID.Add(TYPE_ID28);



                        {
                            // AST REWRITE
                            // elements: TYPE_ID, OBJ_ID, COLON
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 166:3: -> ^( COLON OBJ_ID TYPE_ID )
                            {
                                DebugLocation(166, 5);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:166:5: ^( COLON OBJ_ID TYPE_ID )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(166, 8);
                                    root_1 = (object)adaptor.BecomeRoot(stream_COLON.NextNode(), root_1);

                                    DebugLocation(166, 14);
                                    adaptor.AddChild(root_1, stream_OBJ_ID.NextNode());
                                    DebugLocation(166, 21);
                                    adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("formal", 7);
                    LeaveRule("formal", 7);
                    LeaveRule_formal();
                }
                DebugLocation(166, 28);
            }
            finally { DebugExitRule(GrammarFileName, "formal"); }
            return retval;

        }
        // $ANTLR end "formal"

        partial void EnterRule_localOrFieldInit();
        partial void LeaveRule_localOrFieldInit();
        // $ANTLR start "localOrFieldInit"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:168:1: localOrFieldInit : OBJ_ID COLON TYPE_ID ( ASSIGN expression )? -> ^( LocalOrFieldInit OBJ_ID TYPE_ID ( expression )? ) ;
        [GrammarRule("localOrFieldInit")]
        private AstParserRuleReturnScope<object, IToken> localOrFieldInit()
        {
            EnterRule_localOrFieldInit();
            EnterRule("localOrFieldInit", 8);
            TraceIn("localOrFieldInit", 8);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken OBJ_ID29 = default(IToken);
            IToken COLON30 = default(IToken);
            IToken TYPE_ID31 = default(IToken);
            IToken ASSIGN32 = default(IToken);
            AstParserRuleReturnScope<object, IToken> expression33 = default(AstParserRuleReturnScope<object, IToken>);

            object OBJ_ID29_tree = default(object);
            object COLON30_tree = default(object);
            object TYPE_ID31_tree = default(object);
            object ASSIGN32_tree = default(object);
            RewriteRuleITokenStream stream_OBJ_ID = new RewriteRuleITokenStream(adaptor, "token OBJ_ID");
            RewriteRuleITokenStream stream_TYPE_ID = new RewriteRuleITokenStream(adaptor, "token TYPE_ID");
            RewriteRuleITokenStream stream_COLON = new RewriteRuleITokenStream(adaptor, "token COLON");
            RewriteRuleITokenStream stream_ASSIGN = new RewriteRuleITokenStream(adaptor, "token ASSIGN");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                DebugEnterRule(GrammarFileName, "localOrFieldInit");
                DebugLocation(168, 52);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:168:18: ( OBJ_ID COLON TYPE_ID ( ASSIGN expression )? -> ^( LocalOrFieldInit OBJ_ID TYPE_ID ( expression )? ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:169:3: OBJ_ID COLON TYPE_ID ( ASSIGN expression )?
                    {
                        DebugLocation(169, 3);
                        OBJ_ID29 = (IToken)Match(input, OBJ_ID, Follow._OBJ_ID_in_localOrFieldInit1137);
                        stream_OBJ_ID.Add(OBJ_ID29);

                        DebugLocation(169, 11);
                        COLON30 = (IToken)Match(input, COLON, Follow._COLON_in_localOrFieldInit1140);
                        stream_COLON.Add(COLON30);

                        DebugLocation(169, 18);
                        TYPE_ID31 = (IToken)Match(input, TYPE_ID, Follow._TYPE_ID_in_localOrFieldInit1143);
                        stream_TYPE_ID.Add(TYPE_ID31);

                        DebugLocation(169, 26);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:169:26: ( ASSIGN expression )?
                        int alt7 = 2;
                        try
                        {
                            DebugEnterSubRule(7);
                            try
                            {
                                DebugEnterDecision(7, false);
                                int LA7_1 = input.LA(1);

                                if ((LA7_1 == ASSIGN))
                                {
                                    alt7 = 1;
                                }
                            }
                            finally { DebugExitDecision(7); }
                            switch (alt7)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:169:27: ASSIGN expression
                                    {
                                        DebugLocation(169, 27);
                                        ASSIGN32 = (IToken)Match(input, ASSIGN, Follow._ASSIGN_in_localOrFieldInit1146);
                                        stream_ASSIGN.Add(ASSIGN32);

                                        DebugLocation(169, 35);
                                        PushFollow(Follow._expression_in_localOrFieldInit1149);
                                        expression33 = expression();
                                        PopFollow();

                                        stream_expression.Add(expression33.Tree);

                                    }
                                    break;

                            }
                        }
                        finally { DebugExitSubRule(7); }



                        {
                            // AST REWRITE
                            // elements: TYPE_ID, OBJ_ID, expression
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 170:4: -> ^( LocalOrFieldInit OBJ_ID TYPE_ID ( expression )? )
                            {
                                DebugLocation(170, 7);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:170:7: ^( LocalOrFieldInit OBJ_ID TYPE_ID ( expression )? )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(170, 9);
                                    root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LocalOrFieldInit, "LocalOrFieldInit"), root_1);

                                    DebugLocation(170, 26);
                                    adaptor.AddChild(root_1, stream_OBJ_ID.NextNode());
                                    DebugLocation(170, 33);
                                    adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());
                                    DebugLocation(170, 41);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:170:41: ( expression )?
                                    if (stream_expression.HasNext)
                                    {
                                        DebugLocation(170, 41);
                                        adaptor.AddChild(root_1, stream_expression.NextTree());

                                    }
                                    stream_expression.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("localOrFieldInit", 8);
                    LeaveRule("localOrFieldInit", 8);
                    LeaveRule_localOrFieldInit();
                }
                DebugLocation(170, 52);
            }
            finally { DebugExitRule(GrammarFileName, "localOrFieldInit"); }
            return retval;

        }
        // $ANTLR end "localOrFieldInit"

        partial void EnterRule_expression();
        partial void LeaveRule_expression();
        // $ANTLR start "expression"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:172:1: expression : ( let -> let | assig_expr -> assig_expr );
        [GrammarRule("expression")]
        private AstParserRuleReturnScope<object, IToken> expression()
        {
            EnterRule_expression();
            EnterRule("expression", 9);
            TraceIn("expression", 9);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            AstParserRuleReturnScope<object, IToken> let34 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> assig_expr35 = default(AstParserRuleReturnScope<object, IToken>);

            RewriteRuleSubtreeStream stream_assig_expr = new RewriteRuleSubtreeStream(adaptor, "rule assig_expr");
            RewriteRuleSubtreeStream stream_let = new RewriteRuleSubtreeStream(adaptor, "rule let");
            try
            {
                DebugEnterRule(GrammarFileName, "expression");
                DebugLocation(172, 44);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:172:12: ( let -> let | assig_expr -> assig_expr )
                    int alt8 = 2;
                    try
                    {
                        DebugEnterDecision(8, false);
                        int LA8_1 = input.LA(1);

                        if ((LA8_1 == LET))
                        {
                            alt8 = 1;
                        }
                        else if ((LA8_1 == CASE || LA8_1 == DO || LA8_1 == FALSE || LA8_1 == IF || (LA8_1 >= INTEGER && LA8_1 <= ISVOID) || LA8_1 == LKEY || LA8_1 == LPAREN || (LA8_1 >= NEG && LA8_1 <= OBJ_ID) || LA8_1 == SELF || LA8_1 == STRING || LA8_1 == TRUE || LA8_1 == WHILE))
                        {
                            alt8 = 2;
                        }
                        else
                        {
                            NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
                            DebugRecognitionException(nvae);
                            throw nvae;
                        }
                    }
                    finally { DebugExitDecision(8); }
                    switch (alt8)
                    {
                        case 1:
                            DebugEnterAlt(1);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:173:9: let
                            {
                                DebugLocation(173, 9);
                                PushFollow(Follow._let_in_expression1191);
                                let34 = let();
                                PopFollow();

                                stream_let.Add(let34.Tree);


                                {
                                    // AST REWRITE
                                    // elements: let
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 173:13: -> let
                                    {
                                        DebugLocation(173, 15);
                                        adaptor.AddChild(root_0, stream_let.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 2:
                            DebugEnterAlt(2);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:173:21: assig_expr
                            {
                                DebugLocation(173, 21);
                                PushFollow(Follow._assig_expr_in_expression1198);
                                assig_expr35 = assig_expr();
                                PopFollow();

                                stream_assig_expr.Add(assig_expr35.Tree);


                                {
                                    // AST REWRITE
                                    // elements: assig_expr
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 173:32: -> assig_expr
                                    {
                                        DebugLocation(173, 35);
                                        adaptor.AddChild(root_0, stream_assig_expr.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;

                    }
                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("expression", 9);
                    LeaveRule("expression", 9);
                    LeaveRule_expression();
                }
                DebugLocation(173, 44);
            }
            finally { DebugExitRule(GrammarFileName, "expression"); }
            return retval;

        }
        // $ANTLR end "expression"

        partial void EnterRule_assig_expr();
        partial void LeaveRule_assig_expr();
        // $ANTLR start "assig_expr"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:175:1: assig_expr : ( OBJ_ID ASSIGN ^)* not_expr ;
        [GrammarRule("assig_expr")]
        private AstParserRuleReturnScope<object, IToken> assig_expr()
        {
            EnterRule_assig_expr();
            EnterRule("assig_expr", 10);
            TraceIn("assig_expr", 10);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken OBJ_ID36 = default(IToken);
            IToken ASSIGN37 = default(IToken);
            AstParserRuleReturnScope<object, IToken> not_expr38 = default(AstParserRuleReturnScope<object, IToken>);

            object OBJ_ID36_tree = default(object);
            object ASSIGN37_tree = default(object);
            try
            {
                DebugEnterRule(GrammarFileName, "assig_expr");
                DebugLocation(175, 34);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:175:12: ( ( OBJ_ID ASSIGN ^)* not_expr )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:176:7: ( OBJ_ID ASSIGN ^)* not_expr
                    {
                        root_0 = (object)adaptor.Nil();

                        DebugLocation(176, 7);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:176:7: ( OBJ_ID ASSIGN ^)*
                        try
                        {
                            DebugEnterSubRule(9);
                            while (true)
                            {
                                int alt9 = 2;
                                try
                                {
                                    DebugEnterDecision(9, false);
                                    int LA9_1 = input.LA(1);

                                    if ((LA9_1 == OBJ_ID))
                                    {
                                        int LA9_2 = input.LA(2);

                                        if ((LA9_2 == ASSIGN))
                                        {
                                            alt9 = 1;
                                        }


                                    }


                                }
                                finally { DebugExitDecision(9); }
                                switch (alt9)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:176:8: OBJ_ID ASSIGN ^
                                        {
                                            DebugLocation(176, 8);
                                            OBJ_ID36 = (IToken)Match(input, OBJ_ID, Follow._OBJ_ID_in_assig_expr1217);
                                            OBJ_ID36_tree = (object)adaptor.Create(OBJ_ID36);
                                            adaptor.AddChild(root_0, OBJ_ID36_tree);
                                            DebugLocation(176, 21);
                                            ASSIGN37 = (IToken)Match(input, ASSIGN, Follow._ASSIGN_in_assig_expr1219);
                                            ASSIGN37_tree = (object)adaptor.Create(ASSIGN37);
                                            root_0 = (object)adaptor.BecomeRoot(ASSIGN37_tree, root_0);

                                        }
                                        break;

                                    default:
                                        goto loop9;
                                }
                            }

                        loop9:
                            ;

                        }
                        finally { DebugExitSubRule(9); }

                        DebugLocation(176, 27);
                        PushFollow(Follow._not_expr_in_assig_expr1226);
                        not_expr38 = not_expr();
                        PopFollow();

                        adaptor.AddChild(root_0, not_expr38.Tree);

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("assig_expr", 10);
                    LeaveRule("assig_expr", 10);
                    LeaveRule_assig_expr();
                }
                DebugLocation(176, 34);
            }
            finally { DebugExitRule(GrammarFileName, "assig_expr"); }
            return retval;

        }
        // $ANTLR end "assig_expr"

        partial void EnterRule_not_expr();
        partial void LeaveRule_not_expr();
        // $ANTLR start "not_expr"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:178:1: not_expr : ( NOT ^)* relation ;
        [GrammarRule("not_expr")]
        private AstParserRuleReturnScope<object, IToken> not_expr()
        {
            EnterRule_not_expr();
            EnterRule("not_expr", 11);
            TraceIn("not_expr", 11);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken NOT39 = default(IToken);
            AstParserRuleReturnScope<object, IToken> relation40 = default(AstParserRuleReturnScope<object, IToken>);

            object NOT39_tree = default(object);
            try
            {
                DebugEnterRule(GrammarFileName, "not_expr");
                DebugLocation(178, 23);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:178:10: ( ( NOT ^)* relation )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:179:6: ( NOT ^)* relation
                    {
                        root_0 = (object)adaptor.Nil();

                        DebugLocation(179, 6);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:179:6: ( NOT ^)*
                        try
                        {
                            DebugEnterSubRule(10);
                            while (true)
                            {
                                int alt10 = 2;
                                try
                                {
                                    DebugEnterDecision(10, false);
                                    int LA10_1 = input.LA(1);

                                    if ((LA10_1 == NOT))
                                    {
                                        alt10 = 1;
                                    }


                                }
                                finally { DebugExitDecision(10); }
                                switch (alt10)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:179:7: NOT ^
                                        {
                                            DebugLocation(179, 10);
                                            NOT39 = (IToken)Match(input, NOT, Follow._NOT_in_not_expr1240);
                                            NOT39_tree = (object)adaptor.Create(NOT39);
                                            root_0 = (object)adaptor.BecomeRoot(NOT39_tree, root_0);

                                        }
                                        break;

                                    default:
                                        goto loop10;
                                }
                            }

                        loop10:
                            ;

                        }
                        finally { DebugExitSubRule(10); }

                        DebugLocation(179, 16);
                        PushFollow(Follow._relation_in_not_expr1247);
                        relation40 = relation();
                        PopFollow();

                        adaptor.AddChild(root_0, relation40.Tree);

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("not_expr", 11);
                    LeaveRule("not_expr", 11);
                    LeaveRule_not_expr();
                }
                DebugLocation(179, 23);
            }
            finally { DebugExitRule(GrammarFileName, "not_expr"); }
            return retval;

        }
        // $ANTLR end "not_expr"

        partial void EnterRule_relation();
        partial void LeaveRule_relation();
        // $ANTLR start "relation"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:181:1: relation : ( compare_expr ) ( ( OR ^| AND ^) compare_expr )* ;
        [GrammarRule("relation")]
        private AstParserRuleReturnScope<object, IToken> relation()
        {
            EnterRule_relation();
            EnterRule("relation", 12);
            TraceIn("relation", 12);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken OR42 = default(IToken);
            IToken AND43 = default(IToken);
            AstParserRuleReturnScope<object, IToken> compare_expr41 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> compare_expr44 = default(AstParserRuleReturnScope<object, IToken>);

            object OR42_tree = default(object);
            object AND43_tree = default(object);
            try
            {
                DebugEnterRule(GrammarFileName, "relation");
                DebugLocation(181, 51);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:181:10: ( ( compare_expr ) ( ( OR ^| AND ^) compare_expr )* )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:182:9: ( compare_expr ) ( ( OR ^| AND ^) compare_expr )*
                    {
                        root_0 = (object)adaptor.Nil();

                        DebugLocation(182, 9);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:182:9: ( compare_expr )
                        DebugEnterAlt(1);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:182:10: compare_expr
                        {
                            DebugLocation(182, 10);
                            PushFollow(Follow._compare_expr_in_relation1266);
                            compare_expr41 = compare_expr();
                            PopFollow();

                            adaptor.AddChild(root_0, compare_expr41.Tree);

                        }

                        DebugLocation(182, 25);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:182:25: ( ( OR ^| AND ^) compare_expr )*
                        try
                        {
                            DebugEnterSubRule(12);
                            while (true)
                            {
                                int alt12 = 2;
                                try
                                {
                                    DebugEnterDecision(12, false);
                                    int LA12_1 = input.LA(1);

                                    if ((LA12_1 == AND || LA12_1 == OR))
                                    {
                                        alt12 = 1;
                                    }


                                }
                                finally { DebugExitDecision(12); }
                                switch (alt12)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:182:26: ( OR ^| AND ^) compare_expr
                                        {
                                            DebugLocation(182, 26);
                                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:182:26: ( OR ^| AND ^)
                                            int alt11 = 2;
                                            try
                                            {
                                                DebugEnterSubRule(11);
                                                try
                                                {
                                                    DebugEnterDecision(11, false);
                                                    int LA11_1 = input.LA(1);

                                                    if ((LA11_1 == OR))
                                                    {
                                                        alt11 = 1;
                                                    }
                                                    else if ((LA11_1 == AND))
                                                    {
                                                        alt11 = 2;
                                                    }
                                                    else
                                                    {
                                                        NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
                                                        DebugRecognitionException(nvae);
                                                        throw nvae;
                                                    }
                                                }
                                                finally { DebugExitDecision(11); }
                                                switch (alt11)
                                                {
                                                    case 1:
                                                        DebugEnterAlt(1);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:182:27: OR ^
                                                        {
                                                            DebugLocation(182, 29);
                                                            OR42 = (IToken)Match(input, OR, Follow._OR_in_relation1272);
                                                            OR42_tree = (object)adaptor.Create(OR42);
                                                            root_0 = (object)adaptor.BecomeRoot(OR42_tree, root_0);

                                                        }
                                                        break;
                                                    case 2:
                                                        DebugEnterAlt(2);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:182:31: AND ^
                                                        {
                                                            DebugLocation(182, 34);
                                                            AND43 = (IToken)Match(input, AND, Follow._AND_in_relation1275);
                                                            AND43_tree = (object)adaptor.Create(AND43);
                                                            root_0 = (object)adaptor.BecomeRoot(AND43_tree, root_0);

                                                        }
                                                        break;

                                                }
                                            }
                                            finally { DebugExitSubRule(11); }

                                            DebugLocation(182, 38);
                                            PushFollow(Follow._compare_expr_in_relation1280);
                                            compare_expr44 = compare_expr();
                                            PopFollow();

                                            adaptor.AddChild(root_0, compare_expr44.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop12;
                                }
                            }

                        loop12:
                            ;

                        }
                        finally { DebugExitSubRule(12); }


                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("relation", 12);
                    LeaveRule("relation", 12);
                    LeaveRule_relation();
                }
                DebugLocation(182, 51);
            }
            finally { DebugExitRule(GrammarFileName, "relation"); }
            return retval;

        }
        // $ANTLR end "relation"

        partial void EnterRule_compare_expr();
        partial void LeaveRule_compare_expr();
        // $ANTLR start "compare_expr"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:184:1: compare_expr : ( arith_expr ) ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) arith_expr )* ;
        [GrammarRule("compare_expr")]
        private AstParserRuleReturnScope<object, IToken> compare_expr()
        {
            EnterRule_compare_expr();
            EnterRule("compare_expr", 13);
            TraceIn("compare_expr", 13);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken LE46 = default(IToken);
            IToken LT47 = default(IToken);
            IToken GE48 = default(IToken);
            IToken GT49 = default(IToken);
            IToken EQUAL50 = default(IToken);
            AstParserRuleReturnScope<object, IToken> arith_expr45 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> arith_expr51 = default(AstParserRuleReturnScope<object, IToken>);

            object LE46_tree = default(object);
            object LT47_tree = default(object);
            object GE48_tree = default(object);
            object GT49_tree = default(object);
            object EQUAL50_tree = default(object);
            try
            {
                DebugEnterRule(GrammarFileName, "compare_expr");
                DebugLocation(184, 64);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:184:14: ( ( arith_expr ) ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) arith_expr )* )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:6: ( arith_expr ) ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) arith_expr )*
                    {
                        root_0 = (object)adaptor.Nil();

                        DebugLocation(185, 6);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:6: ( arith_expr )
                        DebugEnterAlt(1);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:7: arith_expr
                        {
                            DebugLocation(185, 7);
                            PushFollow(Follow._arith_expr_in_compare_expr1296);
                            arith_expr45 = arith_expr();
                            PopFollow();

                            adaptor.AddChild(root_0, arith_expr45.Tree);

                        }

                        DebugLocation(185, 19);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:19: ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) arith_expr )*
                        try
                        {
                            DebugEnterSubRule(14);
                            while (true)
                            {
                                int alt14 = 2;
                                try
                                {
                                    DebugEnterDecision(14, false);
                                    int LA14_1 = input.LA(1);

                                    if ((LA14_1 == EQUAL || (LA14_1 >= GE && LA14_1 <= GT) || LA14_1 == LE || LA14_1 == LT))
                                    {
                                        alt14 = 1;
                                    }


                                }
                                finally { DebugExitDecision(14); }
                                switch (alt14)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:21: ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) arith_expr
                                        {
                                            DebugLocation(185, 21);
                                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:21: ( LE ^| LT ^| GE ^| GT ^| EQUAL ^)
                                            int alt13 = 5;
                                            try
                                            {
                                                DebugEnterSubRule(13);
                                                try
                                                {
                                                    DebugEnterDecision(13, false);
                                                    switch (input.LA(1))
                                                    {
                                                        case LE:
                                                            {
                                                                alt13 = 1;
                                                            }
                                                            break;
                                                        case LT:
                                                            {
                                                                alt13 = 2;
                                                            }
                                                            break;
                                                        case GE:
                                                            {
                                                                alt13 = 3;
                                                            }
                                                            break;
                                                        case GT:
                                                            {
                                                                alt13 = 4;
                                                            }
                                                            break;
                                                        case EQUAL:
                                                            {
                                                                alt13 = 5;
                                                            }
                                                            break;
                                                        default:
                                                            {
                                                                NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
                                                                DebugRecognitionException(nvae);
                                                                throw nvae;
                                                            }
                                                    }

                                                }
                                                finally { DebugExitDecision(13); }
                                                switch (alt13)
                                                {
                                                    case 1:
                                                        DebugEnterAlt(1);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:23: LE ^
                                                        {
                                                            DebugLocation(185, 25);
                                                            LE46 = (IToken)Match(input, LE, Follow._LE_in_compare_expr1303);
                                                            LE46_tree = (object)adaptor.Create(LE46);
                                                            root_0 = (object)adaptor.BecomeRoot(LE46_tree, root_0);

                                                        }
                                                        break;
                                                    case 2:
                                                        DebugEnterAlt(2);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:28: LT ^
                                                        {
                                                            DebugLocation(185, 30);
                                                            LT47 = (IToken)Match(input, LT, Follow._LT_in_compare_expr1307);
                                                            LT47_tree = (object)adaptor.Create(LT47);
                                                            root_0 = (object)adaptor.BecomeRoot(LT47_tree, root_0);

                                                        }
                                                        break;
                                                    case 3:
                                                        DebugEnterAlt(3);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:33: GE ^
                                                        {
                                                            DebugLocation(185, 35);
                                                            GE48 = (IToken)Match(input, GE, Follow._GE_in_compare_expr1311);
                                                            GE48_tree = (object)adaptor.Create(GE48);
                                                            root_0 = (object)adaptor.BecomeRoot(GE48_tree, root_0);

                                                        }
                                                        break;
                                                    case 4:
                                                        DebugEnterAlt(4);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:38: GT ^
                                                        {
                                                            DebugLocation(185, 40);
                                                            GT49 = (IToken)Match(input, GT, Follow._GT_in_compare_expr1315);
                                                            GT49_tree = (object)adaptor.Create(GT49);
                                                            root_0 = (object)adaptor.BecomeRoot(GT49_tree, root_0);

                                                        }
                                                        break;
                                                    case 5:
                                                        DebugEnterAlt(5);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:185:44: EQUAL ^
                                                        {
                                                            DebugLocation(185, 49);
                                                            EQUAL50 = (IToken)Match(input, EQUAL, Follow._EQUAL_in_compare_expr1320);
                                                            EQUAL50_tree = (object)adaptor.Create(EQUAL50);
                                                            root_0 = (object)adaptor.BecomeRoot(EQUAL50_tree, root_0);

                                                        }
                                                        break;

                                                }
                                            }
                                            finally { DebugExitSubRule(13); }

                                            DebugLocation(185, 53);
                                            PushFollow(Follow._arith_expr_in_compare_expr1325);
                                            arith_expr51 = arith_expr();
                                            PopFollow();

                                            adaptor.AddChild(root_0, arith_expr51.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop14;
                                }
                            }

                        loop14:
                            ;

                        }
                        finally { DebugExitSubRule(14); }


                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("compare_expr", 13);
                    LeaveRule("compare_expr", 13);
                    LeaveRule_compare_expr();
                }
                DebugLocation(185, 64);
            }
            finally { DebugExitRule(GrammarFileName, "compare_expr"); }
            return retval;

        }
        // $ANTLR end "compare_expr"

        partial void EnterRule_arith_expr();
        partial void LeaveRule_arith_expr();
        // $ANTLR start "arith_expr"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:187:1: arith_expr : ( mult_expr ) ( ( PLUS ^| MINUS ^) mult_expr )* ;
        [GrammarRule("arith_expr")]
        private AstParserRuleReturnScope<object, IToken> arith_expr()
        {
            EnterRule_arith_expr();
            EnterRule("arith_expr", 14);
            TraceIn("arith_expr", 14);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken PLUS53 = default(IToken);
            IToken MINUS54 = default(IToken);
            AstParserRuleReturnScope<object, IToken> mult_expr52 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> mult_expr55 = default(AstParserRuleReturnScope<object, IToken>);

            object PLUS53_tree = default(object);
            object MINUS54_tree = default(object);
            try
            {
                DebugEnterRule(GrammarFileName, "arith_expr");
                DebugLocation(187, 49);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:187:12: ( ( mult_expr ) ( ( PLUS ^| MINUS ^) mult_expr )* )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:188:9: ( mult_expr ) ( ( PLUS ^| MINUS ^) mult_expr )*
                    {
                        root_0 = (object)adaptor.Nil();

                        DebugLocation(188, 9);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:188:9: ( mult_expr )
                        DebugEnterAlt(1);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:188:10: mult_expr
                        {
                            DebugLocation(188, 10);
                            PushFollow(Follow._mult_expr_in_arith_expr1346);
                            mult_expr52 = mult_expr();
                            PopFollow();

                            adaptor.AddChild(root_0, mult_expr52.Tree);

                        }

                        DebugLocation(188, 21);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:188:21: ( ( PLUS ^| MINUS ^) mult_expr )*
                        try
                        {
                            DebugEnterSubRule(16);
                            while (true)
                            {
                                int alt16 = 2;
                                try
                                {
                                    DebugEnterDecision(16, false);
                                    int LA16_1 = input.LA(1);

                                    if ((LA16_1 == MINUS || LA16_1 == PLUS))
                                    {
                                        alt16 = 1;
                                    }


                                }
                                finally { DebugExitDecision(16); }
                                switch (alt16)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:188:22: ( PLUS ^| MINUS ^) mult_expr
                                        {
                                            DebugLocation(188, 22);
                                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:188:22: ( PLUS ^| MINUS ^)
                                            int alt15 = 2;
                                            try
                                            {
                                                DebugEnterSubRule(15);
                                                try
                                                {
                                                    DebugEnterDecision(15, false);
                                                    int LA15_1 = input.LA(1);

                                                    if ((LA15_1 == PLUS))
                                                    {
                                                        alt15 = 1;
                                                    }
                                                    else if ((LA15_1 == MINUS))
                                                    {
                                                        alt15 = 2;
                                                    }
                                                    else
                                                    {
                                                        NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
                                                        DebugRecognitionException(nvae);
                                                        throw nvae;
                                                    }
                                                }
                                                finally { DebugExitDecision(15); }
                                                switch (alt15)
                                                {
                                                    case 1:
                                                        DebugEnterAlt(1);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:188:24: PLUS ^
                                                        {
                                                            DebugLocation(188, 28);
                                                            PLUS53 = (IToken)Match(input, PLUS, Follow._PLUS_in_arith_expr1352);
                                                            PLUS53_tree = (object)adaptor.Create(PLUS53);
                                                            root_0 = (object)adaptor.BecomeRoot(PLUS53_tree, root_0);

                                                        }
                                                        break;
                                                    case 2:
                                                        DebugEnterAlt(2);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:188:31: MINUS ^
                                                        {
                                                            DebugLocation(188, 36);
                                                            MINUS54 = (IToken)Match(input, MINUS, Follow._MINUS_in_arith_expr1356);
                                                            MINUS54_tree = (object)adaptor.Create(MINUS54);
                                                            root_0 = (object)adaptor.BecomeRoot(MINUS54_tree, root_0);

                                                        }
                                                        break;

                                                }
                                            }
                                            finally { DebugExitSubRule(15); }

                                            DebugLocation(188, 39);
                                            PushFollow(Follow._mult_expr_in_arith_expr1360);
                                            mult_expr55 = mult_expr();
                                            PopFollow();

                                            adaptor.AddChild(root_0, mult_expr55.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop16;
                                }
                            }

                        loop16:
                            ;

                        }
                        finally { DebugExitSubRule(16); }


                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("arith_expr", 14);
                    LeaveRule("arith_expr", 14);
                    LeaveRule_arith_expr();
                }
                DebugLocation(188, 49);
            }
            finally { DebugExitRule(GrammarFileName, "arith_expr"); }
            return retval;

        }
        // $ANTLR end "arith_expr"

        partial void EnterRule_mult_expr();
        partial void LeaveRule_mult_expr();
        // $ANTLR start "mult_expr"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:190:1: mult_expr : ( isVoid_expr ) ( ( MULT ^| DIV ^) isVoid_expr )* ;
        [GrammarRule("mult_expr")]
        private AstParserRuleReturnScope<object, IToken> mult_expr()
        {
            EnterRule_mult_expr();
            EnterRule("mult_expr", 15);
            TraceIn("mult_expr", 15);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken MULT57 = default(IToken);
            IToken DIV58 = default(IToken);
            AstParserRuleReturnScope<object, IToken> isVoid_expr56 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> isVoid_expr59 = default(AstParserRuleReturnScope<object, IToken>);

            object MULT57_tree = default(object);
            object DIV58_tree = default(object);
            try
            {
                DebugEnterRule(GrammarFileName, "mult_expr");
                DebugLocation(190, 51);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:190:11: ( ( isVoid_expr ) ( ( MULT ^| DIV ^) isVoid_expr )* )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:191:6: ( isVoid_expr ) ( ( MULT ^| DIV ^) isVoid_expr )*
                    {
                        root_0 = (object)adaptor.Nil();

                        DebugLocation(191, 6);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:191:6: ( isVoid_expr )
                        DebugEnterAlt(1);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:191:7: isVoid_expr
                        {
                            DebugLocation(191, 7);
                            PushFollow(Follow._isVoid_expr_in_mult_expr1376);
                            isVoid_expr56 = isVoid_expr();
                            PopFollow();

                            adaptor.AddChild(root_0, isVoid_expr56.Tree);

                        }

                        DebugLocation(191, 20);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:191:20: ( ( MULT ^| DIV ^) isVoid_expr )*
                        try
                        {
                            DebugEnterSubRule(18);
                            while (true)
                            {
                                int alt18 = 2;
                                try
                                {
                                    DebugEnterDecision(18, false);
                                    int LA18_1 = input.LA(1);

                                    if ((LA18_1 == DIV || LA18_1 == MULT))
                                    {
                                        alt18 = 1;
                                    }


                                }
                                finally { DebugExitDecision(18); }
                                switch (alt18)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:191:22: ( MULT ^| DIV ^) isVoid_expr
                                        {
                                            DebugLocation(191, 22);
                                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:191:22: ( MULT ^| DIV ^)
                                            int alt17 = 2;
                                            try
                                            {
                                                DebugEnterSubRule(17);
                                                try
                                                {
                                                    DebugEnterDecision(17, false);
                                                    int LA17_1 = input.LA(1);

                                                    if ((LA17_1 == MULT))
                                                    {
                                                        alt17 = 1;
                                                    }
                                                    else if ((LA17_1 == DIV))
                                                    {
                                                        alt17 = 2;
                                                    }
                                                    else
                                                    {
                                                        NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
                                                        DebugRecognitionException(nvae);
                                                        throw nvae;
                                                    }
                                                }
                                                finally { DebugExitDecision(17); }
                                                switch (alt17)
                                                {
                                                    case 1:
                                                        DebugEnterAlt(1);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:191:23: MULT ^
                                                        {
                                                            DebugLocation(191, 27);
                                                            MULT57 = (IToken)Match(input, MULT, Follow._MULT_in_mult_expr1382);
                                                            MULT57_tree = (object)adaptor.Create(MULT57);
                                                            root_0 = (object)adaptor.BecomeRoot(MULT57_tree, root_0);

                                                        }
                                                        break;
                                                    case 2:
                                                        DebugEnterAlt(2);
                                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:191:31: DIV ^
                                                        {
                                                            DebugLocation(191, 35);
                                                            DIV58 = (IToken)Match(input, DIV, Follow._DIV_in_mult_expr1387);
                                                            DIV58_tree = (object)adaptor.Create(DIV58);
                                                            root_0 = (object)adaptor.BecomeRoot(DIV58_tree, root_0);

                                                        }
                                                        break;

                                                }
                                            }
                                            finally { DebugExitSubRule(17); }

                                            DebugLocation(191, 38);
                                            PushFollow(Follow._isVoid_expr_in_mult_expr1392);
                                            isVoid_expr59 = isVoid_expr();
                                            PopFollow();

                                            adaptor.AddChild(root_0, isVoid_expr59.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop18;
                                }
                            }

                        loop18:
                            ;

                        }
                        finally { DebugExitSubRule(18); }


                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("mult_expr", 15);
                    LeaveRule("mult_expr", 15);
                    LeaveRule_mult_expr();
                }
                DebugLocation(191, 51);
            }
            finally { DebugExitRule(GrammarFileName, "mult_expr"); }
            return retval;

        }
        // $ANTLR end "mult_expr"

        partial void EnterRule_isVoid_expr();
        partial void LeaveRule_isVoid_expr();
        // $ANTLR start "isVoid_expr"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:193:1: isVoid_expr : ( ISVOID ^)* neg_expr ;
        [GrammarRule("isVoid_expr")]
        private AstParserRuleReturnScope<object, IToken> isVoid_expr()
        {
            EnterRule_isVoid_expr();
            EnterRule("isVoid_expr", 16);
            TraceIn("isVoid_expr", 16);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken ISVOID60 = default(IToken);
            AstParserRuleReturnScope<object, IToken> neg_expr61 = default(AstParserRuleReturnScope<object, IToken>);

            object ISVOID60_tree = default(object);
            try
            {
                DebugEnterRule(GrammarFileName, "isVoid_expr");
                DebugLocation(193, 25);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:193:13: ( ( ISVOID ^)* neg_expr )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:194:6: ( ISVOID ^)* neg_expr
                    {
                        root_0 = (object)adaptor.Nil();

                        DebugLocation(194, 6);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:194:6: ( ISVOID ^)*
                        try
                        {
                            DebugEnterSubRule(19);
                            while (true)
                            {
                                int alt19 = 2;
                                try
                                {
                                    DebugEnterDecision(19, false);
                                    int LA19_1 = input.LA(1);

                                    if ((LA19_1 == ISVOID))
                                    {
                                        alt19 = 1;
                                    }


                                }
                                finally { DebugExitDecision(19); }
                                switch (alt19)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:194:7: ISVOID ^
                                        {
                                            DebugLocation(194, 13);
                                            ISVOID60 = (IToken)Match(input, ISVOID, Follow._ISVOID_in_isVoid_expr1409);
                                            ISVOID60_tree = (object)adaptor.Create(ISVOID60);
                                            root_0 = (object)adaptor.BecomeRoot(ISVOID60_tree, root_0);

                                        }
                                        break;

                                    default:
                                        goto loop19;
                                }
                            }

                        loop19:
                            ;

                        }
                        finally { DebugExitSubRule(19); }

                        DebugLocation(194, 18);
                        PushFollow(Follow._neg_expr_in_isVoid_expr1415);
                        neg_expr61 = neg_expr();
                        PopFollow();

                        adaptor.AddChild(root_0, neg_expr61.Tree);

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("isVoid_expr", 16);
                    LeaveRule("isVoid_expr", 16);
                    LeaveRule_isVoid_expr();
                }
                DebugLocation(194, 25);
            }
            finally { DebugExitRule(GrammarFileName, "isVoid_expr"); }
            return retval;

        }
        // $ANTLR end "isVoid_expr"

        partial void EnterRule_neg_expr();
        partial void LeaveRule_neg_expr();
        // $ANTLR start "neg_expr"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:196:1: neg_expr : ( NEG ^)* dot_expr ;
        [GrammarRule("neg_expr")]
        private AstParserRuleReturnScope<object, IToken> neg_expr()
        {
            EnterRule_neg_expr();
            EnterRule("neg_expr", 17);
            TraceIn("neg_expr", 17);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken NEG62 = default(IToken);
            AstParserRuleReturnScope<object, IToken> dot_expr63 = default(AstParserRuleReturnScope<object, IToken>);

            object NEG62_tree = default(object);
            try
            {
                DebugEnterRule(GrammarFileName, "neg_expr");
                DebugLocation(196, 23);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:196:10: ( ( NEG ^)* dot_expr )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:197:6: ( NEG ^)* dot_expr
                    {
                        root_0 = (object)adaptor.Nil();

                        DebugLocation(197, 6);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:197:6: ( NEG ^)*
                        try
                        {
                            DebugEnterSubRule(20);
                            while (true)
                            {
                                int alt20 = 2;
                                try
                                {
                                    DebugEnterDecision(20, false);
                                    int LA20_1 = input.LA(1);

                                    if ((LA20_1 == NEG))
                                    {
                                        alt20 = 1;
                                    }


                                }
                                finally { DebugExitDecision(20); }
                                switch (alt20)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:197:7: NEG ^
                                        {
                                            DebugLocation(197, 10);
                                            NEG62 = (IToken)Match(input, NEG, Follow._NEG_in_neg_expr1429);
                                            NEG62_tree = (object)adaptor.Create(NEG62);
                                            root_0 = (object)adaptor.BecomeRoot(NEG62_tree, root_0);

                                        }
                                        break;

                                    default:
                                        goto loop20;
                                }
                            }

                        loop20:
                            ;

                        }
                        finally { DebugExitSubRule(20); }

                        DebugLocation(197, 16);
                        PushFollow(Follow._dot_expr_in_neg_expr1436);
                        dot_expr63 = dot_expr();
                        PopFollow();

                        adaptor.AddChild(root_0, dot_expr63.Tree);

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("neg_expr", 17);
                    LeaveRule("neg_expr", 17);
                    LeaveRule_neg_expr();
                }
                DebugLocation(197, 23);
            }
            finally { DebugExitRule(GrammarFileName, "neg_expr"); }
            return retval;

        }
        // $ANTLR end "neg_expr"

        partial void EnterRule_dot_expr();
        partial void LeaveRule_dot_expr();
        // $ANTLR start "dot_expr"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:199:1: dot_expr : ( term -> term ) ( ATSIGN TYPE_ID DOT call_expr -> ^( DotTypeInvoke $dot_expr TYPE_ID call_expr ) | DOT call_expr -> ^( DotObjectInvoke $dot_expr call_expr ) )* ;
        [GrammarRule("dot_expr")]
        private AstParserRuleReturnScope<object, IToken> dot_expr()
        {
            EnterRule_dot_expr();
            EnterRule("dot_expr", 18);
            TraceIn("dot_expr", 18);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken ATSIGN65 = default(IToken);
            IToken TYPE_ID66 = default(IToken);
            IToken DOT67 = default(IToken);
            IToken DOT69 = default(IToken);
            AstParserRuleReturnScope<object, IToken> term64 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> call_expr68 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> call_expr70 = default(AstParserRuleReturnScope<object, IToken>);

            object ATSIGN65_tree = default(object);
            object TYPE_ID66_tree = default(object);
            object DOT67_tree = default(object);
            object DOT69_tree = default(object);
            RewriteRuleITokenStream stream_ATSIGN = new RewriteRuleITokenStream(adaptor, "token ATSIGN");
            RewriteRuleITokenStream stream_TYPE_ID = new RewriteRuleITokenStream(adaptor, "token TYPE_ID");
            RewriteRuleITokenStream stream_DOT = new RewriteRuleITokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_call_expr = new RewriteRuleSubtreeStream(adaptor, "rule call_expr");
            RewriteRuleSubtreeStream stream_term = new RewriteRuleSubtreeStream(adaptor, "rule term");
            try
            {
                DebugEnterRule(GrammarFileName, "dot_expr");
                DebugLocation(199, 48);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:199:10: ( ( term -> term ) ( ATSIGN TYPE_ID DOT call_expr -> ^( DotTypeInvoke $dot_expr TYPE_ID call_expr ) | DOT call_expr -> ^( DotObjectInvoke $dot_expr call_expr ) )* )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:200:9: ( term -> term ) ( ATSIGN TYPE_ID DOT call_expr -> ^( DotTypeInvoke $dot_expr TYPE_ID call_expr ) | DOT call_expr -> ^( DotObjectInvoke $dot_expr call_expr ) )*
                    {
                        DebugLocation(200, 9);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:200:9: ( term -> term )
                        DebugEnterAlt(1);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:200:11: term
                        {
                            DebugLocation(200, 11);
                            PushFollow(Follow._term_in_dot_expr1454);
                            term64 = term();
                            PopFollow();

                            stream_term.Add(term64.Tree);


                            {
                                // AST REWRITE
                                // elements: term
                                // token labels: 
                                // rule labels: retval
                                // token list labels: 
                                // rule list labels: 
                                // wildcard labels: 
                                retval.Tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                root_0 = (object)adaptor.Nil();
                                // 200:16: -> term
                                {
                                    DebugLocation(200, 19);
                                    adaptor.AddChild(root_0, stream_term.NextTree());

                                }

                                retval.Tree = root_0;
                            }

                        }

                        DebugLocation(201, 7);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:201:7: ( ATSIGN TYPE_ID DOT call_expr -> ^( DotTypeInvoke $dot_expr TYPE_ID call_expr ) | DOT call_expr -> ^( DotObjectInvoke $dot_expr call_expr ) )*
                        try
                        {
                            DebugEnterSubRule(21);
                            while (true)
                            {
                                int alt21 = 3;
                                try
                                {
                                    DebugEnterDecision(21, false);
                                    int LA21_1 = input.LA(1);

                                    if ((LA21_1 == ATSIGN))
                                    {
                                        alt21 = 1;
                                    }
                                    else if ((LA21_1 == DOT))
                                    {
                                        alt21 = 2;
                                    }


                                }
                                finally { DebugExitDecision(21); }
                                switch (alt21)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:201:8: ATSIGN TYPE_ID DOT call_expr
                                        {
                                            DebugLocation(201, 8);
                                            ATSIGN65 = (IToken)Match(input, ATSIGN, Follow._ATSIGN_in_dot_expr1470);
                                            stream_ATSIGN.Add(ATSIGN65);

                                            DebugLocation(201, 16);
                                            TYPE_ID66 = (IToken)Match(input, TYPE_ID, Follow._TYPE_ID_in_dot_expr1473);
                                            stream_TYPE_ID.Add(TYPE_ID66);

                                            DebugLocation(201, 24);
                                            DOT67 = (IToken)Match(input, DOT, Follow._DOT_in_dot_expr1475);
                                            stream_DOT.Add(DOT67);

                                            DebugLocation(201, 29);
                                            PushFollow(Follow._call_expr_in_dot_expr1478);
                                            call_expr68 = call_expr();
                                            PopFollow();

                                            stream_call_expr.Add(call_expr68.Tree);


                                            {
                                                // AST REWRITE
                                                // elements: dot_expr, TYPE_ID, call_expr
                                                // token labels: 
                                                // rule labels: retval
                                                // token list labels: 
                                                // rule list labels: 
                                                // wildcard labels: 
                                                retval.Tree = root_0;
                                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                                root_0 = (object)adaptor.Nil();
                                                // 201:40: -> ^( DotTypeInvoke $dot_expr TYPE_ID call_expr )
                                                {
                                                    DebugLocation(201, 43);
                                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:201:43: ^( DotTypeInvoke $dot_expr TYPE_ID call_expr )
                                                    {
                                                        object root_1 = (object)adaptor.Nil();
                                                        DebugLocation(201, 45);
                                                        root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DotTypeInvoke, "DotTypeInvoke"), root_1);

                                                        DebugLocation(201, 61);
                                                        adaptor.AddChild(root_1, stream_retval.NextTree());
                                                        DebugLocation(201, 71);
                                                        adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());
                                                        DebugLocation(201, 79);
                                                        adaptor.AddChild(root_1, stream_call_expr.NextTree());

                                                        adaptor.AddChild(root_0, root_1);
                                                    }

                                                }

                                                retval.Tree = root_0;
                                            }

                                        }
                                        break;
                                    case 2:
                                        DebugEnterAlt(2);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:202:6: DOT call_expr
                                        {
                                            DebugLocation(202, 6);
                                            DOT69 = (IToken)Match(input, DOT, Follow._DOT_in_dot_expr1501);
                                            stream_DOT.Add(DOT69);

                                            DebugLocation(202, 11);
                                            PushFollow(Follow._call_expr_in_dot_expr1504);
                                            call_expr70 = call_expr();
                                            PopFollow();

                                            stream_call_expr.Add(call_expr70.Tree);


                                            {
                                                // AST REWRITE
                                                // elements: dot_expr, call_expr
                                                // token labels: 
                                                // rule labels: retval
                                                // token list labels: 
                                                // rule list labels: 
                                                // wildcard labels: 
                                                retval.Tree = root_0;
                                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                                root_0 = (object)adaptor.Nil();
                                                // 203:4: -> ^( DotObjectInvoke $dot_expr call_expr )
                                                {
                                                    DebugLocation(203, 7);
                                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:203:7: ^( DotObjectInvoke $dot_expr call_expr )
                                                    {
                                                        object root_1 = (object)adaptor.Nil();
                                                        DebugLocation(203, 9);
                                                        root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DotObjectInvoke, "DotObjectInvoke"), root_1);

                                                        DebugLocation(203, 27);
                                                        adaptor.AddChild(root_1, stream_retval.NextTree());
                                                        DebugLocation(203, 37);
                                                        adaptor.AddChild(root_1, stream_call_expr.NextTree());

                                                        adaptor.AddChild(root_0, root_1);
                                                    }

                                                }

                                                retval.Tree = root_0;
                                            }

                                        }
                                        break;

                                    default:
                                        goto loop21;
                                }
                            }

                        loop21:
                            ;

                        }
                        finally { DebugExitSubRule(21); }


                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("dot_expr", 18);
                    LeaveRule("dot_expr", 18);
                    LeaveRule_dot_expr();
                }
                DebugLocation(203, 48);
            }
            finally { DebugExitRule(GrammarFileName, "dot_expr"); }
            return retval;

        }
        // $ANTLR end "dot_expr"

        partial void EnterRule_term();
        partial void LeaveRule_term();
        // $ANTLR start "term"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:205:1: term : ( call_expr -> call_expr | conditionals_expr -> conditionals_expr | loops -> loops | blocks -> blocks | case -> case | new -> new | LPAREN expression RPAREN -> expression | constants -> constants | identifiers -> identifiers );
        [GrammarRule("term")]
        private AstParserRuleReturnScope<object, IToken> term()
        {
            EnterRule_term();
            EnterRule("term", 19);
            TraceIn("term", 19);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken LPAREN77 = default(IToken);
            IToken RPAREN79 = default(IToken);
            AstParserRuleReturnScope<object, IToken> call_expr71 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> conditionals_expr72 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> loops73 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> blocks74 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> case75 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> new76 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> expression78 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> constants80 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> identifiers81 = default(AstParserRuleReturnScope<object, IToken>);

            object LPAREN77_tree = default(object);
            object RPAREN79_tree = default(object);
            RewriteRuleITokenStream stream_LPAREN = new RewriteRuleITokenStream(adaptor, "token LPAREN");
            RewriteRuleITokenStream stream_RPAREN = new RewriteRuleITokenStream(adaptor, "token RPAREN");
            RewriteRuleSubtreeStream stream_new = new RewriteRuleSubtreeStream(adaptor, "rule new");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            RewriteRuleSubtreeStream stream_blocks = new RewriteRuleSubtreeStream(adaptor, "rule blocks");
            RewriteRuleSubtreeStream stream_identifiers = new RewriteRuleSubtreeStream(adaptor, "rule identifiers");
            RewriteRuleSubtreeStream stream_call_expr = new RewriteRuleSubtreeStream(adaptor, "rule call_expr");
            RewriteRuleSubtreeStream stream_conditionals_expr = new RewriteRuleSubtreeStream(adaptor, "rule conditionals_expr");
            RewriteRuleSubtreeStream stream_loops = new RewriteRuleSubtreeStream(adaptor, "rule loops");
            RewriteRuleSubtreeStream stream_constants = new RewriteRuleSubtreeStream(adaptor, "rule constants");
            RewriteRuleSubtreeStream stream_case = new RewriteRuleSubtreeStream(adaptor, "rule case");
            try
            {
                DebugEnterRule(GrammarFileName, "term");
                DebugLocation(205, 29);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:205:6: ( call_expr -> call_expr | conditionals_expr -> conditionals_expr | loops -> loops | blocks -> blocks | case -> case | new -> new | LPAREN expression RPAREN -> expression | constants -> constants | identifiers -> identifiers )
                    int alt22 = 9;
                    try
                    {
                        DebugEnterDecision(22, false);
                        switch (input.LA(1))
                        {
                            case OBJ_ID:
                                {
                                    int LA22_2 = input.LA(2);

                                    if ((LA22_2 == LPAREN))
                                    {
                                        alt22 = 1;
                                    }
                                    else if ((LA22_2 == AND || LA22_2 == ATSIGN || LA22_2 == COMMA || LA22_2 == DIV || LA22_2 == DOT || (LA22_2 >= ELSE && LA22_2 <= EQUAL) || LA22_2 == FI || (LA22_2 >= GE && LA22_2 <= GT) || LA22_2 == IN || LA22_2 == LE || LA22_2 == LOOP || LA22_2 == LT || (LA22_2 >= MINUS && LA22_2 <= MULT) || (LA22_2 >= OD && LA22_2 <= POOL) || (LA22_2 >= RKEY && LA22_2 <= RPAREN) || LA22_2 == SEMI || LA22_2 == THEN || LA22_2 == WHILE))
                                    {
                                        alt22 = 9;
                                    }
                                    else
                                    {
                                        NoViableAltException nvae = new NoViableAltException("", 22, 1, input, 2);
                                        DebugRecognitionException(nvae);
                                        throw nvae;
                                    }
                                }
                                break;
                            case IF:
                                {
                                    alt22 = 2;
                                }
                                break;
                            case DO:
                            case WHILE:
                                {
                                    alt22 = 3;
                                }
                                break;
                            case LKEY:
                                {
                                    alt22 = 4;
                                }
                                break;
                            case CASE:
                                {
                                    alt22 = 5;
                                }
                                break;
                            case NEW:
                                {
                                    alt22 = 6;
                                }
                                break;
                            case LPAREN:
                                {
                                    alt22 = 7;
                                }
                                break;
                            case FALSE:
                            case INTEGER:
                            case STRING:
                            case TRUE:
                                {
                                    alt22 = 8;
                                }
                                break;
                            case SELF:
                                {
                                    alt22 = 9;
                                }
                                break;
                            default:
                                {
                                    NoViableAltException nvae = new NoViableAltException("", 22, 0, input, 1);
                                    DebugRecognitionException(nvae);
                                    throw nvae;
                                }
                        }

                    }
                    finally { DebugExitDecision(22); }
                    switch (alt22)
                    {
                        case 1:
                            DebugEnterAlt(1);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:206:9: call_expr
                            {
                                DebugLocation(206, 9);
                                PushFollow(Follow._call_expr_in_term1546);
                                call_expr71 = call_expr();
                                PopFollow();

                                stream_call_expr.Add(call_expr71.Tree);


                                {
                                    // AST REWRITE
                                    // elements: call_expr
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 206:19: -> call_expr
                                    {
                                        DebugLocation(206, 24);
                                        adaptor.AddChild(root_0, stream_call_expr.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 2:
                            DebugEnterAlt(2);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:207:4: conditionals_expr
                            {
                                DebugLocation(207, 4);
                                PushFollow(Follow._conditionals_expr_in_term1558);
                                conditionals_expr72 = conditionals_expr();
                                PopFollow();

                                stream_conditionals_expr.Add(conditionals_expr72.Tree);


                                {
                                    // AST REWRITE
                                    // elements: conditionals_expr
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 207:22: -> conditionals_expr
                                    {
                                        DebugLocation(207, 25);
                                        adaptor.AddChild(root_0, stream_conditionals_expr.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 3:
                            DebugEnterAlt(3);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:208:4: loops
                            {
                                DebugLocation(208, 4);
                                PushFollow(Follow._loops_in_term1568);
                                loops73 = loops();
                                PopFollow();

                                stream_loops.Add(loops73.Tree);


                                {
                                    // AST REWRITE
                                    // elements: loops
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 208:10: -> loops
                                    {
                                        DebugLocation(208, 13);
                                        adaptor.AddChild(root_0, stream_loops.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 4:
                            DebugEnterAlt(4);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:209:4: blocks
                            {
                                DebugLocation(209, 4);
                                PushFollow(Follow._blocks_in_term1577);
                                blocks74 = blocks();
                                PopFollow();

                                stream_blocks.Add(blocks74.Tree);


                                {
                                    // AST REWRITE
                                    // elements: blocks
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 209:11: -> blocks
                                    {
                                        DebugLocation(209, 14);
                                        adaptor.AddChild(root_0, stream_blocks.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 5:
                            DebugEnterAlt(5);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:210:4: case
                            {
                                DebugLocation(210, 4);
                                PushFollow(Follow._case_in_term1587);
                                case75 = @case();
                                PopFollow();

                                stream_case.Add(case75.Tree);


                                {
                                    // AST REWRITE
                                    // elements: case
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 210:9: -> case
                                    {
                                        DebugLocation(210, 12);
                                        adaptor.AddChild(root_0, stream_case.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 6:
                            DebugEnterAlt(6);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:211:4: new
                            {
                                DebugLocation(211, 4);
                                PushFollow(Follow._new_in_term1596);
                                new76 = @new();
                                PopFollow();

                                stream_new.Add(new76.Tree);


                                {
                                    // AST REWRITE
                                    // elements: new
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 211:8: -> new
                                    {
                                        DebugLocation(211, 11);
                                        adaptor.AddChild(root_0, stream_new.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 7:
                            DebugEnterAlt(7);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:212:4: LPAREN expression RPAREN
                            {
                                DebugLocation(212, 4);
                                LPAREN77 = (IToken)Match(input, LPAREN, Follow._LPAREN_in_term1605);
                                stream_LPAREN.Add(LPAREN77);

                                DebugLocation(212, 11);
                                PushFollow(Follow._expression_in_term1607);
                                expression78 = expression();
                                PopFollow();

                                stream_expression.Add(expression78.Tree);
                                DebugLocation(212, 22);
                                RPAREN79 = (IToken)Match(input, RPAREN, Follow._RPAREN_in_term1609);
                                stream_RPAREN.Add(RPAREN79);



                                {
                                    // AST REWRITE
                                    // elements: expression
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 212:29: -> expression
                                    {
                                        DebugLocation(212, 32);
                                        adaptor.AddChild(root_0, stream_expression.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 8:
                            DebugEnterAlt(8);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:213:4: constants
                            {
                                DebugLocation(213, 4);
                                PushFollow(Follow._constants_in_term1618);
                                constants80 = constants();
                                PopFollow();

                                stream_constants.Add(constants80.Tree);


                                {
                                    // AST REWRITE
                                    // elements: constants
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 213:14: -> constants
                                    {
                                        DebugLocation(213, 17);
                                        adaptor.AddChild(root_0, stream_constants.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 9:
                            DebugEnterAlt(9);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:214:4: identifiers
                            {
                                DebugLocation(214, 4);
                                PushFollow(Follow._identifiers_in_term1627);
                                identifiers81 = identifiers();
                                PopFollow();

                                stream_identifiers.Add(identifiers81.Tree);


                                {
                                    // AST REWRITE
                                    // elements: identifiers
                                    // token labels: 
                                    // rule labels: retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 214:16: -> identifiers
                                    {
                                        DebugLocation(214, 19);
                                        adaptor.AddChild(root_0, stream_identifiers.NextTree());

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;

                    }
                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("term", 19);
                    LeaveRule("term", 19);
                    LeaveRule_term();
                }
                DebugLocation(214, 29);
            }
            finally { DebugExitRule(GrammarFileName, "term"); }
            return retval;

        }
        // $ANTLR end "term"

        partial void EnterRule_identifiers();
        partial void LeaveRule_identifiers();
        // $ANTLR start "identifiers"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:1: identifiers : ( OBJ_ID ^| SELF ^);
        [GrammarRule("identifiers")]
        private AstParserRuleReturnScope<object, IToken> identifiers()
        {
            EnterRule_identifiers();
            EnterRule("identifiers", 20);
            TraceIn("identifiers", 20);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken OBJ_ID82 = default(IToken);
            IToken SELF83 = default(IToken);

            object OBJ_ID82_tree = default(object);
            object SELF83_tree = default(object);
            try
            {
                DebugEnterRule(GrammarFileName, "identifiers");
                DebugLocation(216, 20);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:216:13: ( OBJ_ID ^| SELF ^)
                    int alt23 = 2;
                    try
                    {
                        DebugEnterDecision(23, false);
                        int LA23_1 = input.LA(1);

                        if ((LA23_1 == OBJ_ID))
                        {
                            alt23 = 1;
                        }
                        else if ((LA23_1 == SELF))
                        {
                            alt23 = 2;
                        }
                        else
                        {
                            NoViableAltException nvae = new NoViableAltException("", 23, 0, input, 1);
                            DebugRecognitionException(nvae);
                            throw nvae;
                        }
                    }
                    finally { DebugExitDecision(23); }
                    switch (alt23)
                    {
                        case 1:
                            DebugEnterAlt(1);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:217:6: OBJ_ID ^
                            {
                                root_0 = (object)adaptor.Nil();

                                DebugLocation(217, 12);
                                OBJ_ID82 = (IToken)Match(input, OBJ_ID, Follow._OBJ_ID_in_identifiers1644);
                                OBJ_ID82_tree = (object)adaptor.Create(OBJ_ID82);
                                root_0 = (object)adaptor.BecomeRoot(OBJ_ID82_tree, root_0);

                            }
                            break;
                        case 2:
                            DebugEnterAlt(2);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:217:16: SELF ^
                            {
                                root_0 = (object)adaptor.Nil();

                                DebugLocation(217, 20);
                                SELF83 = (IToken)Match(input, SELF, Follow._SELF_in_identifiers1649);
                                SELF83_tree = (object)adaptor.Create(SELF83);
                                root_0 = (object)adaptor.BecomeRoot(SELF83_tree, root_0);

                            }
                            break;

                    }
                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("identifiers", 20);
                    LeaveRule("identifiers", 20);
                    LeaveRule_identifiers();
                }
                DebugLocation(217, 20);
            }
            finally { DebugExitRule(GrammarFileName, "identifiers"); }
            return retval;

        }
        // $ANTLR end "identifiers"

        partial void EnterRule_constants();
        partial void LeaveRule_constants();
        // $ANTLR start "constants"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:219:1: constants : ( TRUE ^| FALSE ^| INTEGER ^| STRING ^);
        [GrammarRule("constants")]
        private AstParserRuleReturnScope<object, IToken> constants()
        {
            EnterRule_constants();
            EnterRule("constants", 21);
            TraceIn("constants", 21);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken TRUE84 = default(IToken);
            IToken FALSE85 = default(IToken);
            IToken INTEGER86 = default(IToken);
            IToken STRING87 = default(IToken);

            object TRUE84_tree = default(object);
            object FALSE85_tree = default(object);
            object INTEGER86_tree = default(object);
            object STRING87_tree = default(object);
            try
            {
                DebugEnterRule(GrammarFileName, "constants");
                DebugLocation(219, 40);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:219:11: ( TRUE ^| FALSE ^| INTEGER ^| STRING ^)
                    int alt24 = 4;
                    try
                    {
                        DebugEnterDecision(24, false);
                        switch (input.LA(1))
                        {
                            case TRUE:
                                {
                                    alt24 = 1;
                                }
                                break;
                            case FALSE:
                                {
                                    alt24 = 2;
                                }
                                break;
                            case INTEGER:
                                {
                                    alt24 = 3;
                                }
                                break;
                            case STRING:
                                {
                                    alt24 = 4;
                                }
                                break;
                            default:
                                {
                                    NoViableAltException nvae = new NoViableAltException("", 24, 0, input, 1);
                                    DebugRecognitionException(nvae);
                                    throw nvae;
                                }
                        }

                    }
                    finally { DebugExitDecision(24); }
                    switch (alt24)
                    {
                        case 1:
                            DebugEnterAlt(1);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:220:6: TRUE ^
                            {
                                root_0 = (object)adaptor.Nil();

                                DebugLocation(220, 10);
                                TRUE84 = (IToken)Match(input, TRUE, Follow._TRUE_in_constants1663);
                                TRUE84_tree = (object)adaptor.Create(TRUE84);
                                root_0 = (object)adaptor.BecomeRoot(TRUE84_tree, root_0);

                            }
                            break;
                        case 2:
                            DebugEnterAlt(2);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:220:14: FALSE ^
                            {
                                root_0 = (object)adaptor.Nil();

                                DebugLocation(220, 19);
                                FALSE85 = (IToken)Match(input, FALSE, Follow._FALSE_in_constants1668);
                                FALSE85_tree = (object)adaptor.Create(FALSE85);
                                root_0 = (object)adaptor.BecomeRoot(FALSE85_tree, root_0);

                            }
                            break;
                        case 3:
                            DebugEnterAlt(3);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:220:23: INTEGER ^
                            {
                                root_0 = (object)adaptor.Nil();

                                DebugLocation(220, 30);
                                INTEGER86 = (IToken)Match(input, INTEGER, Follow._INTEGER_in_constants1673);
                                INTEGER86_tree = (object)adaptor.Create(INTEGER86);
                                root_0 = (object)adaptor.BecomeRoot(INTEGER86_tree, root_0);

                            }
                            break;
                        case 4:
                            DebugEnterAlt(4);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:220:34: STRING ^
                            {
                                root_0 = (object)adaptor.Nil();

                                DebugLocation(220, 40);
                                STRING87 = (IToken)Match(input, STRING, Follow._STRING_in_constants1678);
                                STRING87_tree = (object)adaptor.Create(STRING87);
                                root_0 = (object)adaptor.BecomeRoot(STRING87_tree, root_0);

                            }
                            break;

                    }
                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("constants", 21);
                    LeaveRule("constants", 21);
                    LeaveRule_constants();
                }
                DebugLocation(220, 40);
            }
            finally { DebugExitRule(GrammarFileName, "constants"); }
            return retval;

        }
        // $ANTLR end "constants"

        partial void EnterRule_call_expr();
        partial void LeaveRule_call_expr();
        // $ANTLR start "call_expr"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:222:2: call_expr : OBJ_ID LPAREN ( invokeExpressions )? RPAREN -> ^( ImplicitInvoke OBJ_ID ( invokeExpressions )? ) ;
        [GrammarRule("call_expr")]
        private AstParserRuleReturnScope<object, IToken> call_expr()
        {
            EnterRule_call_expr();
            EnterRule("call_expr", 22);
            TraceIn("call_expr", 22);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken OBJ_ID88 = default(IToken);
            IToken LPAREN89 = default(IToken);
            IToken RPAREN91 = default(IToken);
            AstParserRuleReturnScope<object, IToken> invokeExpressions90 = default(AstParserRuleReturnScope<object, IToken>);

            object OBJ_ID88_tree = default(object);
            object LPAREN89_tree = default(object);
            object RPAREN91_tree = default(object);
            RewriteRuleITokenStream stream_OBJ_ID = new RewriteRuleITokenStream(adaptor, "token OBJ_ID");
            RewriteRuleITokenStream stream_LPAREN = new RewriteRuleITokenStream(adaptor, "token LPAREN");
            RewriteRuleITokenStream stream_RPAREN = new RewriteRuleITokenStream(adaptor, "token RPAREN");
            RewriteRuleSubtreeStream stream_invokeExpressions = new RewriteRuleSubtreeStream(adaptor, "rule invokeExpressions");
            try
            {
                DebugEnterRule(GrammarFileName, "call_expr");
                DebugLocation(222, 48);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:222:12: ( OBJ_ID LPAREN ( invokeExpressions )? RPAREN -> ^( ImplicitInvoke OBJ_ID ( invokeExpressions )? ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:223:4: OBJ_ID LPAREN ( invokeExpressions )? RPAREN
                    {
                        DebugLocation(223, 4);
                        OBJ_ID88 = (IToken)Match(input, OBJ_ID, Follow._OBJ_ID_in_call_expr1694);
                        stream_OBJ_ID.Add(OBJ_ID88);

                        DebugLocation(223, 12);
                        LPAREN89 = (IToken)Match(input, LPAREN, Follow._LPAREN_in_call_expr1697);
                        stream_LPAREN.Add(LPAREN89);

                        DebugLocation(223, 19);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:223:19: ( invokeExpressions )?
                        int alt25 = 2;
                        try
                        {
                            DebugEnterSubRule(25);
                            try
                            {
                                DebugEnterDecision(25, false);
                                int LA25_1 = input.LA(1);

                                if ((LA25_1 == CASE || LA25_1 == DO || LA25_1 == FALSE || LA25_1 == IF || (LA25_1 >= INTEGER && LA25_1 <= ISVOID) || (LA25_1 >= LET && LA25_1 <= LKEY) || LA25_1 == LPAREN || (LA25_1 >= NEG && LA25_1 <= OBJ_ID) || LA25_1 == SELF || LA25_1 == STRING || LA25_1 == TRUE || LA25_1 == WHILE))
                                {
                                    alt25 = 1;
                                }
                            }
                            finally { DebugExitDecision(25); }
                            switch (alt25)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:223:19: invokeExpressions
                                    {
                                        DebugLocation(223, 19);
                                        PushFollow(Follow._invokeExpressions_in_call_expr1699);
                                        invokeExpressions90 = invokeExpressions();
                                        PopFollow();

                                        stream_invokeExpressions.Add(invokeExpressions90.Tree);

                                    }
                                    break;

                            }
                        }
                        finally { DebugExitSubRule(25); }

                        DebugLocation(223, 39);
                        RPAREN91 = (IToken)Match(input, RPAREN, Follow._RPAREN_in_call_expr1703);
                        stream_RPAREN.Add(RPAREN91);



                        {
                            // AST REWRITE
                            // elements: invokeExpressions, OBJ_ID
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 224:4: -> ^( ImplicitInvoke OBJ_ID ( invokeExpressions )? )
                            {
                                DebugLocation(224, 6);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:224:6: ^( ImplicitInvoke OBJ_ID ( invokeExpressions )? )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(224, 8);
                                    root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ImplicitInvoke, "ImplicitInvoke"), root_1);

                                    DebugLocation(224, 23);
                                    adaptor.AddChild(root_1, stream_OBJ_ID.NextNode());
                                    DebugLocation(224, 30);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:224:30: ( invokeExpressions )?
                                    if (stream_invokeExpressions.HasNext)
                                    {
                                        DebugLocation(224, 30);
                                        adaptor.AddChild(root_1, stream_invokeExpressions.NextTree());

                                    }
                                    stream_invokeExpressions.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("call_expr", 22);
                    LeaveRule("call_expr", 22);
                    LeaveRule_call_expr();
                }
                DebugLocation(224, 48);
            }
            finally { DebugExitRule(GrammarFileName, "call_expr"); }
            return retval;

        }
        // $ANTLR end "call_expr"

        partial void EnterRule_invokeExpressions();
        partial void LeaveRule_invokeExpressions();
        // $ANTLR start "invokeExpressions"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:226:1: invokeExpressions : expression ( COMMA expression )* -> ^( Params ( expression )+ ) ;
        [GrammarRule("invokeExpressions")]
        private AstParserRuleReturnScope<object, IToken> invokeExpressions()
        {
            EnterRule_invokeExpressions();
            EnterRule("invokeExpressions", 23);
            TraceIn("invokeExpressions", 23);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken COMMA93 = default(IToken);
            AstParserRuleReturnScope<object, IToken> expression92 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> expression94 = default(AstParserRuleReturnScope<object, IToken>);

            object COMMA93_tree = default(object);
            RewriteRuleITokenStream stream_COMMA = new RewriteRuleITokenStream(adaptor, "token COMMA");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                DebugEnterRule(GrammarFileName, "invokeExpressions");
                DebugLocation(226, 25);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:226:19: ( expression ( COMMA expression )* -> ^( Params ( expression )+ ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:227:6: expression ( COMMA expression )*
                    {
                        DebugLocation(227, 6);
                        PushFollow(Follow._expression_in_invokeExpressions1733);
                        expression92 = expression();
                        PopFollow();

                        stream_expression.Add(expression92.Tree);
                        DebugLocation(227, 16);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:227:16: ( COMMA expression )*
                        try
                        {
                            DebugEnterSubRule(26);
                            while (true)
                            {
                                int alt26 = 2;
                                try
                                {
                                    DebugEnterDecision(26, false);
                                    int LA26_1 = input.LA(1);

                                    if ((LA26_1 == COMMA))
                                    {
                                        alt26 = 1;
                                    }


                                }
                                finally { DebugExitDecision(26); }
                                switch (alt26)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:227:18: COMMA expression
                                        {
                                            DebugLocation(227, 18);
                                            COMMA93 = (IToken)Match(input, COMMA, Follow._COMMA_in_invokeExpressions1736);
                                            stream_COMMA.Add(COMMA93);

                                            DebugLocation(227, 24);
                                            PushFollow(Follow._expression_in_invokeExpressions1738);
                                            expression94 = expression();
                                            PopFollow();

                                            stream_expression.Add(expression94.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop26;
                                }
                            }

                        loop26:
                            ;

                        }
                        finally { DebugExitSubRule(26); }



                        {
                            // AST REWRITE
                            // elements: expression
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 228:3: -> ^( Params ( expression )+ )
                            {
                                DebugLocation(228, 5);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:228:5: ^( Params ( expression )+ )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(228, 7);
                                    root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(Params, "Params"), root_1);

                                    DebugLocation(228, 14);
                                    if (!(stream_expression.HasNext))
                                    {
                                        throw new RewriteEarlyExitException();
                                    }
                                    while (stream_expression.HasNext)
                                    {
                                        DebugLocation(228, 14);
                                        adaptor.AddChild(root_1, stream_expression.NextTree());

                                    }
                                    stream_expression.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("invokeExpressions", 23);
                    LeaveRule("invokeExpressions", 23);
                    LeaveRule_invokeExpressions();
                }
                DebugLocation(228, 25);
            }
            finally { DebugExitRule(GrammarFileName, "invokeExpressions"); }
            return retval;

        }
        // $ANTLR end "invokeExpressions"

        partial void EnterRule_conditionals_expr();
        partial void LeaveRule_conditionals_expr();
        // $ANTLR start "conditionals_expr"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:230:1: conditionals_expr : IF cond= expression THEN e1= expression ( ELSE e2= expression )? FI -> ^( IF $cond $e1 ( $e2)? ) ;
        [GrammarRule("conditionals_expr")]
        private AstParserRuleReturnScope<object, IToken> conditionals_expr()
        {
            EnterRule_conditionals_expr();
            EnterRule("conditionals_expr", 24);
            TraceIn("conditionals_expr", 24);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken IF95 = default(IToken);
            IToken THEN96 = default(IToken);
            IToken ELSE97 = default(IToken);
            IToken FI98 = default(IToken);
            AstParserRuleReturnScope<object, IToken> cond = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> e1 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> e2 = default(AstParserRuleReturnScope<object, IToken>);

            object IF95_tree = default(object);
            object THEN96_tree = default(object);
            object ELSE97_tree = default(object);
            object FI98_tree = default(object);
            RewriteRuleITokenStream stream_FI = new RewriteRuleITokenStream(adaptor, "token FI");
            RewriteRuleITokenStream stream_ELSE = new RewriteRuleITokenStream(adaptor, "token ELSE");
            RewriteRuleITokenStream stream_THEN = new RewriteRuleITokenStream(adaptor, "token THEN");
            RewriteRuleITokenStream stream_IF = new RewriteRuleITokenStream(adaptor, "token IF");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                DebugEnterRule(GrammarFileName, "conditionals_expr");
                DebugLocation(230, 26);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:230:19: ( IF cond= expression THEN e1= expression ( ELSE e2= expression )? FI -> ^( IF $cond $e1 ( $e2)? ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:231:3: IF cond= expression THEN e1= expression ( ELSE e2= expression )? FI
                    {
                        DebugLocation(231, 3);
                        IF95 = (IToken)Match(input, IF, Follow._IF_in_conditionals_expr1761);
                        stream_IF.Add(IF95);

                        DebugLocation(231, 10);
                        PushFollow(Follow._expression_in_conditionals_expr1765);
                        cond = expression();
                        PopFollow();

                        stream_expression.Add(cond.Tree);
                        DebugLocation(231, 23);
                        THEN96 = (IToken)Match(input, THEN, Follow._THEN_in_conditionals_expr1768);
                        stream_THEN.Add(THEN96);

                        DebugLocation(231, 30);
                        PushFollow(Follow._expression_in_conditionals_expr1773);
                        e1 = expression();
                        PopFollow();

                        stream_expression.Add(e1.Tree);
                        DebugLocation(231, 44);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:231:44: ( ELSE e2= expression )?
                        int alt27 = 2;
                        try
                        {
                            DebugEnterSubRule(27);
                            try
                            {
                                DebugEnterDecision(27, false);
                                int LA27_1 = input.LA(1);

                                if ((LA27_1 == ELSE))
                                {
                                    alt27 = 1;
                                }
                            }
                            finally { DebugExitDecision(27); }
                            switch (alt27)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:231:45: ELSE e2= expression
                                    {
                                        DebugLocation(231, 45);
                                        ELSE97 = (IToken)Match(input, ELSE, Follow._ELSE_in_conditionals_expr1777);
                                        stream_ELSE.Add(ELSE97);

                                        DebugLocation(231, 53);
                                        PushFollow(Follow._expression_in_conditionals_expr1783);
                                        e2 = expression();
                                        PopFollow();

                                        stream_expression.Add(e2.Tree);

                                    }
                                    break;

                            }
                        }
                        finally { DebugExitSubRule(27); }

                        DebugLocation(231, 69);
                        FI98 = (IToken)Match(input, FI, Follow._FI_in_conditionals_expr1788);
                        stream_FI.Add(FI98);



                        {
                            // AST REWRITE
                            // elements: cond, e1, IF, e2
                            // token labels: 
                            // rule labels: cond, e1, e2, retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_cond = new RewriteRuleSubtreeStream(adaptor, "rule cond", cond != null ? cond.Tree : null);
                            RewriteRuleSubtreeStream stream_e1 = new RewriteRuleSubtreeStream(adaptor, "rule e1", e1 != null ? e1.Tree : null);
                            RewriteRuleSubtreeStream stream_e2 = new RewriteRuleSubtreeStream(adaptor, "rule e2", e2 != null ? e2.Tree : null);
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 232:3: -> ^( IF $cond $e1 ( $e2)? )
                            {
                                DebugLocation(232, 6);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:232:6: ^( IF $cond $e1 ( $e2)? )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(232, 8);
                                    root_1 = (object)adaptor.BecomeRoot(stream_IF.NextNode(), root_1);

                                    DebugLocation(232, 13);
                                    adaptor.AddChild(root_1, stream_cond.NextTree());
                                    DebugLocation(232, 19);
                                    adaptor.AddChild(root_1, stream_e1.NextTree());
                                    DebugLocation(232, 23);
                                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:232:23: ( $e2)?
                                    if (stream_e2.HasNext)
                                    {
                                        DebugLocation(232, 23);
                                        adaptor.AddChild(root_1, stream_e2.NextTree());

                                    }
                                    stream_e2.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("conditionals_expr", 24);
                    LeaveRule("conditionals_expr", 24);
                    LeaveRule_conditionals_expr();
                }
                DebugLocation(232, 26);
            }
            finally { DebugExitRule(GrammarFileName, "conditionals_expr"); }
            return retval;

        }
        // $ANTLR end "conditionals_expr"

        partial void EnterRule_loops();
        partial void LeaveRule_loops();
        // $ANTLR start "loops"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:234:1: loops : ( WHILE cond= expression LOOP loop= expression POOL -> ^( WHILE $cond $loop) | DO loop= expression WHILE cond= expression OD -> ^( DoWhile $loop $cond) );
        [GrammarRule("loops")]
        private AstParserRuleReturnScope<object, IToken> loops()
        {
            EnterRule_loops();
            EnterRule("loops", 25);
            TraceIn("loops", 25);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken WHILE99 = default(IToken);
            IToken LOOP100 = default(IToken);
            IToken POOL101 = default(IToken);
            IToken DO102 = default(IToken);
            IToken WHILE103 = default(IToken);
            IToken OD104 = default(IToken);
            AstParserRuleReturnScope<object, IToken> cond = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> loop = default(AstParserRuleReturnScope<object, IToken>);

            object WHILE99_tree = default(object);
            object LOOP100_tree = default(object);
            object POOL101_tree = default(object);
            object DO102_tree = default(object);
            object WHILE103_tree = default(object);
            object OD104_tree = default(object);
            RewriteRuleITokenStream stream_OD = new RewriteRuleITokenStream(adaptor, "token OD");
            RewriteRuleITokenStream stream_LOOP = new RewriteRuleITokenStream(adaptor, "token LOOP");
            RewriteRuleITokenStream stream_POOL = new RewriteRuleITokenStream(adaptor, "token POOL");
            RewriteRuleITokenStream stream_WHILE = new RewriteRuleITokenStream(adaptor, "token WHILE");
            RewriteRuleITokenStream stream_DO = new RewriteRuleITokenStream(adaptor, "token DO");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                DebugEnterRule(GrammarFileName, "loops");
                DebugLocation(234, 28);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:234:7: ( WHILE cond= expression LOOP loop= expression POOL -> ^( WHILE $cond $loop) | DO loop= expression WHILE cond= expression OD -> ^( DoWhile $loop $cond) )
                    int alt28 = 2;
                    try
                    {
                        DebugEnterDecision(28, false);
                        int LA28_1 = input.LA(1);

                        if ((LA28_1 == WHILE))
                        {
                            alt28 = 1;
                        }
                        else if ((LA28_1 == DO))
                        {
                            alt28 = 2;
                        }
                        else
                        {
                            NoViableAltException nvae = new NoViableAltException("", 28, 0, input, 1);
                            DebugRecognitionException(nvae);
                            throw nvae;
                        }
                    }
                    finally { DebugExitDecision(28); }
                    switch (alt28)
                    {
                        case 1:
                            DebugEnterAlt(1);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:235:6: WHILE cond= expression LOOP loop= expression POOL
                            {
                                DebugLocation(235, 6);
                                WHILE99 = (IToken)Match(input, WHILE, Follow._WHILE_in_loops1821);
                                stream_WHILE.Add(WHILE99);

                                DebugLocation(235, 17);
                                PushFollow(Follow._expression_in_loops1827);
                                cond = expression();
                                PopFollow();

                                stream_expression.Add(cond.Tree);
                                DebugLocation(235, 30);
                                LOOP100 = (IToken)Match(input, LOOP, Follow._LOOP_in_loops1829);
                                stream_LOOP.Add(LOOP100);

                                DebugLocation(235, 40);
                                PushFollow(Follow._expression_in_loops1835);
                                loop = expression();
                                PopFollow();

                                stream_expression.Add(loop.Tree);
                                DebugLocation(235, 53);
                                POOL101 = (IToken)Match(input, POOL, Follow._POOL_in_loops1837);
                                stream_POOL.Add(POOL101);



                                {
                                    // AST REWRITE
                                    // elements: loop, cond, WHILE
                                    // token labels: 
                                    // rule labels: loop, cond, retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_loop = new RewriteRuleSubtreeStream(adaptor, "rule loop", loop != null ? loop.Tree : null);
                                    RewriteRuleSubtreeStream stream_cond = new RewriteRuleSubtreeStream(adaptor, "rule cond", cond != null ? cond.Tree : null);
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 236:9: -> ^( WHILE $cond $loop)
                                    {
                                        DebugLocation(236, 11);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:236:11: ^( WHILE $cond $loop)
                                        {
                                            object root_1 = (object)adaptor.Nil();
                                            DebugLocation(236, 14);
                                            root_1 = (object)adaptor.BecomeRoot(stream_WHILE.NextNode(), root_1);

                                            DebugLocation(236, 21);
                                            adaptor.AddChild(root_1, stream_cond.NextTree());
                                            DebugLocation(236, 27);
                                            adaptor.AddChild(root_1, stream_loop.NextTree());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;
                        case 2:
                            DebugEnterAlt(2);
                            // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:238:3: DO loop= expression WHILE cond= expression OD
                            {
                                DebugLocation(238, 3);
                                DO102 = (IToken)Match(input, DO, Follow._DO_in_loops1866);
                                stream_DO.Add(DO102);

                                DebugLocation(238, 10);
                                PushFollow(Follow._expression_in_loops1870);
                                loop = expression();
                                PopFollow();

                                stream_expression.Add(loop.Tree);
                                DebugLocation(238, 23);
                                WHILE103 = (IToken)Match(input, WHILE, Follow._WHILE_in_loops1873);
                                stream_WHILE.Add(WHILE103);

                                DebugLocation(238, 33);
                                PushFollow(Follow._expression_in_loops1877);
                                cond = expression();
                                PopFollow();

                                stream_expression.Add(cond.Tree);
                                DebugLocation(238, 45);
                                OD104 = (IToken)Match(input, OD, Follow._OD_in_loops1879);
                                stream_OD.Add(OD104);



                                {
                                    // AST REWRITE
                                    // elements: loop, cond
                                    // token labels: 
                                    // rule labels: loop, cond, retval
                                    // token list labels: 
                                    // rule list labels: 
                                    // wildcard labels: 
                                    retval.Tree = root_0;
                                    RewriteRuleSubtreeStream stream_loop = new RewriteRuleSubtreeStream(adaptor, "rule loop", loop != null ? loop.Tree : null);
                                    RewriteRuleSubtreeStream stream_cond = new RewriteRuleSubtreeStream(adaptor, "rule cond", cond != null ? cond.Tree : null);
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                                    root_0 = (object)adaptor.Nil();
                                    // 239:3: -> ^( DoWhile $loop $cond)
                                    {
                                        DebugLocation(239, 5);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:239:5: ^( DoWhile $loop $cond)
                                        {
                                            object root_1 = (object)adaptor.Nil();
                                            DebugLocation(239, 7);
                                            root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DoWhile, "DoWhile"), root_1);

                                            DebugLocation(239, 17);
                                            adaptor.AddChild(root_1, stream_loop.NextTree());
                                            DebugLocation(239, 24);
                                            adaptor.AddChild(root_1, stream_cond.NextTree());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                    retval.Tree = root_0;
                                }

                            }
                            break;

                    }
                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("loops", 25);
                    LeaveRule("loops", 25);
                    LeaveRule_loops();
                }
                DebugLocation(239, 28);
            }
            finally { DebugExitRule(GrammarFileName, "loops"); }
            return retval;

        }
        // $ANTLR end "loops"

        partial void EnterRule_blocks();
        partial void LeaveRule_blocks();
        // $ANTLR start "blocks"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:241:1: blocks : LKEY ( expression SEMI )+ RKEY -> ^( Block ( expression )+ ) ;
        [GrammarRule("blocks")]
        private AstParserRuleReturnScope<object, IToken> blocks()
        {
            EnterRule_blocks();
            EnterRule("blocks", 26);
            TraceIn("blocks", 26);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken LKEY105 = default(IToken);
            IToken SEMI107 = default(IToken);
            IToken RKEY108 = default(IToken);
            AstParserRuleReturnScope<object, IToken> expression106 = default(AstParserRuleReturnScope<object, IToken>);

            object LKEY105_tree = default(object);
            object SEMI107_tree = default(object);
            object RKEY108_tree = default(object);
            RewriteRuleITokenStream stream_LKEY = new RewriteRuleITokenStream(adaptor, "token LKEY");
            RewriteRuleITokenStream stream_SEMI = new RewriteRuleITokenStream(adaptor, "token SEMI");
            RewriteRuleITokenStream stream_RKEY = new RewriteRuleITokenStream(adaptor, "token RKEY");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                DebugEnterRule(GrammarFileName, "blocks");
                DebugLocation(241, 24);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:241:8: ( LKEY ( expression SEMI )+ RKEY -> ^( Block ( expression )+ ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:242:9: LKEY ( expression SEMI )+ RKEY
                    {
                        DebugLocation(242, 9);
                        LKEY105 = (IToken)Match(input, LKEY, Follow._LKEY_in_blocks1912);
                        stream_LKEY.Add(LKEY105);

                        DebugLocation(242, 14);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:242:14: ( expression SEMI )+
                        int cnt29 = 0;
                        try
                        {
                            DebugEnterSubRule(29);
                            while (true)
                            {
                                int alt29 = 2;
                                try
                                {
                                    DebugEnterDecision(29, false);
                                    int LA29_1 = input.LA(1);

                                    if ((LA29_1 == CASE || LA29_1 == DO || LA29_1 == FALSE || LA29_1 == IF || (LA29_1 >= INTEGER && LA29_1 <= ISVOID) || (LA29_1 >= LET && LA29_1 <= LKEY) || LA29_1 == LPAREN || (LA29_1 >= NEG && LA29_1 <= OBJ_ID) || LA29_1 == SELF || LA29_1 == STRING || LA29_1 == TRUE || LA29_1 == WHILE))
                                    {
                                        alt29 = 1;
                                    }


                                }
                                finally { DebugExitDecision(29); }
                                switch (alt29)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:242:15: expression SEMI
                                        {
                                            DebugLocation(242, 15);
                                            PushFollow(Follow._expression_in_blocks1915);
                                            expression106 = expression();
                                            PopFollow();

                                            stream_expression.Add(expression106.Tree);
                                            DebugLocation(242, 26);
                                            SEMI107 = (IToken)Match(input, SEMI, Follow._SEMI_in_blocks1917);
                                            stream_SEMI.Add(SEMI107);


                                        }
                                        break;

                                    default:
                                        if (cnt29 >= 1)
                                            goto loop29;

                                        EarlyExitException eee29 = new EarlyExitException(29, input);
                                        DebugRecognitionException(eee29);
                                        throw eee29;
                                }
                                cnt29++;
                            }
                        loop29:
                            ;

                        }
                        finally { DebugExitSubRule(29); }

                        DebugLocation(242, 33);
                        RKEY108 = (IToken)Match(input, RKEY, Follow._RKEY_in_blocks1921);
                        stream_RKEY.Add(RKEY108);



                        {
                            // AST REWRITE
                            // elements: expression
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 243:3: -> ^( Block ( expression )+ )
                            {
                                DebugLocation(243, 5);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:243:5: ^( Block ( expression )+ )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(243, 7);
                                    root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(Block, "Block"), root_1);

                                    DebugLocation(243, 13);
                                    if (!(stream_expression.HasNext))
                                    {
                                        throw new RewriteEarlyExitException();
                                    }
                                    while (stream_expression.HasNext)
                                    {
                                        DebugLocation(243, 13);
                                        adaptor.AddChild(root_1, stream_expression.NextTree());

                                    }
                                    stream_expression.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("blocks", 26);
                    LeaveRule("blocks", 26);
                    LeaveRule_blocks();
                }
                DebugLocation(243, 24);
            }
            finally { DebugExitRule(GrammarFileName, "blocks"); }
            return retval;

        }
        // $ANTLR end "blocks"

        partial void EnterRule_let();
        partial void LeaveRule_let();
        // $ANTLR start "let"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:245:1: let : LET letExprs IN child= expression -> ^( LET letExprs $child) ;
        [GrammarRule("let")]
        private AstParserRuleReturnScope<object, IToken> let()
        {
            EnterRule_let();
            EnterRule("let", 27);
            TraceIn("let", 27);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken LET109 = default(IToken);
            IToken IN111 = default(IToken);
            AstParserRuleReturnScope<object, IToken> child = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> letExprs110 = default(AstParserRuleReturnScope<object, IToken>);

            object LET109_tree = default(object);
            object IN111_tree = default(object);
            RewriteRuleITokenStream stream_IN = new RewriteRuleITokenStream(adaptor, "token IN");
            RewriteRuleITokenStream stream_LET = new RewriteRuleITokenStream(adaptor, "token LET");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            RewriteRuleSubtreeStream stream_letExprs = new RewriteRuleSubtreeStream(adaptor, "rule letExprs");
            try
            {
                DebugEnterRule(GrammarFileName, "let");
                DebugLocation(245, 28);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:245:5: ( LET letExprs IN child= expression -> ^( LET letExprs $child) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:246:6: LET letExprs IN child= expression
                    {
                        DebugLocation(246, 6);
                        LET109 = (IToken)Match(input, LET, Follow._LET_in_let1946);
                        stream_LET.Add(LET109);

                        DebugLocation(246, 10);
                        PushFollow(Follow._letExprs_in_let1948);
                        letExprs110 = letExprs();
                        PopFollow();

                        stream_letExprs.Add(letExprs110.Tree);
                        DebugLocation(246, 19);
                        IN111 = (IToken)Match(input, IN, Follow._IN_in_let1950);
                        stream_IN.Add(IN111);

                        DebugLocation(246, 27);
                        PushFollow(Follow._expression_in_let1955);
                        child = expression();
                        PopFollow();

                        stream_expression.Add(child.Tree);


                        {
                            // AST REWRITE
                            // elements: child, LET, letExprs
                            // token labels: 
                            // rule labels: retval, child
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);
                            RewriteRuleSubtreeStream stream_child = new RewriteRuleSubtreeStream(adaptor, "rule child", child != null ? child.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 247:3: -> ^( LET letExprs $child)
                            {
                                DebugLocation(247, 6);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:247:6: ^( LET letExprs $child)
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(247, 8);
                                    root_1 = (object)adaptor.BecomeRoot(stream_LET.NextNode(), root_1);

                                    DebugLocation(247, 13);
                                    adaptor.AddChild(root_1, stream_letExprs.NextTree());
                                    DebugLocation(247, 23);
                                    adaptor.AddChild(root_1, stream_child.NextTree());

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("let", 27);
                    LeaveRule("let", 27);
                    LeaveRule_let();
                }
                DebugLocation(247, 28);
            }
            finally { DebugExitRule(GrammarFileName, "let"); }
            return retval;

        }
        // $ANTLR end "let"

        partial void EnterRule_letExprs();
        partial void LeaveRule_letExprs();
        // $ANTLR start "letExprs"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:249:1: letExprs : localOrFieldInit ( COMMA localOrFieldInit )* -> ^( LetExprs ( localOrFieldInit )+ ) ;
        [GrammarRule("letExprs")]
        private AstParserRuleReturnScope<object, IToken> letExprs()
        {
            EnterRule_letExprs();
            EnterRule("letExprs", 28);
            TraceIn("letExprs", 28);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken COMMA113 = default(IToken);
            AstParserRuleReturnScope<object, IToken> localOrFieldInit112 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> localOrFieldInit114 = default(AstParserRuleReturnScope<object, IToken>);

            object COMMA113_tree = default(object);
            RewriteRuleITokenStream stream_COMMA = new RewriteRuleITokenStream(adaptor, "token COMMA");
            RewriteRuleSubtreeStream stream_localOrFieldInit = new RewriteRuleSubtreeStream(adaptor, "rule localOrFieldInit");
            try
            {
                DebugEnterRule(GrammarFileName, "letExprs");
                DebugLocation(249, 33);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:249:10: ( localOrFieldInit ( COMMA localOrFieldInit )* -> ^( LetExprs ( localOrFieldInit )+ ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:250:6: localOrFieldInit ( COMMA localOrFieldInit )*
                    {
                        DebugLocation(250, 6);
                        PushFollow(Follow._localOrFieldInit_in_letExprs1983);
                        localOrFieldInit112 = localOrFieldInit();
                        PopFollow();

                        stream_localOrFieldInit.Add(localOrFieldInit112.Tree);
                        DebugLocation(250, 23);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:250:23: ( COMMA localOrFieldInit )*
                        try
                        {
                            DebugEnterSubRule(30);
                            while (true)
                            {
                                int alt30 = 2;
                                try
                                {
                                    DebugEnterDecision(30, false);
                                    int LA30_1 = input.LA(1);

                                    if ((LA30_1 == COMMA))
                                    {
                                        alt30 = 1;
                                    }


                                }
                                finally { DebugExitDecision(30); }
                                switch (alt30)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:250:24: COMMA localOrFieldInit
                                        {
                                            DebugLocation(250, 24);
                                            COMMA113 = (IToken)Match(input, COMMA, Follow._COMMA_in_letExprs1986);
                                            stream_COMMA.Add(COMMA113);

                                            DebugLocation(250, 30);
                                            PushFollow(Follow._localOrFieldInit_in_letExprs1988);
                                            localOrFieldInit114 = localOrFieldInit();
                                            PopFollow();

                                            stream_localOrFieldInit.Add(localOrFieldInit114.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop30;
                                }
                            }

                        loop30:
                            ;

                        }
                        finally { DebugExitSubRule(30); }



                        {
                            // AST REWRITE
                            // elements: localOrFieldInit
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 251:3: -> ^( LetExprs ( localOrFieldInit )+ )
                            {
                                DebugLocation(251, 5);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:251:5: ^( LetExprs ( localOrFieldInit )+ )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(251, 7);
                                    root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LetExprs, "LetExprs"), root_1);

                                    DebugLocation(251, 16);
                                    if (!(stream_localOrFieldInit.HasNext))
                                    {
                                        throw new RewriteEarlyExitException();
                                    }
                                    while (stream_localOrFieldInit.HasNext)
                                    {
                                        DebugLocation(251, 16);
                                        adaptor.AddChild(root_1, stream_localOrFieldInit.NextTree());

                                    }
                                    stream_localOrFieldInit.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("letExprs", 28);
                    LeaveRule("letExprs", 28);
                    LeaveRule_letExprs();
                }
                DebugLocation(251, 33);
            }
            finally { DebugExitRule(GrammarFileName, "letExprs"); }
            return retval;

        }
        // $ANTLR end "letExprs"

        partial void EnterRule_case();
        partial void LeaveRule_case();
        // $ANTLR start "case"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:253:1: case : CASE expression OF ( caseExprs )+ ESAC -> ^( CASE expression ( caseExprs )+ ) ;
        [GrammarRule("case")]
        private AstParserRuleReturnScope<object, IToken> @case()
        {
            EnterRule_case();
            EnterRule("case", 29);
            TraceIn("case", 29);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken CASE115 = default(IToken);
            IToken OF117 = default(IToken);
            IToken ESAC119 = default(IToken);
            AstParserRuleReturnScope<object, IToken> expression116 = default(AstParserRuleReturnScope<object, IToken>);
            AstParserRuleReturnScope<object, IToken> caseExprs118 = default(AstParserRuleReturnScope<object, IToken>);

            object CASE115_tree = default(object);
            object OF117_tree = default(object);
            object ESAC119_tree = default(object);
            RewriteRuleITokenStream stream_ESAC = new RewriteRuleITokenStream(adaptor, "token ESAC");
            RewriteRuleITokenStream stream_OF = new RewriteRuleITokenStream(adaptor, "token OF");
            RewriteRuleITokenStream stream_CASE = new RewriteRuleITokenStream(adaptor, "token CASE");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            RewriteRuleSubtreeStream stream_caseExprs = new RewriteRuleSubtreeStream(adaptor, "rule caseExprs");
            try
            {
                DebugEnterRule(GrammarFileName, "case");
                DebugLocation(253, 34);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:253:6: ( CASE expression OF ( caseExprs )+ ESAC -> ^( CASE expression ( caseExprs )+ ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:254:9: CASE expression OF ( caseExprs )+ ESAC
                    {
                        DebugLocation(254, 9);
                        CASE115 = (IToken)Match(input, CASE, Follow._CASE_in_case2019);
                        stream_CASE.Add(CASE115);

                        DebugLocation(254, 14);
                        PushFollow(Follow._expression_in_case2021);
                        expression116 = expression();
                        PopFollow();

                        stream_expression.Add(expression116.Tree);
                        DebugLocation(254, 26);
                        OF117 = (IToken)Match(input, OF, Follow._OF_in_case2024);
                        stream_OF.Add(OF117);

                        DebugLocation(254, 29);
                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:254:29: ( caseExprs )+
                        int cnt31 = 0;
                        try
                        {
                            DebugEnterSubRule(31);
                            while (true)
                            {
                                int alt31 = 2;
                                try
                                {
                                    DebugEnterDecision(31, false);
                                    int LA31_1 = input.LA(1);

                                    if ((LA31_1 == OBJ_ID))
                                    {
                                        alt31 = 1;
                                    }


                                }
                                finally { DebugExitDecision(31); }
                                switch (alt31)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:254:29: caseExprs
                                        {
                                            DebugLocation(254, 29);
                                            PushFollow(Follow._caseExprs_in_case2026);
                                            caseExprs118 = caseExprs();
                                            PopFollow();

                                            stream_caseExprs.Add(caseExprs118.Tree);

                                        }
                                        break;

                                    default:
                                        if (cnt31 >= 1)
                                            goto loop31;

                                        EarlyExitException eee31 = new EarlyExitException(31, input);
                                        DebugRecognitionException(eee31);
                                        throw eee31;
                                }
                                cnt31++;
                            }
                        loop31:
                            ;

                        }
                        finally { DebugExitSubRule(31); }

                        DebugLocation(254, 41);
                        ESAC119 = (IToken)Match(input, ESAC, Follow._ESAC_in_case2030);
                        stream_ESAC.Add(ESAC119);



                        {
                            // AST REWRITE
                            // elements: expression, caseExprs, CASE
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 255:3: -> ^( CASE expression ( caseExprs )+ )
                            {
                                DebugLocation(255, 6);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:255:6: ^( CASE expression ( caseExprs )+ )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(255, 8);
                                    root_1 = (object)adaptor.BecomeRoot(stream_CASE.NextNode(), root_1);

                                    DebugLocation(255, 13);
                                    adaptor.AddChild(root_1, stream_expression.NextTree());
                                    DebugLocation(255, 24);
                                    if (!(stream_caseExprs.HasNext))
                                    {
                                        throw new RewriteEarlyExitException();
                                    }
                                    while (stream_caseExprs.HasNext)
                                    {
                                        DebugLocation(255, 24);
                                        adaptor.AddChild(root_1, stream_caseExprs.NextTree());

                                    }
                                    stream_caseExprs.Reset();

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("case", 29);
                    LeaveRule("case", 29);
                    LeaveRule_case();
                }
                DebugLocation(255, 34);
            }
            finally { DebugExitRule(GrammarFileName, "case"); }
            return retval;

        }
        // $ANTLR end "case"

        partial void EnterRule_caseExprs();
        partial void LeaveRule_caseExprs();
        // $ANTLR start "caseExprs"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:257:1: caseExprs : OBJ_ID COLON TYPE_ID HENCE expression SEMI -> ^( CaseExpr OBJ_ID TYPE_ID expression ) ;
        [GrammarRule("caseExprs")]
        private AstParserRuleReturnScope<object, IToken> caseExprs()
        {
            EnterRule_caseExprs();
            EnterRule("caseExprs", 30);
            TraceIn("caseExprs", 30);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken OBJ_ID120 = default(IToken);
            IToken COLON121 = default(IToken);
            IToken TYPE_ID122 = default(IToken);
            IToken HENCE123 = default(IToken);
            IToken SEMI125 = default(IToken);
            AstParserRuleReturnScope<object, IToken> expression124 = default(AstParserRuleReturnScope<object, IToken>);

            object OBJ_ID120_tree = default(object);
            object COLON121_tree = default(object);
            object TYPE_ID122_tree = default(object);
            object HENCE123_tree = default(object);
            object SEMI125_tree = default(object);
            RewriteRuleITokenStream stream_OBJ_ID = new RewriteRuleITokenStream(adaptor, "token OBJ_ID");
            RewriteRuleITokenStream stream_TYPE_ID = new RewriteRuleITokenStream(adaptor, "token TYPE_ID");
            RewriteRuleITokenStream stream_HENCE = new RewriteRuleITokenStream(adaptor, "token HENCE");
            RewriteRuleITokenStream stream_SEMI = new RewriteRuleITokenStream(adaptor, "token SEMI");
            RewriteRuleITokenStream stream_COLON = new RewriteRuleITokenStream(adaptor, "token COLON");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                DebugEnterRule(GrammarFileName, "caseExprs");
                DebugLocation(257, 41);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:257:11: ( OBJ_ID COLON TYPE_ID HENCE expression SEMI -> ^( CaseExpr OBJ_ID TYPE_ID expression ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:258:6: OBJ_ID COLON TYPE_ID HENCE expression SEMI
                    {
                        DebugLocation(258, 6);
                        OBJ_ID120 = (IToken)Match(input, OBJ_ID, Follow._OBJ_ID_in_caseExprs2056);
                        stream_OBJ_ID.Add(OBJ_ID120);

                        DebugLocation(258, 13);
                        COLON121 = (IToken)Match(input, COLON, Follow._COLON_in_caseExprs2058);
                        stream_COLON.Add(COLON121);

                        DebugLocation(258, 20);
                        TYPE_ID122 = (IToken)Match(input, TYPE_ID, Follow._TYPE_ID_in_caseExprs2061);
                        stream_TYPE_ID.Add(TYPE_ID122);

                        DebugLocation(258, 28);
                        HENCE123 = (IToken)Match(input, HENCE, Follow._HENCE_in_caseExprs2063);
                        stream_HENCE.Add(HENCE123);

                        DebugLocation(258, 34);
                        PushFollow(Follow._expression_in_caseExprs2065);
                        expression124 = expression();
                        PopFollow();

                        stream_expression.Add(expression124.Tree);
                        DebugLocation(258, 45);
                        SEMI125 = (IToken)Match(input, SEMI, Follow._SEMI_in_caseExprs2067);
                        stream_SEMI.Add(SEMI125);



                        {
                            // AST REWRITE
                            // elements: OBJ_ID, TYPE_ID, expression
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 259:3: -> ^( CaseExpr OBJ_ID TYPE_ID expression )
                            {
                                DebugLocation(259, 5);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:259:5: ^( CaseExpr OBJ_ID TYPE_ID expression )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(259, 7);
                                    root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CaseExpr, "CaseExpr"), root_1);

                                    DebugLocation(259, 16);
                                    adaptor.AddChild(root_1, stream_OBJ_ID.NextNode());
                                    DebugLocation(259, 23);
                                    adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());
                                    DebugLocation(259, 31);
                                    adaptor.AddChild(root_1, stream_expression.NextTree());

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("caseExprs", 30);
                    LeaveRule("caseExprs", 30);
                    LeaveRule_caseExprs();
                }
                DebugLocation(259, 41);
            }
            finally { DebugExitRule(GrammarFileName, "caseExprs"); }
            return retval;

        }
        // $ANTLR end "caseExprs"

        partial void EnterRule_new();
        partial void LeaveRule_new();
        // $ANTLR start "new"
        // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:261:1: new : NEW TYPE_ID -> ^( NEW TYPE_ID ) ;
        [GrammarRule("new")]
        private AstParserRuleReturnScope<object, IToken> @new()
        {
            EnterRule_new();
            EnterRule("new", 31);
            TraceIn("new", 31);
            AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
            retval.Start = (IToken)input.LT(1);

            object root_0 = default(object);

            IToken NEW126 = default(IToken);
            IToken TYPE_ID127 = default(IToken);

            object NEW126_tree = default(object);
            object TYPE_ID127_tree = default(object);
            RewriteRuleITokenStream stream_NEW = new RewriteRuleITokenStream(adaptor, "token NEW");
            RewriteRuleITokenStream stream_TYPE_ID = new RewriteRuleITokenStream(adaptor, "token TYPE_ID");
            try
            {
                DebugEnterRule(GrammarFileName, "new");
                DebugLocation(261, 19);
                try
                {
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:261:5: ( NEW TYPE_ID -> ^( NEW TYPE_ID ) )
                    DebugEnterAlt(1);
                    // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:262:7: NEW TYPE_ID
                    {
                        DebugLocation(262, 7);
                        NEW126 = (IToken)Match(input, NEW, Follow._NEW_in_new2094);
                        stream_NEW.Add(NEW126);

                        DebugLocation(262, 11);
                        TYPE_ID127 = (IToken)Match(input, TYPE_ID, Follow._TYPE_ID_in_new2096);
                        stream_TYPE_ID.Add(TYPE_ID127);



                        {
                            // AST REWRITE
                            // elements: NEW, TYPE_ID
                            // token labels: 
                            // rule labels: retval
                            // token list labels: 
                            // rule list labels: 
                            // wildcard labels: 
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval", retval != null ? retval.Tree : null);

                            root_0 = (object)adaptor.Nil();
                            // 263:3: -> ^( NEW TYPE_ID )
                            {
                                DebugLocation(263, 6);
                                // \\\\Mac\\Home\\Desktop\\Compiler\\Jonathan\\CoolCompiler\\ANTLR\\CoolGrammar.g:263:6: ^( NEW TYPE_ID )
                                {
                                    object root_1 = (object)adaptor.Nil();
                                    DebugLocation(263, 8);
                                    root_1 = (object)adaptor.BecomeRoot(stream_NEW.NextNode(), root_1);

                                    DebugLocation(263, 12);
                                    adaptor.AddChild(root_1, stream_TYPE_ID.NextNode());

                                    adaptor.AddChild(root_0, root_1);
                                }

                            }

                            retval.Tree = root_0;
                        }

                    }

                    retval.Stop = (IToken)input.LT(-1);

                    retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

                }
                catch (RecognitionException re)
                {
                    ReportError(re);
                    Recover(input, re);
                    retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

                }
                finally
                {
                    TraceOut("new", 31);
                    LeaveRule("new", 31);
                    LeaveRule_new();
                }
                DebugLocation(263, 19);
            }
            finally { DebugExitRule(GrammarFileName, "new"); }
            return retval;

        }
        // $ANTLR end "new"
        #endregion Rules


        #region Follow sets
        private static class Follow
        {
            public static readonly BitSet _class_in_program890 = new BitSet(new ulong[] { 0x0UL, 0x20UL });
            public static readonly BitSet _SEMI_in_program892 = new BitSet(new ulong[] { 0x802UL });
            public static readonly BitSet _CLASS_in_class925 = new BitSet(new ulong[] { 0x0UL, 0x200UL });
            public static readonly BitSet _TYPE_ID_in_class927 = new BitSet(new ulong[] { 0x204000000000UL });
            public static readonly BitSet _INHERITS_in_class930 = new BitSet(new ulong[] { 0x0UL, 0x200UL });
            public static readonly BitSet _TYPE_ID_in_class932 = new BitSet(new ulong[] { 0x200000000000UL });
            public static readonly BitSet _LKEY_in_class936 = new BitSet(new ulong[] { 0x400000000000000UL, 0x4UL });
            public static readonly BitSet _feature_list_in_class938 = new BitSet(new ulong[] { 0x0UL, 0x4UL });
            public static readonly BitSet _RKEY_in_class941 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _feature_in_feature_list972 = new BitSet(new ulong[] { 0x0UL, 0x20UL });
            public static readonly BitSet _SEMI_in_feature_list974 = new BitSet(new ulong[] { 0x400000000000002UL });
            public static readonly BitSet _localOrFieldInit_in_feature1002 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _method_in_feature1010 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _OBJ_ID_in_method1027 = new BitSet(new ulong[] { 0x1000000000000UL });
            public static readonly BitSet _LPAREN_in_method1029 = new BitSet(new ulong[] { 0x400000000000000UL, 0x8UL });
            public static readonly BitSet _formal_parameters_in_method1032 = new BitSet(new ulong[] { 0x0UL, 0x8UL });
            public static readonly BitSet _RPAREN_in_method1036 = new BitSet(new ulong[] { 0x1000UL });
            public static readonly BitSet _COLON_in_method1039 = new BitSet(new ulong[] { 0x0UL, 0x200UL });
            public static readonly BitSet _TYPE_ID_in_method1042 = new BitSet(new ulong[] { 0x200000000000UL });
            public static readonly BitSet _LKEY_in_method1044 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_method1046 = new BitSet(new ulong[] { 0x0UL, 0x4UL });
            public static readonly BitSet _RKEY_in_method1048 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _formal_in_formal_parameters1076 = new BitSet(new ulong[] { 0x2002UL });
            public static readonly BitSet _COMMA_in_formal_parameters1079 = new BitSet(new ulong[] { 0x400000000000000UL });
            public static readonly BitSet _formal_in_formal_parameters1081 = new BitSet(new ulong[] { 0x2002UL });
            public static readonly BitSet _OBJ_ID_in_formal1107 = new BitSet(new ulong[] { 0x1000UL });
            public static readonly BitSet _COLON_in_formal1110 = new BitSet(new ulong[] { 0x0UL, 0x200UL });
            public static readonly BitSet _TYPE_ID_in_formal1113 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _OBJ_ID_in_localOrFieldInit1137 = new BitSet(new ulong[] { 0x1000UL });
            public static readonly BitSet _COLON_in_localOrFieldInit1140 = new BitSet(new ulong[] { 0x0UL, 0x200UL });
            public static readonly BitSet _TYPE_ID_in_localOrFieldInit1143 = new BitSet(new ulong[] { 0x22UL });
            public static readonly BitSet _ASSIGN_in_localOrFieldInit1146 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_localOrFieldInit1149 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _let_in_expression1191 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _assig_expr_in_expression1198 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _OBJ_ID_in_assig_expr1217 = new BitSet(new ulong[] { 0x20UL });
            public static readonly BitSet _ASSIGN_in_assig_expr1219 = new BitSet(new ulong[] { 0x781219010080400UL, 0x550UL });
            public static readonly BitSet _not_expr_in_assig_expr1226 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _NOT_in_not_expr1240 = new BitSet(new ulong[] { 0x781219010080400UL, 0x550UL });
            public static readonly BitSet _relation_in_not_expr1247 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _compare_expr_in_relation1266 = new BitSet(new ulong[] { 0x2000000000000012UL });
            public static readonly BitSet _OR_in_relation1272 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _AND_in_relation1275 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _compare_expr_in_relation1280 = new BitSet(new ulong[] { 0x2000000000000012UL });
            public static readonly BitSet _arith_expr_in_compare_expr1296 = new BitSet(new ulong[] { 0x2080602000002UL });
            public static readonly BitSet _LE_in_compare_expr1303 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _LT_in_compare_expr1307 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _GE_in_compare_expr1311 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _GT_in_compare_expr1315 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _EQUAL_in_compare_expr1320 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _arith_expr_in_compare_expr1325 = new BitSet(new ulong[] { 0x2080602000002UL });
            public static readonly BitSet _mult_expr_in_arith_expr1346 = new BitSet(new ulong[] { 0x4010000000000002UL });
            public static readonly BitSet _PLUS_in_arith_expr1352 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _MINUS_in_arith_expr1356 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _mult_expr_in_arith_expr1360 = new BitSet(new ulong[] { 0x4010000000000002UL });
            public static readonly BitSet _isVoid_expr_in_mult_expr1376 = new BitSet(new ulong[] { 0x20000000040002UL });
            public static readonly BitSet _MULT_in_mult_expr1382 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _DIV_in_mult_expr1387 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _isVoid_expr_in_mult_expr1392 = new BitSet(new ulong[] { 0x20000000040002UL });
            public static readonly BitSet _ISVOID_in_isVoid_expr1409 = new BitSet(new ulong[] { 0x581219010080400UL, 0x550UL });
            public static readonly BitSet _neg_expr_in_isVoid_expr1415 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _NEG_in_neg_expr1429 = new BitSet(new ulong[] { 0x581209010080400UL, 0x550UL });
            public static readonly BitSet _dot_expr_in_neg_expr1436 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _term_in_dot_expr1454 = new BitSet(new ulong[] { 0x100042UL });
            public static readonly BitSet _ATSIGN_in_dot_expr1470 = new BitSet(new ulong[] { 0x0UL, 0x200UL });
            public static readonly BitSet _TYPE_ID_in_dot_expr1473 = new BitSet(new ulong[] { 0x100000UL });
            public static readonly BitSet _DOT_in_dot_expr1475 = new BitSet(new ulong[] { 0x400000000000000UL });
            public static readonly BitSet _call_expr_in_dot_expr1478 = new BitSet(new ulong[] { 0x100042UL });
            public static readonly BitSet _DOT_in_dot_expr1501 = new BitSet(new ulong[] { 0x400000000000000UL });
            public static readonly BitSet _call_expr_in_dot_expr1504 = new BitSet(new ulong[] { 0x100042UL });
            public static readonly BitSet _call_expr_in_term1546 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _conditionals_expr_in_term1558 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _loops_in_term1568 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _blocks_in_term1577 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _case_in_term1587 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _new_in_term1596 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _LPAREN_in_term1605 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_term1607 = new BitSet(new ulong[] { 0x0UL, 0x8UL });
            public static readonly BitSet _RPAREN_in_term1609 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _constants_in_term1618 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _identifiers_in_term1627 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _OBJ_ID_in_identifiers1644 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _SELF_in_identifiers1649 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _TRUE_in_constants1663 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _FALSE_in_constants1668 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _INTEGER_in_constants1673 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _STRING_in_constants1678 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _OBJ_ID_in_call_expr1694 = new BitSet(new ulong[] { 0x1000000000000UL });
            public static readonly BitSet _LPAREN_in_call_expr1697 = new BitSet(new ulong[] { 0x781319010080400UL, 0x558UL });
            public static readonly BitSet _invokeExpressions_in_call_expr1699 = new BitSet(new ulong[] { 0x0UL, 0x8UL });
            public static readonly BitSet _RPAREN_in_call_expr1703 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _expression_in_invokeExpressions1733 = new BitSet(new ulong[] { 0x2002UL });
            public static readonly BitSet _COMMA_in_invokeExpressions1736 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_invokeExpressions1738 = new BitSet(new ulong[] { 0x2002UL });
            public static readonly BitSet _IF_in_conditionals_expr1761 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_conditionals_expr1765 = new BitSet(new ulong[] { 0x0UL, 0x80UL });
            public static readonly BitSet _THEN_in_conditionals_expr1768 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_conditionals_expr1773 = new BitSet(new ulong[] { 0x21000000UL });
            public static readonly BitSet _ELSE_in_conditionals_expr1777 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_conditionals_expr1783 = new BitSet(new ulong[] { 0x20000000UL });
            public static readonly BitSet _FI_in_conditionals_expr1788 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _WHILE_in_loops1821 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_loops1827 = new BitSet(new ulong[] { 0x400000000000UL });
            public static readonly BitSet _LOOP_in_loops1829 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_loops1835 = new BitSet(new ulong[] { 0x8000000000000000UL });
            public static readonly BitSet _POOL_in_loops1837 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _DO_in_loops1866 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_loops1870 = new BitSet(new ulong[] { 0x0UL, 0x400UL });
            public static readonly BitSet _WHILE_in_loops1873 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_loops1877 = new BitSet(new ulong[] { 0x800000000000000UL });
            public static readonly BitSet _OD_in_loops1879 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _LKEY_in_blocks1912 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_blocks1915 = new BitSet(new ulong[] { 0x0UL, 0x20UL });
            public static readonly BitSet _SEMI_in_blocks1917 = new BitSet(new ulong[] { 0x781319010080400UL, 0x554UL });
            public static readonly BitSet _RKEY_in_blocks1921 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _LET_in_let1946 = new BitSet(new ulong[] { 0x400000000000000UL });
            public static readonly BitSet _letExprs_in_let1948 = new BitSet(new ulong[] { 0x2000000000UL });
            public static readonly BitSet _IN_in_let1950 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_let1955 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _localOrFieldInit_in_letExprs1983 = new BitSet(new ulong[] { 0x2002UL });
            public static readonly BitSet _COMMA_in_letExprs1986 = new BitSet(new ulong[] { 0x400000000000000UL });
            public static readonly BitSet _localOrFieldInit_in_letExprs1988 = new BitSet(new ulong[] { 0x2002UL });
            public static readonly BitSet _CASE_in_case2019 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_case2021 = new BitSet(new ulong[] { 0x1000000000000000UL });
            public static readonly BitSet _OF_in_case2024 = new BitSet(new ulong[] { 0x400000000000000UL });
            public static readonly BitSet _caseExprs_in_case2026 = new BitSet(new ulong[] { 0x400000004000000UL });
            public static readonly BitSet _ESAC_in_case2030 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _OBJ_ID_in_caseExprs2056 = new BitSet(new ulong[] { 0x1000UL });
            public static readonly BitSet _COLON_in_caseExprs2058 = new BitSet(new ulong[] { 0x0UL, 0x200UL });
            public static readonly BitSet _TYPE_ID_in_caseExprs2061 = new BitSet(new ulong[] { 0x800000000UL });
            public static readonly BitSet _HENCE_in_caseExprs2063 = new BitSet(new ulong[] { 0x781319010080400UL, 0x550UL });
            public static readonly BitSet _expression_in_caseExprs2065 = new BitSet(new ulong[] { 0x0UL, 0x20UL });
            public static readonly BitSet _SEMI_in_caseExprs2067 = new BitSet(new ulong[] { 0x2UL });
            public static readonly BitSet _NEW_in_new2094 = new BitSet(new ulong[] { 0x0UL, 0x200UL });
            public static readonly BitSet _TYPE_ID_in_new2096 = new BitSet(new ulong[] { 0x2UL });
        }
        #endregion Follow sets
    }

} // namespace CoolGrammar
